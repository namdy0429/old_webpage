
<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title></title>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

</head>

<body>

  <!-- Page Content -->
  <div class="container" style="max-width: 1620px">
    <div class="row">
      <h1 class="col-lg-12 col-md-12 mb-12" style="margin-top: 30px;">android_database_sqlite</h1>
      <br>
      <h4 class="col-lg-12 col-md-12 mb-12">query</h4>
    </div>
    
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>google_____google-authenticator-android_____AccountDb_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/google_____google-authenticator-android_____AccountDb.java

android.database.sqlite.SQLiteDatabase.query

/**
   * Returns true if the cursor is null, or contains no rows.
   */
  private Cursor getNames() {
    return mDatabase.<mark>query</mark>(TABLE_NAME, null, null, null, null, null, null, null);
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>yxl_____DownloadProvider_____DownloadProvider_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/yxl_____DownloadProvider_____DownloadProvider.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Delete request headers for downloads matching the given query.
     */    @Override
    public Cursor <mark>query</mark>(final Uri uri, String[] projection,
                        final String selection, final String[] selectionArgs,

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Delete all completed tasks with date < older than date */    /** Return a list of all tasks */
    public Cursor getAllTaskListCursor() {
        return database.<mark>query</mark>(tasksTable, TaskModelForList.FIELD_LIST,
                null, null, null, null, null, null);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Get identifiers for all non-completed tasks */    /** Return a list of all tasks */
    public Cursor getBackupTaskListCursor() {
        return database.<mark>query</mark>(tasksTable, TaskModelForXml.FIELD_LIST,
                null, null, null, null,
                null, null);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dreeves_____TagTime_____PingsDbAdapter_9.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dreeves_____TagTime_____PingsDbAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Fetches a string with space separated list of tags for a ping with the
	 * supplied id
	 */	 */
	public Cursor fetchTaggings(long id, String col_key) {
		return mDb.<mark>query</mark>(true, TAG_PING_TABLE, new String[] { KEY_PID, KEY_TID }, col_key + " = " + id, null, null,
				null, null, null);
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____DatabaseAdapter_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____DatabaseAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Retrieves all records from database table
	 * @return {@link Cursor} to all records in table <code>tableName</code>
	 */	 */
	public Cursor fetchRecord(long rowId){
		return mDb.<mark>query</mark>(mTableName, null, DatabaseSchema.CommonColumns._ID + "=" + rowId,
				null, null, null, null);
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_8.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Get identifiers for all non-completed, non-hidden tasks */    /** Get identifiers for all tasks */
    public HashSet<TaskIdentifier> getAllTaskIdentifiers() {
        Cursor cursor = database.<mark>query</mark>(tasksTable, new String[] { KEY_ROWID },
                null, null, null, null, null, null);
        return createTaskIdentifierSet(cursor);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>NordicSemiconductor_____Android-nRF-Toolbox_____DatabaseHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/NordicSemiconductor_____Android-nRF-Toolbox_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Returns the list of names of all saved configurations.
	 * @return cursor
	 */	 */
	public int getConfigurationsCount() {
		final Cursor cursor = mDatabase.<mark>query</mark>(Tables.CONFIGURATIONS, ID_PROJECTION, NOT_DELETED_SELECTION, null, null, null, null);
		try {
			return cursor.getCount();
		} finally {
			cursor.close();
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Return a list of all tasks */    /** Return a list of all of the tasks matching selection */
    public Cursor getMatchingTasksForProvider(String selection,
                String[] selectionArgs) {
        return database.<mark>query</mark>(tasksTable, TaskModelForProvider.FIELD_LIST,
                selection, selectionArgs, null, null,
                null, null);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matt-allen_____repay-android_____DatabaseHandler_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/matt-allen_____repay-android_____DatabaseHandler.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Add a friend into the database. To get a RepayID, use generateRepayID()
	 * @param friend
	 * @throws android.database.SQLException
	 */	 */
	public int getNumberOfPeople() throws NullPointerException{
		SQLiteDatabase db = this.getReadableDatabase();
		Cursor c = db.<mark>query</mark>(Names.F_TABLENAME,null,null,null,null,null,null);
		return c.getCount();
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>psaravan_____JamsMusicPlayer_____DBAccessHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/psaravan_____JamsMusicPlayer_____DBAccessHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Returns a cursor with unique albums within the database, regardless of the blacklist status.
     */     */
    public Cursor getAllLocalSongs() {
    	String where = SONG_SOURCE + "='local'";
    	String[] columns = { SONG_FILE_PATH };
    	
    	return getDatabase().<mark>query</mark>(MUSIC_LIBRARY_TABLE, columns, where, null, null, null, null);
    	
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>NordicSemiconductor_____Android-nRF-Toolbox_____DatabaseHelper_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/NordicSemiconductor_____Android-nRF-Toolbox_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Returns the XML wth the configuration by id.
	 * @param id the configuration id in the DB
	 * @return the XML with configuration or null
	 */	 */
	public Cursor getConfigurations() {
		return mDatabase.<mark>query</mark>(Tables.CONFIGURATIONS, CONFIGURATION_PROJECTION, NOT_DELETED_SELECTION, null, null, null, ConfigurationContract.Configuration.NAME + " ASC");
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dreeves_____TagTime_____PingsDbAdapter_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dreeves_____TagTime_____PingsDbAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Returns a Cursor for all tags in the database, sorted by their use
	 * frequency
	 */	 */
	public String getTagName(long tid) {
		String ret = "";
		Cursor c = mDb.<mark>query</mark>(TAGS_TABLE, new String[] { KEY_TAG }, KEY_ROWID + "=" + tid, null, null, null, null);
		if (c.getCount() > 0) {
			c.moveToFirst();
			ret = c.getString(c.getColumnIndex(KEY_TAG));
		}
		c.close();
		return ret;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____AlertController_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____AlertController.java

android.database.sqlite.SQLiteDatabase.query

/** Get a list of alerts that are set for the future */    /** Get a cursor to tag identifiers */
    public Cursor getTaskAlertsCursor(TaskIdentifier taskId) throws SQLException {
        Cursor cursor = alertDatabase.<mark>query</mark>(alertsTable,
                Alert.FIELD_LIST, Alert.TASK + " = ?",
                new String[] { taskId.idAsString() }, null, null, null);
        return cursor;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Return a list of all tasks */    /** Return a list of all of the tasks with progress < COMPLETE_PERCENTAGE */
    public Cursor getActiveTaskListCursor() {
        return database.<mark>query</mark>(tasksTable, TaskModelForList.FIELD_LIST,
            AbstractTaskModel.PROGRESS_PERCENTAGE + " < " +
                AbstractTaskModel.COMPLETE_PERCENTAGE, null, null, null,
                null, null);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>NordicSemiconductor_____Android-nRF-Toolbox_____DatabaseHelper_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/NordicSemiconductor_____Android-nRF-Toolbox_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Adds new configuration to the database.
	 * @param name the configuration name
	 * @param configuration the XML
	 * @return the id or -1 if error occurred
	 */	 */
	public Cursor getConfigurationsNames() {
		return mDatabase.<mark>query</mark>(Tables.CONFIGURATIONS, NAME_PROJECTION, NOT_DELETED_SELECTION, null, null, null, ConfigurationContract.Configuration.NAME + " ASC");
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>vx_____connectbot_____HostDatabase_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/vx_____connectbot_____HostDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Unset any hosts using a pubkey ID that has been deleted.
	 * @param pubkeyId
	 */	 */
	public HostBean findHostById(long hostId) {
		HostBean host;

		synchronized (dbLock) {
			SQLiteDatabase db = getReadableDatabase();

			Cursor c = db.<mark>query</mark>(TABLE_HOSTS, null,
					"_id = ?", new String[] { String.valueOf(hostId) },
					null, null, null);

			host = getFirstHostBean(c);
		}

		return host;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>connectbot_____connectbot_____PubkeyDatabase_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/connectbot_____connectbot_____PubkeyDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * @param pubkey
	 */	 */
	public List<CharSequence> allValues(String column) {
		List<CharSequence> list = new ArrayList<>();

		Cursor c = mDb.<mark>query</mark>(TABLE_PUBKEYS, new String[] { "_id", column },
				null, null, null, null, "_id ASC");

		if (c != null) {
			int COL = c.getColumnIndexOrThrow(column);

			while (c.moveToNext())
				list.add(c.getString(COL));

			c.close();
		}

		return list;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>Neamar_____KISS_____DBHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/Neamar_____KISS_____DBHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Retrieve previously selected items for the query
     *
     * @param context android context
     * @param query   query to run
     * @return records with number of use
     */
    private static Cursor getHistoryByRecency(SQLiteDatabase db, int limit) {
        return db.<mark>query</mark>(true, "history", new String[]{"record", "1"}, null, null,
                null, null, "_id DESC", Integer.toString(limit));
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>bishopmatthew_____HackerNews_____Story_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/bishopmatthew_____HackerNews_____Story.java

android.database.sqlite.SQLiteDatabase.query

/** Deletes any cached rows matching page **/
	public static Story cachedById(SQLiteDatabase db, long sId) {
		Story story = new Story();
		Cursor c = db.<mark>query</mark>(story.getTableName(), story.getColNames(), STORY_ID + "=?",
				new String[] { Long.toString(sId) }, null, null, null);

		if (c.moveToFirst()) {
			story.readFromCursor(c);
			c.close();
			return story;
		} else {
			c.close();
			return null;
		}

	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>vx_____connectbot_____HostDatabase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/vx_____connectbot_____HostDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * @param hostId
	 * @return
	 */	 */
	public List<HostBean> getHosts(boolean sortColors) {
		String sortField = sortColors ? FIELD_HOST_COLOR : FIELD_HOST_NICKNAME;
		List<HostBean> hosts;

		synchronized (dbLock) {
			SQLiteDatabase db = this.getReadableDatabase();

			Cursor c = db.<mark>query</mark>(TABLE_HOSTS, null, null, null, null, null, sortField + " ASC");

			hosts = createHostBeans(c);

			c.close();
		}

		return hosts;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>eidottermihi_____rpicheck_____DeviceDbHelper_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/eidottermihi_____rpicheck_____DeviceDbHelper.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close
android.database.sqlite.SQLiteDatabase.close

/**
     * Deletes a device and all device query data of this device.
     *
     * @param id the ID of the Device
     */     */
    public Cursor getFullCommandCursor() {
        SQLiteDatabase db = this.getWritableDatabase();
        return db
                .<mark>query</mark>(COMMANDS_TABLE_NAME, null, null, null, null, null, null);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>connectbot_____connectbot_____HostDatabase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/connectbot_____connectbot_____HostDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * @param hostId host id for the host
	 * @return host matching the hostId or {@code null} if none match
	 */	@Override
	public List<HostBean> getHosts(boolean sortColors) {
		String sortField = sortColors ? FIELD_HOST_COLOR : FIELD_HOST_NICKNAME;
		List<HostBean> hosts;

		Cursor c = mDb.<mark>query</mark>(TABLE_HOSTS, null, null, null, null, null, sortField + " ASC");

		hosts = createHostBeans(c);

		c.close();

		return hosts;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>tomahawk-player_____tomahawk-android_____DatabaseHelper_10.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/tomahawk-player_____tomahawk-android_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * @return the count of all logged ops that should be delivered to the API
     */
    public Cursor getSearchHistoryCursor(String entry) {
        return mDatabase.<mark>query</mark>(TomahawkSQLiteHelper.TABLE_SEARCHHISTORY, null,
                TomahawkSQLiteHelper.SEARCHHISTORY_COLUMN_ENTRY + " LIKE ?",
                new String[]{entry + "%"}, null, null,
                TomahawkSQLiteHelper.SEARCHHISTORY_COLUMN_ID + " DESC");
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dreeves_____TagTime_____PingsDbAdapter_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dreeves_____TagTime_____PingsDbAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Removes the pair with the supplied ping id and tag string from the
	 * database.
	 */	 */
	public long[] getAllTagIds() {
		Cursor all_tids = mDb.<mark>query</mark>(TAGS_TABLE, new String[] { "_id" }, null, null, null, null, null);
		long[] res = new long[all_tids.getCount()];
		int index = 0;
		all_tids.moveToFirst();
		while (!all_tids.isAfterLast()) {
			res[index++] = all_tids.getLong(0);
			all_tids.moveToNext();
		}
		all_tids.close();
		return res;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>stefan-niedermann_____nextcloud-notes_____NoteSQLiteOpenHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/stefan-niedermann_____nextcloud-notes_____NoteSQLiteOpenHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Creates a DBNote object from the current row of a Cursor.
     *
     * @param cursor database cursor
     * @return DBNote
     */
    private void dropIndexes(SQLiteDatabase db) {
        Cursor c = db.<mark>query</mark>("sqlite_master", new String[]{"name"}, "type=?", new String[]{"index"}, null, null, null);
        while (c.moveToNext()) {
            db.execSQL("DROP INDEX " + c.getString(0));
        }
        c.close();
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_9.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Create a weighted list of tasks from the db cursor given */    /** Get identifiers for all non-completed tasks */
    public HashSet<TaskIdentifier> getActiveTaskIdentifiers() {
        Cursor cursor = database.<mark>query</mark>(tasksTable, new String[] { KEY_ROWID },
                AbstractTaskModel.PROGRESS_PERCENTAGE + " < " +
                AbstractTaskModel.COMPLETE_PERCENTAGE, null, null, null, null, null);
        return createTaskIdentifierSet(cursor);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____DatabaseAdapter_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____DatabaseAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Fetch all records from database matching conditions
     * @param where SQL where clause
     * @param whereArgs String arguments for where clause
     * @param orderBy SQL orderby clause
     * @return Cursor to records matching conditions
     */     */
    public Cursor fetchRecord(@NonNull String uid){
        return mDb.<mark>query</mark>(mTableName, null, CommonColumns.COLUMN_UID + "=?" ,
                new String[]{uid}, null, null, null);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>LitePalFramework_____LitePal_____DataHandler_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/LitePalFramework_____LitePal_____DataHandler.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Assign the generated id value to {@link LitePalSupport#baseObjId}. This
	 * value will be used as identify of this model for system use.
	 * 
	 * @param baseObj
	 *            The class of base object.
	 * @param id
	 *            The value of id.
	 */	@SuppressWarnings("unchecked")
	protected <T> List<T> <mark>query</mark>(Class<T> modelClass, String[] columns, String selection,
			String[] selectionArgs, String groupBy, String having, String orderBy, String limit,

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>bishopmatthew_____HackerNews_____Comment_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/bishopmatthew_____HackerNews_____Comment.java

android.database.sqlite.SQLiteDatabase.query

/** Deletes any cached comment rows matching storyId **/	/** Loads a comment from the cache base on on it's commentId **/
	public static Comment readFromCommentId(SQLiteDatabase db, long cId) {
		Comment comment = new Comment();
		Cursor c = db.<mark>query</mark>(comment.getTableName(), comment.getColNames(), COMMENT_ID + "=?",
				new String[] { Long.toString(cId) }, null, null, null);

		if (c.moveToFirst()) {
			comment.readFromCursor(c);
		}

		c.close();
		return comment;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>DaxiaK_____MyDiary_____DBManager_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/DaxiaK_____MyDiary_____DBManager.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Select memo & order for show in memoActivity
     *
     * @param topicId
     * @return
     */
    public Cursor selectDiaryContentByDiaryId(long diaryId) {
        Cursor c = db.<mark>query</mark>(DiaryItemEntry_V2.TABLE_NAME, null, DiaryItemEntry_V2.COLUMN_REF_DIARY__ID + " = ?", new String[]{String.valueOf(diaryId)},
                null, null, DiaryItemEntry_V2.COLUMN_POSITION + " ASC", null);
        if (c != null) {
            c.moveToFirst();
        }
        return c;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matt-allen_____repay-android_____DatabaseHandler_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/matt-allen_____repay-android_____DatabaseHandler.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
	 * Get information on friend by passing in their RepayID
	 * @param repayID
	 * @return Friend object representation of person
	 * @throws IndexOutOfBoundsException
	 * @throws android.database.SQLException
	 */	 */
	public int getNumberOfDebts() throws NullPointerException{
		SQLiteDatabase db = this.getReadableDatabase();
		Cursor c = db.<mark>query</mark>(Names.D_TABLENAME,null,null,null,null,null,null);
		return c.getCount();
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>JetBrains_____android_____TopekaDatabaseHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/JetBrains_____android_____TopekaDatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Scooooooooooore!
     *
     * @param context The context this is running in.
     * @return The score over all Categories.
     */     */
    private static Cursor getCategoryCursor(Context context) {
        SQLiteDatabase readableDatabase = getReadableDatabase(context);
        Cursor data = readableDatabase
                .<mark>query</mark>(CategoryTable.NAME, CategoryTable.PROJECTION, null, null, null, null, null);
        data.moveToFirst();
        return data;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>mjdenham_____and-bible_____MyNoteDBAdapter_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/mjdenham_____and-bible_____MyNoteDBAdapter.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

/** return Dto from current cursor position or null
	 * @param c
	 * @return
	 * @throws NoSuchKeyException
	 */
	public MyNoteDto getMyNoteDto(long id) {
		MyNoteDto mynote = null;
		
		Cursor c = db.<mark>query</mark>(MyNoteQuery.TABLE, MyNoteQuery.COLUMNS, MyNoteColumn._ID+"=?", new String[] {String.valueOf(id)}, null, null, null);
		try {
			if (c.moveToFirst()) {
				mynote = getMyNoteDto(c);
			}
		} finally {
			c.close();
		}
		
		return mynote;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codeka_____wwmmo_____StarStore_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codeka_____wwmmo_____StarStore.java

android.database.sqlite.SQLiteOpenHelper.getReadableDatabase
android.database.sqlite.SQLiteDatabase.query

/**
   * Puts the given value to the data store.
   */   */
  public Long getLastSimulationOfOurStar() {
    SQLiteDatabase db = helper.<mark>getReadableDatabase</mark>();
    try (
        Cursor cursor = db.<mark>query</mark>(
            false, name, new String[]{ "last_simulation" }, "my_empire=1",
            null, null, null, "last_simulation DESC", null)) {
      if (cursor.moveToFirst()) {
        return cursor.getLong(0);
      }
    }

    return null;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>yukuku_____androidbible_____SongDb_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/yukuku_____androidbible_____SongDb.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * For migration
	 */
	private static Cursor querySongs(SQLiteDatabase db, String[] columns, String bookName) {
		Cursor c;
		if (bookName == null) {
			c = db.<mark>query</mark>(Table.SongInfo.tableName(), 
			columns, 
			null, 
			null, 
			null, null, Table.SongInfo.bookName + " asc, " + Table.SongInfo.ordering + " asc");
		} else {
			c = db.<mark>query</mark>(Table.SongInfo.tableName(), 
			columns, 
			Table.SongInfo.bookName + "=?",
			new String[] {bookName},
			null, null, Table.SongInfo.ordering + " asc");
		}
		return c;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>vx_____connectbot_____PubkeyDatabase_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/vx_____connectbot_____PubkeyDatabase.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
	 * @param pubkey
	 */	 */
	public List<CharSequence> allValues(String column) {
		List<CharSequence> list = new LinkedList<CharSequence>();

		SQLiteDatabase db = this.getReadableDatabase();
		Cursor c = db.<mark>query</mark>(TABLE_PUBKEYS, new String[] { "_id", column },
				null, null, null, null, "_id ASC");

		if (c != null) {
			int COL = c.getColumnIndexOrThrow(column);

			while (c.moveToNext())
				list.add(c.getString(COL));

			c.<mark>close</mark>();
		}

		db.<mark>close</mark>();

		return list;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>johannilsson_____sthlmtraveling_____HistoryDbAdapter_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/johannilsson_____sthlmtraveling_____HistoryDbAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Fetch all entries for a specific type.
     * @return a Cursor object
     */     */
    public Cursor fetchByName(int type, String name) {
        String selection = KEY_NAME + "=? AND " + KEY_TYPE + "=?";
        String[] selectionArgs = new String[] {name, String.valueOf(type)};
        Cursor cursor = mDb.<mark>query</mark>(DATABASE_TABLE, ALL, selection,
                selectionArgs, null, null, null);
        if (cursor != null) {
            cursor.moveToFirst();
        }
        return cursor;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_13.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Returns a TaskModelForView corresponding to the given TaskIdentifier */     * Don't forget to close the cursor when you're done. */
    private Cursor fetchTaskCursor(TaskIdentifier taskId, String[] fieldList) {
        long id = taskId.getId();
        Cursor cursor = database.<mark>query</mark>(true, tasksTable, fieldList,
                KEY_ROWID + "=" + id, null, null, null, null, null);
        if (cursor == null)
            throw new SQLException("Returned empty set!");

        cursor.moveToFirst();
        return cursor;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>firebase_____firebase-android-sdk_____SQLiteEventStore_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/firebase_____firebase-android-sdk_____SQLiteEventStore.java

android.database.sqlite.SQLiteDatabase.query

/** Loads metadata pairs for given events. */  @Nullable
  private Long getTransportContextId(SQLiteDatabase db, TransportContext transportContext) {
    try (Cursor cursor =
        db.<mark>query</mark>(
            "transport_contexts",
            new String[] {"_id"},
            "backend_name = ?",
            new String[] {transportContext.getBackendName()},
            null,
            null,
            null)) {
      if (!cursor.moveToNext()) {
        return null;
      }
      return cursor.getLong(0);
    }
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>eidottermihi_____rpicheck_____DeviceDbHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/eidottermihi_____rpicheck_____DeviceDbHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Creates a new device in the device table.
     *
     * @param name        name of device
     * @param host        hostname
     * @param user        username (ssh)
     * @param pass        password (ssh)
     * @param sshPort     SSH port
     * @param description device description
     * @return a {@link RaspberryDeviceBean}
     */     */
    public Cursor getFullDeviceCursor() {
        SQLiteDatabase db = this.getWritableDatabase();
        return db.<mark>query</mark>(DEVICES_TABLE_NAME, null, null, null, null, null, null);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dreeves_____TagTime_____PingsDbAdapter_8.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dreeves_____TagTime_____PingsDbAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Return a Cursor positioned at the note that matches the given rowId
	 * 
	 * @param pingid
	 *            id of note to retrieve
	 * @return Cursor positioned to matching note, if found
	 * @throws SQLException
	 *             if note could not be found/retrieved
	 */	 */
	public boolean isTagPing(long pingid, long tagid) {
		Cursor c = mDb.<mark>query</mark>(TAG_PING_TABLE, new String[] { KEY_ROWID }, KEY_PID + "=" + pingid + " AND " + KEY_TID
				+ "=" + tagid, null, null, null, null);
		boolean ret = c.getCount() > 0;
		c.close();
		return ret;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dreeves_____TagTime_____PingsDbAdapter_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dreeves_____TagTime_____PingsDbAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Finds the id associated with the supplied tag string. Returns -1 if tag
	 * string is not found.
	 * 
	 * @param tag
	 * @return tag_id of tag or -1 if tag does not exist
	 */	 */
	public Cursor fetchAllPings(boolean reverse) {
		if (reverse) {
			return mDb.<mark>query</mark>(PINGS_TABLE, new String[] { KEY_ROWID, KEY_PING, KEY_NOTES, KEY_PERIOD }, null, null,
					null, null, KEY_PING + " DESC");
		} else {
			return mDb.<mark>query</mark>(PINGS_TABLE, new String[] { KEY_ROWID, KEY_PING, KEY_NOTES, KEY_PERIOD }, null, null,
					null, null, KEY_PING + " ASC");
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>naman14_____Timber_____SongPlayCount_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/naman14_____Timber_____SongPlayCount.java

android.database.sqlite.SQLiteDatabase.query

/**
     * This updates all the results for the getTopPlayedResults so that we can get an
     * accurate list of the top played results
     */     */
    public Cursor getTopPlayedResults(int numResults) {
        updateResults();

        final SQLiteDatabase database = mMusicDatabase.getReadableDatabase();
        return database.<mark>query</mark>(SongPlayCountColumns.NAME, new String[]{SongPlayCountColumns.ID},
                null, null, null, null, SongPlayCountColumns.PLAYCOUNTSCORE + " DESC",
                (numResults <= 0 ? null : String.valueOf(numResults)));
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dreeves_____TagTime_____PingsDbAdapter_10.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dreeves_____TagTime_____PingsDbAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Fetch a list of the tag names as a list of strings. This should be faster
	 * than manipulating the string all the time.
	 * 
	 * @param pingid
	 *            the ID of the ping
	 * @return a list of strings including tag names for the indicated ping
	 */	 */
	public Cursor fetchPing(long pingid) throws SQLException {
		Cursor pCursor = mDb.<mark>query</mark>(true, PINGS_TABLE, new String[] { KEY_ROWID, KEY_PING, KEY_NOTES, KEY_PERIOD },
				KEY_ROWID + "=" + pingid, null, null, null, null, null);
		if (pCursor != null) {
			pCursor.moveToFirst();
		}
		return pCursor;

	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker41_____article-android_____DataSource_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker41_____article-android_____DataSource.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Deletes an article and its content.
     *
     * @param article The article to delete.
     */     */
    public Cursor getSavedArticles() {
        return database.<mark>query</mark>(
                ArticleModel.TABLE + " a left outer join " + SourceModel.TABLE + " s " +
                    "on a." + ArticleModel.COLUMN_SOURCE_ID + " = s." + SourceModel.COLUMN_REMOTE_ID,
                null,
                ArticleModel.COLUMN_SAVED + "=1",
                null,
                null,
                null,
                ArticleModel.COLUMN_INSERTED_AT + " desc");
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>cyclestreets_____android_____DbAdapter_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/cyclestreets_____android_____DbAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
   * Return a Cursor positioned at the trip that matches the given rowId
   *
   * @param rowId id of trip to retrieve
   * @return Cursor positioned to matching trip, if found
   * @throws SQLException if trip could not be found/retrieved
   */   */
  public Cursor fetchAllTrips() {
    Cursor c = db_.<mark>query</mark>(DATA_TABLE_TRIPS, new String[] { K_TRIP_ROWID,
        K_TRIP_PURP, K_TRIP_START, K_TRIP_FANCYSTART, K_TRIP_NOTE, K_TRIP_FANCYINFO },
        null, null, null, null, "-" + K_TRIP_START);
    if (c != null && c.getCount()>0) {
      c.moveToFirst();
    }
    return c;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_10.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Delete the given task */    /** Get identifiers for all non-completed, non-hidden tasks */
    public HashSet<TaskIdentifier> getActiveVisibleTaskIdentifiers() {
        Cursor cursor = database.<mark>query</mark>(tasksTable, new String[] { KEY_ROWID },
                AbstractTaskModel.PROGRESS_PERCENTAGE + " < " +
                AbstractTaskModel.COMPLETE_PERCENTAGE + " AND (" +
                AbstractTaskModel.HIDDEN_UNTIL + " ISNULL OR " + AbstractTaskModel.HIDDEN_UNTIL + " < " +
                System.currentTimeMillis() + ")", null, null, null, null, null);
        return createTaskIdentifierSet(cursor);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>AOKP_____frameworks_base_____AccountsDb_16.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/AOKP_____frameworks_base_____AccountsDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Returns a map account -> (package -> visibility)
     */
    Account findDeAccountByAccountId(long accountId) {
        SQLiteDatabase db = mDeDatabase.getReadableDatabase();
        final Cursor cursor = db.<mark>query</mark>(TABLE_ACCOUNTS, new String[] {ACCOUNTS_NAME, ACCOUNTS_TYPE},
                ACCOUNTS_ID + "=? ", new String[] {String.valueOf(accountId)}, null, null, null);
        try {
            while (cursor.moveToNext()) {
                return new Account(cursor.getString(0), cursor.getString(1));
            }
        } finally {
            cursor.close();
        }
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>cyclestreets_____android_____DbAdapter_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/cyclestreets_____android_____DbAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
   * Return a Cursor over the list of all notes in the database
   *
   * @return Cursor over all trips
   */
  public Cursor fetchAllCoordsForTrip(long tripid) {
    try {
      Cursor mCursor = db_.<mark>query</mark>(true, DATA_TABLE_COORDS, new String[] {
          K_POINT_LAT, K_POINT_LGT, K_POINT_TIME,
          K_POINT_ACC, K_POINT_ALT, K_POINT_SPEED },
          K_POINT_TRIP + "=" + tripid,
          null, null, null, K_POINT_TIME, null);

      if (mCursor != null) {
        mCursor.moveToFirst();
      }
      return mCursor;
    } catch (Exception e) {
      //Log.v("GOT!",e.toString());
      return null;
    }
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>hushnymous_____android_frameworks_base_____WebViewDatabaseClassic_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/hushnymous_____android_frameworks_base_____WebViewDatabaseClassic.java

android.database.sqlite.SQLiteDatabase.query

/**
     * @see WebViewDatabase#hasUsernamePassword
     */
    private boolean hasEntries(int tableId) {
        if (!checkInitialized()) {
            return false;
        }

        Cursor cursor = null;
        boolean ret = false;
        try {
            cursor = sDatabase.<mark>query</mark>(mTableNames[tableId], ID_PROJECTION,
                    null, null, null, null, null);
            ret = cursor.moveToFirst() == true;
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, "hasEntries", e);
        } finally {
            if (cursor != null) cursor.close();
        }
        return ret;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>yxl_____DownloadProvider_____DownloadProvider_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/yxl_____DownloadProvider_____DownloadProvider.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete

/**
     * Updates a row in the database
     */     */
    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {
        String where = Downloads.RequestHeaders.COLUMN_DOWNLOAD_ID + "="
                + getDownloadIdFromUri(uri);
        String[] projection = new String[]{
                Downloads.RequestHeaders.COLUMN_HEADER,
                Downloads.RequestHeaders.COLUMN_VALUE};
        Cursor cursor = db.<mark>query</mark>(Downloads.RequestHeaders.HEADERS_DB_TABLE,
                projection, where, null, null, null, null);
        return new ReadOnlyCursorWrapper(cursor);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>xamarin_____XobotOS_____WebViewDatabase_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/xamarin_____XobotOS_____WebViewDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Find out if there are any passwords saved. 
     *
     * @return TRUE if there is passwords saved
     */
    boolean hasCache() {
        if (!checkInitialized()) {
            return false;
        }

        Cursor cursor = null;
        boolean ret = false;
        try {
            cursor = mCacheDatabase.<mark>query</mark>("cache", ID_PROJECTION,
                    null, null, null, null, null);
            ret = cursor.moveToFirst() == true;
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, "hasCache", e);
        } finally {
            if (cursor != null) cursor.close();
        }
        return ret;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>AOKP_____frameworks_base_____AccountsDb_15.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/AOKP_____frameworks_base_____AccountsDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Returns a map from packageNames to visibility.
     */
    Integer findAccountVisibility(long accountId, String packageName) {
        SQLiteDatabase db = mDeDatabase.getReadableDatabase();
        final Cursor cursor = db.<mark>query</mark>(TABLE_VISIBILITY, new String[] {VISIBILITY_VALUE},
                VISIBILITY_ACCOUNTS_ID + "=? AND " + VISIBILITY_PACKAGE + "=? ",
                new String[] {String.valueOf(accountId), packageName}, null, null, null);
        try {
            while (cursor.moveToNext()) {
                return cursor.getInt(0);
            }
        } finally {
            cursor.close();
        }
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>vanilla-music_____vanilla_____CoverCache_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/vanilla-music_____vanilla_____CoverCache.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete

/**
		 * Attempts to create a new bitmap object for given song.
		 * Returns null if no cover art was found
		 *
		 * @param song the function will search for artwork of this object
		 * @param maxPxCount the maximum amount of pixels to return (30*30 = 900)
		 */		 */
		private long getUsedSpace() {
			long usedSpace = -1;
			SQLiteDatabase dbh = getWritableDatabase();
			Cursor cursor = dbh.<mark>query</mark>(TABLE_NAME, new String[]{"SUM(size)"}, null, null, null, null, null);
			if (cursor != null) {
				if (cursor.moveToNext())
					usedSpace = cursor.getLong(0);
				cursor.close();
			}
			return usedSpace;
		}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dreeves_____TagTime_____PingsDbAdapter_11.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dreeves_____TagTime_____PingsDbAdapter.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete

/** Cleans up the tags database, removing all unused tags */	 */
	public String fetchTagString(long pingid) throws Exception {
		Cursor c = mDb.<mark>query</mark>(TAG_PING_TABLE, new String[] { KEY_PID, KEY_TID }, KEY_PID + "=" + pingid, null, null,
				null, null);
		String s = "";
		try {
			c.moveToFirst();
			int idx = c.getColumnIndex(KEY_TID);
			while (!c.isAfterLast()) {
				long tid = c.getLong(idx);
				String t = getTagName(tid);
				if (t.equals("")) {
					Exception e = new Exception("Could not find tag with id=" + tid);
					throw e;
				}
				s += t + " ";
				c.moveToNext();
			}
		} finally {
			c.close();
		}
		return s;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>zom_____Zom-Android_____DictionaryAdapter_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/zom_____Zom-Android_____DictionaryAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
         * This is a function that should only be used if you know what you're doing.
         * It is only here to clear the appended test data. This clears out all data within
         * the table specified when the database connection was opened.
         * @return Returns TRUE if successful. FALSE if not.
         */         */
        public Cursor getAllEntries(String[] columns, String selection, String[] selectionArgs,
                                    String groupBy, String having, String sortBy, String sortOption) {
            return db.<mark>query</mark>(mDefaultTable, columns, selection, selectionArgs, groupBy,
                    having, sortBy + " " + sortOption);
        }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____UserManager_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____UserManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Enable or disable auto sync.
     *
     * @param autoSync
     */     */
    public String getCurrent() {
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database.<mark>query</mark>(DBContract.User.TABLE_NAME,
                new String[]{DBContract.User.COLUMN_NAME_ID},
                DBContract.User.COLUMN_NAME_IS_CURRENT + " =" + 1, null, null,
                null, null);

        if (cursor.moveToFirst()) {

            String out = cursor.getString(0);
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
            return out;
        } else {
            return null;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dreeves_____TagTime_____PingsDbAdapter_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dreeves_____TagTime_____PingsDbAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Returns a Cursor for all tags in the database, sorted by the indicated
	 * method. "FREQ" sorts by occurence frequency, "ALPHA" chooses alphabetic
	 * sort and "ROWID" sorts by the tag ID.
	 */	 */
	public long getTID(String tag) {
		if (LOCAL_LOGV) Log.v(TAG, "getTID(" + tag + ")");
		// return -1 if not found
		long tid = -1;
		Cursor cursor = mDb.<mark>query</mark>(TAGS_TABLE, new String[] { KEY_ROWID, KEY_TAG }, KEY_TAG + "='" + tag + "'", null,
				null, null, null, null);
		if (LOCAL_LOGV) Log.v(TAG, "getTID: queried for tag=" + tag);
		if (cursor.getCount() > 0) {
			cursor.moveToFirst();
			tid = cursor.getLong(cursor.getColumnIndex(KEY_ROWID));
		}
		cursor.close();
		return tid;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matt-allen_____repay-android_____DatabaseHandler_8.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/matt-allen_____repay-android_____DatabaseHandler.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * @param debtID
	 * @return The debt stored against the two given attributes
	 * @throws android.database.SQLException
	 * @throws IndexOutOfBoundsException
	 * @throws java.text.ParseException
	 */	 */
	public Debt getMostRecentDebt() throws ParseException, NullPointerException, SQLiteException,
			CursorIndexOutOfBoundsException{
		SQLiteDatabase db = getReadableDatabase();
		Cursor c;
		c = db.<mark>query</mark>(Names.D_TABLENAME, null, null, null, null, null, null);
		c.moveToLast();
		SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);
		db.close();
		return new Debt(c.getInt(0), c.getString(1), sdf.parse(c.getString(2)),
				new BigDecimal(c.getString(2)), c.getString(3));
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>kabouzeid_____Phonograph_____SongPlayCountStore_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/kabouzeid_____Phonograph_____SongPlayCountStore.java

android.database.sqlite.SQLiteDatabase.beginTransaction
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.setTransactionSuccessful
android.database.sqlite.SQLiteDatabase.endTransaction

/**
     * @param songId The song Id to remove.
     */     */
    public Cursor getTopPlayedResults(int numResults) {
        updateResults();

        final SQLiteDatabase database = getReadableDatabase();
        return database.<mark>query</mark>(SongPlayCountColumns.NAME, new String[]{SongPlayCountColumns.ID},
                null, null, null, null, SongPlayCountColumns.PLAY_COUNT_SCORE + " DESC",
                (numResults <= 0 ? null : String.valueOf(numResults)));
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>yukuku_____androidbible_____SongDb_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/yukuku_____androidbible_____SongDb.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * @return null if there is no song at all
	 */	
	public Song getSong(String bookName, String code) {
		SQLiteDatabase db = helper.getReadableDatabase();
		
		String[] columns = new String[] {
		Table.SongInfo.data.name(), // 0
		Table.SongInfo.dataFormatVersion.name(), // 1
		};
		
		Cursor c = db.<mark>query</mark>(Table.SongInfo.tableName(),
			columns,
			Table.SongInfo.bookName + "=? and " + Table.SongInfo.code + "=?",
			new String[]{bookName, code},
			null, null, null);
		
		try {
			if (c.moveToNext()) {
				byte[] data = c.getBlob(0);
				int dataFormatVersion = c.getInt(1);
				return unmarshallSong(data, dataFormatVersion);
			} else {
				return null;
			}
		} finally {
			c.close();
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker41_____article-android_____DataSource_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker41_____article-android_____DataSource.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Gets a single source from the database.
     *
     * @param remoteId the remote id of the source to grab.
     * @return the source.
     */    @VisibleForTesting
    Long getCategoryId(String name) {
        Cursor cursor = database.<mark>query</mark>(
                CategoryModel.TABLE,
                null,
                CategoryModel.COLUMN_NAME + "=?",
                new String[] {name},
                null,
                null,
                null);

        if (cursor != null && cursor.moveToFirst()) {
            long id = cursor.getLong(cursor.getColumnIndex(CategoryModel.COLUMN_ID));
            cursor.close();
            return id;
        } else {
            return null;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker41_____article-android_____DataSource_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker41_____article-android_____DataSource.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Inserts a source into the database. Also will insert a category if that category does not
     * already exist.
     *
     * @param source the source to insert.
     */     */
    public Cursor getArticlesForSource(long remoteSourceId) {
        return database.<mark>query</mark>(
                ArticleModel.TABLE + " a left outer join " + SourceModel.TABLE + " s " +
                    "on a." + ArticleModel.COLUMN_SOURCE_ID + " = s." + SourceModel.COLUMN_REMOTE_ID,
                null,
                ArticleModel.COLUMN_SOURCE_ID + "=?",
                new String[] {Long.toString(remoteSourceId)},
                null,
                null,
                ArticleModel.COLUMN_INSERTED_AT + " desc");
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____AlertController_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____AlertController.java

android.database.sqlite.SQLiteDatabase.query

/** Remove all alerts from the task */    /** Get a list of alerts for the given task */
    public List<Date> getTaskAlerts(TaskIdentifier
            taskId) throws SQLException {
        List<Date> list = new LinkedList<Date>();
        Cursor cursor = alertDatabase.<mark>query</mark>(alertsTable,
                Alert.FIELD_LIST, Alert.TASK + " = ?",
                new String[] { taskId.idAsString() }, null, null, null);

        try {
            if(cursor.getCount() == 0)
                return list;
            do {
                cursor.moveToNext();
                list.add(new Alert(cursor).getDate());
            } while(!cursor.isLast());

            return list;
        } finally {
            cursor.close();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____UserManager_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____UserManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Sets the time of last sync.
     *
     * @param timeStamp
     */     */
    public String getCurrentEmail() {
        Log.d(TAG, "getCurrentEmail");
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database.<mark>query</mark>(DBContract.User.TABLE_NAME,
                new String[]{DBContract.User.COLUMN_NAME_EMAIL},
                DBContract.User.COLUMN_NAME_IS_CURRENT + " =" + 1, null, null,
                null, null);

        if (cursor.moveToFirst()) {

            String out = cursor.getString(0);
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
            return out;
        } else {
            return null;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TagController_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TagController.java

android.database.sqlite.SQLiteDatabase.query

/** Deletes the tag and removes tag/task mappings */    /** Returns a TaskModelForView corresponding to the given Tag Name */
    public TagModelForView fetchTagFromName(String name) throws SQLException {
        Cursor cursor = tagDatabase.<mark>query</mark>(true, tagsTable,
                TagModelForView.FIELD_LIST,
                AbstractTagModel.NAME + " = ?", new String[] {name}, null, null, null, null);

        try {
            if (cursor != null && cursor.getCount() > 0) {
                cursor.moveToFirst();
                TagModelForView model = new TagModelForView(cursor);
                return model;
            }
            return null;
        } finally {
            if(cursor != null)
                cursor.close();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>JetBrains_____android_____TopekaDatabaseHelper_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/JetBrains_____android_____TopekaDatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Creates a quiz corresponding to the projection provided from a cursor row.
     * Currently only {@link QuizTable#PROJECTION} is supported.
     *
     * @param cursor The Cursor containing the data.
     * @return The created quiz.
     */     */
    public static Category getCategoryWith(Context context, String categoryId) {
        SQLiteDatabase readableDatabase = getReadableDatabase(context);
        String[] selectionArgs = {categoryId};
        Cursor data = readableDatabase
                .<mark>query</mark>(CategoryTable.NAME, CategoryTable.PROJECTION, CategoryTable.COLUMN_ID + "=?",
                        selectionArgs, null, null, null);
        data.moveToFirst();
        return getCategory(data, readableDatabase);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____UserManager_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____UserManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Delets given user from DB
     *
     * @param user
     */     */
    public String isUser(User user) {
        Log.d(TAG, "isUser");
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database.<mark>query</mark>(DBContract.User.TABLE_NAME,
                new String[]{DBContract.User.COLUMN_NAME_ID},
                DBContract.User.COLUMN_NAME_EMAIL + " ='" + user.getEmail()
                        + "'", null, null, null, null
        );

        if (cursor.moveToFirst()) {

            String out = cursor.getString(0);
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
            return out;
        } else {
            return null;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____PersonManager_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____PersonManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Gets person from ID.
     *
     * @param id
     * @return
     */     */
    public int getPerson(Person person) {
        Log.d(TAG, "getPerson");
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database.<mark>query</mark>(DBContract.Person.TABLE_NAME,
                new String[]{DBContract.Person.COLUMN_NAME_ID},
                DBContract.Person.COLUMN_NAME_EMAIL + " ='" + person.getEmail()
                        + "'", null, null, null, null
        );

        if (cursor.moveToFirst()) {

            int out = cursor.getInt(0);
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
            return out;
        } else {
            return -1;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker41_____article-android_____DataSource_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker41_____article-android_____DataSource.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Gets all articles for a particular source.
     *
     * NOTE: this method does not return the content associated with the article, that would be
     *       slow as some articles can get very large.
     *
     * @param remoteSourceId the source to get articles for.
     * @return a cursor of articles.
     */     */
    public Cursor getAllArticles() {
        return database.<mark>query</mark>(
                ArticleModel.TABLE + " a left outer join " + SourceModel.TABLE + " s " +
                    "on a." + ArticleModel.COLUMN_SOURCE_ID + " = s." + SourceModel.COLUMN_REMOTE_ID,
                null,
                null,
                null,
                null,
                null,
                ArticleModel.COLUMN_INSERTED_AT + " desc");
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____SyncDataController_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____SyncDataController.java

android.database.sqlite.SQLiteDatabase.query

/** Get mapping for given task */    /** Get all mappings for the given synchronization service */
    public HashSet<SyncMapping> getSyncMappings(int syncServiceId) throws SQLException {
        HashSet<SyncMapping> list = new HashSet<SyncMapping>();
        Cursor cursor = syncDatabase.<mark>query</mark>(syncTable,
                SyncMapping.FIELD_LIST,
                SyncMapping.SYNC_SERVICE + " = " + syncServiceId,
                null, null, null, null);

        try {
            if(cursor.getCount() == 0)
                return list;
            do {
                cursor.moveToNext();
                list.add(new SyncMapping(cursor));
            } while(!cursor.isLast());

            return list;
        } finally {
            cursor.close();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_11.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Returns a TaskModelForView corresponding to the given TaskIdentifier */    /** Create a weighted list of tasks from the db cursor given */
    public Cursor getTaskListCursorById(List<TaskIdentifier> idList) {

        StringBuilder where = new StringBuilder();
        for(int i = 0; i < idList.size(); i++) {
            where.append(KEY_ROWID);
            where.append("=");
            where.append(idList.get(i).idAsString());
            if(i < idList.size()-1)
                where.append(" OR ");
        }

        // hack for empty arrays
        if(idList.size() == 0)
            where.append("0");

        return database.<mark>query</mark>(true, tasksTable,
                TaskModelForList.FIELD_LIST, where.toString(), null, null,
                null, null, null);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TagController_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TagController.java

android.database.sqlite.SQLiteDatabase.query

/** Get a list of task identifiers for the given tag.
     * This searches for TAGGED tasks only.
     * Use getUntaggedTasks() to get a list of UNTAGGED tasks **/    /** Get a list of all tags */
    public LinkedList<TagModelForView> getAllTags()
            throws SQLException {
        LinkedList<TagModelForView> list = new LinkedList<TagModelForView>();
        Cursor cursor = tagDatabase.<mark>query</mark>(tagsTable,
            TagModelForView.FIELD_LIST, null, null, null, null, null, null);

        try {
	        if(cursor.getCount() == 0)
	            return list;
	        do {
	            cursor.moveToNext();
	            list.add(new TagModelForView(cursor));
	        } while(!cursor.isLast());
        } finally {
        	cursor.close();
        }

        return list;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____MeasurementManager_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____MeasurementManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Check whether the given measurement exists
     *
     * @param ID
     * @return
     */
    public void getch(String id) {
        Log.d(TAG, "checkMeasurement");
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database
                .<mark>query</mark>(DBContract.Measurement.TABLE_NAME,
                        new String[]{DBContract.Measurement.COLUMN_NAME_MID_NECK_GIRTH},
                        DBContract.Measurement.COLUMN_NAME_ID + " ='" + id
                                + "'", null, null, null, null
                );

        if (cursor.moveToFirst()) {

            String out = cursor.getString(0);
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>stefan-niedermann_____nextcloud-notes_____NoteSQLiteOpenHelper_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/stefan-niedermann_____nextcloud-notes_____NoteSQLiteOpenHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Returns a list of all Notes in the Database
     *
     * @return List&lt;Note&gt;
     */    @WorkerThread
    private List<DBNote> getNotesCustom(@NonNull String selection, @NonNull String[] selectionArgs, @Nullable String orderBy) {
        SQLiteDatabase db = getReadableDatabase();
        if (selectionArgs.length > 2) {
            Log.v("Note", selection + "   ----   " + selectionArgs[0] + " " + selectionArgs[1] + " " + selectionArgs[2]);
        }
        Cursor cursor = db.<mark>query</mark>(table_notes, columns, selection, selectionArgs, null, null, orderBy);
        List<DBNote> notes = new ArrayList<>();
        while (cursor.moveToNext()) {
            notes.add(getNoteFromCursor(cursor));
        }
        cursor.close();
        return notes;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____MeasurementManager_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____MeasurementManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Get the picture Id given from API to the given measurements given picture type.
     *
     * @param ID
     * @param type
     * @return
     */     */
    public Measurement getMeasurementSync() {
        Measurement out = null;
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database
                .<mark>query</mark>(DBContract.Measurement.TABLE_NAME, DBContract.Measurement.allColumns,
                        DBContract.Measurement.COLUMN_NAME_IS_SYNCED + " = " + 0
                        , null, null, null, null);
        if (cursor.moveToFirst()) {
            out = createMeasurement(cursor);
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
        }
        return out;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>yukuku_____androidbible_____SongDb_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/yukuku_____androidbible_____SongDb.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

/**
	 * Delete song book together with its songs.
	 * @return number of songs deleted
	 */	 */
	@Nullable public Pair<String /* bookName */, Song> getAnySong() {
		final SQLiteDatabase db = helper.getReadableDatabase();
		try (Cursor c = db.<mark>query</mark>(Table.SongInfo.tableName(), ToStringArray(Table.SongInfo.bookName, Table.SongInfo.data, Table.SongInfo.dataFormatVersion), null, null, null, null, Table.SongInfo.bookName + " asc, " + Table.SongInfo.ordering + " asc", "1")) {
			if (c.moveToNext()) {
				final String bookName = c.getString(0);
				final byte[] data = c.getBlob(1);
				final int dataFormatVersion = c.getInt(2);
				final Song song = unmarshallSong(data, dataFormatVersion);
				return Pair.create(bookName, song);
			} else {
				return null;
			}
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____MeasurementManager_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____MeasurementManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Creates the measurement object using the fields in the given Cursor
     *
     * @param cursor
     * @return
     */     */
    public boolean isMeasurement(String ID) {
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database
                .<mark>query</mark>(DBContract.Measurement.TABLE_NAME, DBContract.Measurement.allColumns,
                        DBContract.Measurement.COLUMN_NAME_ID + " ='" + ID
                                + "'", null, null, null, null
                );
        if (cursor.moveToFirst()) {
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
            return true;
        } else {
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
            return false;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker24_____Talon-for-Twitter_____ActivityDataSource_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker24_____Talon-for-Twitter_____ActivityDataSource.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

/**
     * Find out if the tweet is in the database
     * @param tweetId
     * @param account
     * @return number of favorites on that tweet
     */
    public synchronized Cursor getCursor(int account) {

        String where = ActivitySQLiteHelper.COLUMN_ACCOUNT + " = " + account;

        Cursor cursor;
        try {
            cursor = database.<mark>query</mark>(ActivitySQLiteHelper.TABLE_ACTIVITY,
                    allColumns, where, null, null, null, ActivitySQLiteHelper.COLUMN_TIME + " ASC");
        } catch (Exception e) {
            open();
            cursor = database.<mark>query</mark>(ActivitySQLiteHelper.TABLE_ACTIVITY,
                    allColumns, where, null, null, null, ActivitySQLiteHelper.COLUMN_TIME + " ASC");
        }

        return cursor;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matt-allen_____repay-android_____DatabaseHandler_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/matt-allen_____repay-android_____DatabaseHandler.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Convenience method for knowing how many debt entries are in the database
	 * @return Number of debts in database
	 * @throws NullPointerException If no records are found
	 */	 */
	public ArrayList<Friend> getAllFriends() throws SQLException, NullPointerException, CursorIndexOutOfBoundsException{
		SQLiteDatabase db = this.getReadableDatabase();
		ArrayList<Friend> friends = new ArrayList<Friend>();

		Cursor c = db.<mark>query</mark>(Names.F_TABLENAME, new String[]{Names.F_REPAYID, Names.F_LOOKUPURI, Names.F_NAME, Names.F_DEBT},
				null, null, null, null, null);

		if (c != null && c.getCount() > 0)
		{
			c.moveToFirst();

			do
			{
				friends.add(new Friend(c.getString(0), c.getString(1), c.getString(2), new BigDecimal(c.getString(3))));
			}
			while (c.moveToNext());
		}
		db.close();

		return friends;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>tomahawk-player_____tomahawk-android_____DatabaseHelper_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/tomahawk-player_____tomahawk-android_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * @param playlistId the id by which to get the correct {@link org.tomahawk.libtomahawk.collection.Playlist}
     * @return the stored {@link org.tomahawk.libtomahawk.collection.Playlist} with playlistId as
     * its id
     */     */
    public String getPlaylistLocalId(String hatchetId) {
        String[] columns = new String[]{TomahawkSQLiteHelper.PLAYLISTS_COLUMN_ID};

        Cursor playlistsCursor = mDatabase.<mark>query</mark>(TomahawkSQLiteHelper.TABLE_PLAYLISTS,
                columns, TomahawkSQLiteHelper.PLAYLISTS_COLUMN_HATCHETID + " = ?",
                new String[]{hatchetId}, null, null, null);
        String localId = null;
        if (playlistsCursor.moveToFirst()) {
            localId = playlistsCursor.getString(0);
        }
        playlistsCursor.close();
        return localId;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>mjdenham_____and-bible_____MyNoteDBAdapter_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/mjdenham_____and-bible_____MyNoteDBAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Find bookmark starting at the location specified by key.
	 * If it starts there then the initial part of the key should match.
	 */	
	public List<MyNoteDto> getMyNotesInBook(BibleBook book) {
		Log.d(TAG, "about to getMyNotesInPassage:"+book.getOSIS());
		List<MyNoteDto> notesList = new ArrayList<MyNoteDto>();
		Cursor c = db.<mark>query</mark>(MyNoteQuery.TABLE, MyNoteQuery.COLUMNS, MyNoteColumn.KEY+" LIKE ?", new String []{String.valueOf(book.getOSIS()+".%")}, null, null, null);
		try {
			if (c.moveToFirst()) {
		        while (!c.isAfterLast()) {
		        	MyNoteDto mynote = getMyNoteDto(c);
		    		notesList.add(mynote);
		       	    c.moveToNext();
		        }
			}
		} finally {
	        c.close();
		}
        
		Log.d(TAG, "myNotesInPassage set to " + notesList.size() + " item long list");
        return notesList;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>bishopmatthew_____HackerNews_____Comment_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/bishopmatthew_____HackerNews_____Comment.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Adds these values to the cache, and deletes any expired comments
	 * 
	 * @param timestamp
	 **/	/** Loads a list of comments form the cache based on the parent storyId. **/
	public static List<Comment> getFromCache(SQLiteDatabase db, long sId) {
		Comment firstComment = new Comment();
		List<Comment> comments = null;
		Cursor c = db.<mark>query</mark>(firstComment.getTableName(), firstComment.getColNames(), STORY_ID + "=?",
				new String[] { Long.toString(sId) }, null, null, null);
		if (c.moveToFirst()) {
			comments = new ArrayList<Comment>();
			firstComment.readFromCursor(c);
			comments.add(firstComment);
			c.moveToNext();
			for (int i = 1; i < c.getCount(); i++) {
				Comment comment = new Comment();
				comment.readFromCursor(c);
				comments.add(comment);
				c.moveToNext();
			}
		}

		c.close();
		return comments;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____MeasurementManager_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____MeasurementManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close
android.database.sqlite.SQLiteDatabase.close

/**
     * Checks for un synced measurements and gets them
     *
     * @return
     */     */
    public Measurement getMeasurement(String ID) {
        Log.d(TAG, "getMeasurement");
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database
                .<mark>query</mark>(DBContract.Measurement.TABLE_NAME, DBContract.Measurement.allColumns,
                        DBContract.Measurement.COLUMN_NAME_ID + " ='" + ID
                                + "'", null, null, null, null
                );

        Measurement out = null;
        if (cursor.moveToFirst()) {
            out = createMeasurement(cursor);
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
        }
        return out;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____MapTileProviderDataBase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____MapTileProviderDataBase.java

android.database.sqlite.SQLiteDatabase.isOpen
android.database.sqlite.SQLiteDatabase.query

/**
     * Save tile data to the database, checks if it exists beforehand
     * 
     * @param aTile tile meta data
     * @param tile_data the tile image data
     * @return the size of the tile if successfully added
     * @throws IOException
     */     */
    public boolean hasTile(@NonNull final MapTile aTile) {
        boolean existed = false;
        if (mDatabase.<mark>isOpen</mark>()) {
            final String[] args = new String[] { aTile.rendererID, Integer.toString(aTile.zoomLevel), Integer.toString(aTile.x), Integer.toString(aTile.y) };
            final Cursor c = mDatabase.<mark>query</mark>(T_FSCACHE, new String[] { T_FSCACHE_RENDERER_ID }, T_FSCACHE_WHERE, args, null, null, null);
            existed = c.getCount() > 0;
            c.close();
        }
        return existed;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>tomahawk-player_____tomahawk-android_____DatabaseHelper_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/tomahawk-player_____tomahawk-android_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * @param playlistId the id by which to get the correct {@link org.tomahawk.libtomahawk.collection.Playlist}
     * @return the playlist's name, null if playlist not found
     */     */
    public String getPlaylistHatchetId(String playlistId) {
        if (playlistId == null) {
            return null;
        }
        String[] columns = new String[]{TomahawkSQLiteHelper.PLAYLISTS_COLUMN_HATCHETID};
        Cursor playlistsCursor = mDatabase.<mark>query</mark>(TomahawkSQLiteHelper.TABLE_PLAYLISTS,
                columns, TomahawkSQLiteHelper.PLAYLISTS_COLUMN_ID + " = ?",
                new String[]{playlistId}, null, null, null);
        String hatchetId = null;
        if (playlistsCursor.moveToFirst()) {
            hatchetId = playlistsCursor.getString(0);
        }
        playlistsCursor.close();
        return hatchetId;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____SyncDataController_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____SyncDataController.java

android.database.sqlite.SQLiteDatabase.query

/** Saves the given task to the database. Returns true on success. */    /** Get all mappings for specified task for all synchronization services */
    public HashSet<SyncMapping> getSyncMappings(TaskIdentifier taskId)
            throws SQLException {
        HashSet<SyncMapping> list = new HashSet<SyncMapping>();
        Cursor cursor = syncDatabase.<mark>query</mark>(syncTable,
                SyncMapping.FIELD_LIST,
                SyncMapping.TASK + " = ?",
                new String[] { "" + taskId.getId() },
                null, null, null);

        try {
            if(cursor.getCount() == 0)
                return list;
            do {
                cursor.moveToNext();
                list.add(new SyncMapping(cursor));
            } while(!cursor.isLast());

            return list;
        } finally {
            cursor.close();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>NordicSemiconductor_____Android-nRF-Toolbox_____DatabaseHelper_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/NordicSemiconductor_____Android-nRF-Toolbox_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.update
android.database.sqlite.SQLiteDatabase.query

/**
	 * Renames the server configuration and replaces its XML (name inside has changed).
	 * @param oldName the old name to look for
	 * @param newName the new configuration name
	 * @param configuration the new XML
	 * @return number of rows affected
	 */	 */
	public long deleteConfiguration(final String name) {
		mSingleArg[0] = name;

		final ContentValues values = mValues;
		values.clear();
		values.put(ConfigurationContract.Configuration.DELETED, 1);
		mDatabase.<mark>update</mark>(Tables.CONFIGURATIONS, values, NAME_SELECTION, mSingleArg);

		final Cursor cursor = mDatabase.<mark>query</mark>(Tables.CONFIGURATIONS, ID_PROJECTION, NAME_SELECTION, mSingleArg, null, null, null);
		try {
			if (cursor.moveToNext())
				return cursor.getLong(0 /* _ID */);
			return -1;
		} finally {
			cursor.close();
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____DatabaseAdapter_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____DatabaseAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Returns the commodity GUID for the given ISO 4217 currency code
     * @param currencyCode ISO 4217 currency code
     * @return GUID of commodity
     */     */
    public String getUID(long id){
        Cursor cursor = mDb.<mark>query</mark>(mTableName,
                new String[]{DatabaseSchema.CommonColumns.COLUMN_UID},
                DatabaseSchema.CommonColumns._ID + " = " + id,
                null, null, null, null);

        String uid = null;
        try {
            if (cursor.moveToFirst()) {
                uid = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseSchema.CommonColumns.COLUMN_UID));
            } else {
                throw new IllegalArgumentException(mTableName + " Record ID " + id + " does not exist in the db");
            }
        } finally {
            cursor.close();
        }
        return uid;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____UserManager_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____UserManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Gets the time of last sync
     *
     * @return
     */     */
    public boolean getAutoSync() {
        Log.d(TAG, "getAutoSync");
        String email = getCurrentEmail();
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database.<mark>query</mark>(DBContract.User.TABLE_NAME,
                new String[]{DBContract.User.COLUMN_NAME_AUTO_SYNC},
                DBContract.User.COLUMN_NAME_EMAIL + " = '" + email + "'", null, null,
                null, null);

        if (cursor.moveToFirst()) {

            int out = cursor.getInt(0);
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
            if (out == 1) {
                return true;
            } else {
                return false;
            }

        } else {
            return false;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>aws_____aws-sdk-android_____SQLiteLocalStorage_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/aws_____aws-sdk-android_____SQLiteLocalStorage.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Close the local storage. Any operation called after this will fail.
     */    @Override
    public long getLastSyncCount(String identityId, String datasetName) {
        long lastSyncCount = 0;

        SQLiteDatabase db = helper.getWritableDatabase();
        Cursor c = db.<mark>query</mark>(TABLE_DATASETS, DatasetColumns.ALL,
                DatasetColumns.IDENTITY_ID + " = ? AND " + DatasetColumns.DATASET_NAME + " = ?",
                new String[] {
                        identityId, datasetName
                }, null, null, null);
        if (c.moveToFirst()) {
            lastSyncCount = c.getInt(c.getColumnIndex(DatasetColumns.LAST_SYNC_COUNT));
        } else {
            Log.w(TAG, String.format("couldn't find %s in %s table",
                    datasetName, TABLE_DATASETS));
        }
        c.close();

        return lastSyncCount;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>Odoo-mobile_____framework_____OModel_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/Odoo-mobile_____framework_____OModel.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Handle record values for insert, update, delete operation with relation columns
     * Each record have different behaviour, appending, deleting, unlink reference and
     * replacing with new list
     *
     * @param record_id Main record id on which relation values affected
     * @param column    column object of the record (for relation column only)
     * @param values    values list with commands (@see RelCommands)
     */
    public int selectRowId(String selection, String[] args) {
        int row_id = INVALID_ROW_ID;
        SQLiteDatabase db = getReadableDatabase();
        Cursor cr = db.<mark>query</mark>(getTableName(), new String[]{OColumn.ROW_ID}, selection, args, null, null, null);
        try {
            if (cr.moveToFirst()) {
                row_id = cr.getInt(0);
            }
        } finally {
            cr.close();
        }
        return row_id;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>xamarin_____XobotOS_____WebViewDatabase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/xamarin_____XobotOS_____WebViewDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Delete cookies which matches (domain, path, name).
     *
     * @param domain If it is null, nothing happens.
     * @param path If it is null, all the cookies match (domain) will be
     *            deleted.
     * @param name If it is null, all the cookies match (domain, path) will be
     *            deleted.
     */
    private boolean hasEntries(int tableId) {
        if (!checkInitialized()) {
            return false;
        }

        Cursor cursor = null;
        boolean ret = false;
        try {
            cursor = mDatabase.<mark>query</mark>(mTableNames[tableId], ID_PROJECTION,
                    null, null, null, null, null);
            ret = cursor.moveToFirst() == true;
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, "hasEntries", e);
        } finally {
            if (cursor != null) cursor.close();
        }
        return ret;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>Ansh1234_____AppDataReader_____SqliteDatabaseReader_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/Ansh1234_____AppDataReader_____SqliteDatabaseReader.java

android.database.sqlite.SQLiteDatabase.query

/**
   * This method is used to return the data of an individual row.
   *
   * @param cursor
   * @param columnCount
   * @return
   */
  public static String[] getColumnNames(Context context, String databaseName, String
      tableName) {

    if (context == null || Utils.isEmpty(databaseName) || Utils.isEmpty(tableName)) {
      return null;
    }

    SQLiteDatabase sqLiteDatabase;
    try {
      sqLiteDatabase = context.openOrCreateDatabase(databaseName, 0, null);
    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }
    Cursor cursor = sqLiteDatabase.<mark>query</mark>(tableName, null, null, null, null, null, null);

    if (cursor == null) {
      return null;
    }


    //Get the column names
    String[] columnNames = cursor.getColumnNames();
    if (columnNames == null || columnNames.length == 0) {
      return null;
    }
    return columnNames;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____TileLayerDatabase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____TileLayerDatabase.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

/**
     * Retrieve a single layer identified by its mysql rowid
     * 
     * @param context Androic Context
     * @param db readable SWLiteDatabase
     * @param rowId the mysql rowid
     * @return a TileLayerServer instance of null if none could be found
     */     */
    public static long getSourceUpdate(@NonNull SQLiteDatabase db, @NonNull String source) {
        Cursor dbresult = db.<mark>query</mark>(SOURCES_TABLE, null, NAME_FIELD + "='" + source + "'", null, null, null, null);
        try {
            if (dbresult.getCount() >= 1) {
                boolean haveEntry = dbresult.moveToFirst();
                if (haveEntry) {
                    return dbresult.getLong(dbresult.getColumnIndex(UPDATED_FIELD));
                }
            }
            return 0;
        } finally {
            dbresult.close();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_12.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Returns null if unsuccessful, otherwise moves cursor to the task.
     * Don't forget to close the cursor when you're done. */    /** Returns a TaskModelForView by name */
    public TaskModelForSync searchForTaskForSync(String name) throws SQLException {
        Cursor cursor = database.<mark>query</mark>(true, tasksTable, TaskModelForSync.FIELD_LIST,
                AbstractTaskModel.NAME + " = ? AND " +
                    AbstractTaskModel.PROGRESS_PERCENTAGE + " < "+
                        AbstractTaskModel.COMPLETE_PERCENTAGE,
                new String[] { name }, null, null, null, null);
        try {
            if (cursor == null || cursor.getCount() == 0)
                return null;
            cursor.moveToFirst();
            TaskModelForSync model = new TaskModelForSync(cursor);
            return model;
        } finally {
            if(cursor != null)
                cursor.close();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>aws_____aws-sdk-android_____SQLiteLocalStorage_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/aws_____aws-sdk-android_____SQLiteLocalStorage.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Converts a Cursor object into a Record object. This could potentially
     * throws exception if the stored record has bogus data that fails the
     * constructor.
     * 
     * @param c a Cursor object
     * @return a Record object.
     */    @Override
    public Record getRecord(String identityId, String datasetName, String key) {
        Record record = null;

        SQLiteDatabase db = helper.getWritableDatabase();
        Cursor c = db.<mark>query</mark>(TABLE_RECORDS, RecordColumns.ALL,
                RecordColumns.IDENTITY_ID + " = ? AND "
                        + RecordColumns.DATASET_NAME + " = ? AND "
                        + RecordColumns.KEY + " = ?",
                new String[] {
                        identityId, datasetName, key
                }, null, null, null);
        if (c.moveToFirst()) {
            record = cursorToRecord(c);
        }
        c.close();

        return record;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____MeasurementManager_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____MeasurementManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Deletes the given measurement and add it's ID to delete table.
     *
     * @param ID
     * @param personID
     */     */
    public boolean isSyncedOnce(String ID) {
        Log.d(TAG, "isSyncedOnce");
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database
                .<mark>query</mark>(DBContract.Measurement.TABLE_NAME,
                        new String[]{DBContract.Measurement.COLUMN_NAME_SYNCED_ONCE},
                        DBContract.Measurement.COLUMN_NAME_ID + " = '" + ID + "'"
                        , null, null, null, null);
        if (cursor.moveToFirst()) {
            int val = cursor.getInt(0);
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
            if (val == 1) {
                return true;
            } else {
                return false;
            }
        }
        return false;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>haiwen_____seadroid_____DatabaseHelper_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/haiwen_____seadroid_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Tell if a record exists already.
     */     */
    public String getRepoDir(Account account, String repoID) {
        String[] projection = {
            REPODIR_COLUMN_REPO_DIR
        };

        String selectClause = String.format("%s = ? and %s = ?",
                                            REPODIR_COLUMN_ACCOUNT,
                                            REPODIR_COLUMN_REPO_ID);

        String[] selectArgs = { account.getSignature(), repoID };


        Cursor cursor = database.<mark>query</mark>(
            REPODIR_TABLE_NAME,
            projection,
            selectClause,
            selectArgs,
            null,   // don't group the rows
            null,   // don't filter by row groups
            null);  // The sort order

        if (!cursor.moveToFirst()) {
            cursor.close();
            return null;
        }

        String dir = cursor.getString(0);
        cursor.close();

        return dir;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____DatabaseAdapter_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____DatabaseAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Returns the {@link org.gnucash.android.model.AccountType} of the account with unique ID <code>uid</code>
     * @param accountUID Unique ID of the account
     * @return {@link org.gnucash.android.model.AccountType} of the account.
     * @throws java.lang.IllegalArgumentException if accountUID does not exist in DB,
     */     */
    public String getAccountCurrencyCode(@NonNull String accountUID) {
        Cursor cursor = mDb.<mark>query</mark>(DatabaseSchema.AccountEntry.TABLE_NAME,
                new String[] {DatabaseSchema.AccountEntry.COLUMN_CURRENCY},
                DatabaseSchema.AccountEntry.COLUMN_UID + "= ?",
                new String[]{accountUID}, null, null, null);
        try {
            if (cursor.moveToFirst()) {
                return cursor.getString(0);
            } else {
                throw new IllegalArgumentException("Account " + accountUID + " does not exist");
            }
        } finally {
            cursor.close();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matt-allen_____repay-android_____DatabaseHandler_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/matt-allen_____repay-android_____DatabaseHandler.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
	 * @param debtID
	 * @return The debt stored against the two given attributes
	 * @throws android.database.SQLException
	 * @throws IndexOutOfBoundsException
	 * @throws java.text.ParseException
	 */	 */
	public Friend getFriendByRepayID(String repayID) throws IndexOutOfBoundsException, SQLException, NullPointerException{
		Friend friend = null;
		Cursor c = null;
		SQLiteDatabase db = this.getReadableDatabase();
		c = db.<mark>query</mark>(Names.F_TABLENAME, new String[]{Names.F_REPAYID, Names.F_LOOKUPURI, Names.F_NAME, Names.F_DEBT},
				Names.F_REPAYID+"=?", new String[]{repayID}, null, null, null);
		c.moveToFirst();
		try {
			friend = new Friend(repayID, c.getString(1), c.getString(2), new BigDecimal(c.getString(3)));
		} catch (NullPointerException e) {
			Log.i(TAG, "No ContactURI present, passing null");
			friend = new Friend(repayID, null, c.getString(2), new BigDecimal(c.getString(3)));
		}
		db.<mark>close</mark>();
		return friend;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codeka_____wwmmo_____ChatStore_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codeka_____wwmmo_____ChatStore.java

android.database.sqlite.SQLiteOpenHelper.getReadableDatabase
android.database.sqlite.SQLiteDatabase.query

  /** Gets all messages, regardless of room, from the given start time. */
  public List<ChatMessage> getMessages(long time, int count) {
    ArrayList<ChatMessage> msgs = new ArrayList<>();
    SQLiteDatabase db = helper.<mark>getReadableDatabase</mark>();
    try (
        Cursor cursor = db.<mark>query</mark>(
            name + "_messages",
            new String[] { "msg" } /* columns */,
            "date_posted <= ?" /* selection */,
            new String[] { String.format(Locale.US, "%d", time) } /* selectionArgs */,
            null /* groupBy */,
            null /* having */,
            "date_posted DESC" /* orderBy */,
            String.format(Locale.US, "%d", count))) {
      while (cursor.moveToNext()) {
        msgs.add(ChatMessage.ADAPTER.decode(cursor.getBlob(0)));
      }
      Collections.reverse(msgs); // Make it oldest-first.
    } catch (IOException e) {
      log.error("Error fetching chat messages.", e);
    }
    return msgs;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____TileLayerDatabase_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____TileLayerDatabase.java

android.database.sqlite.SQLiteDatabase.rawQuery
android.database.sqlite.SQLiteDatabase.query

/**
     * Get a Cursor for all user defined layers
     * 
     * @param db a readable SQLiteDatabase
     * @return a Cursor pointing to all custom imagery layers
     */     */
    public static TileLayerServer getLayer(@NonNull Context context, @NonNull SQLiteDatabase db, @NonNull String id) {
        TileLayerServer layer = null;
        Cursor dbresult = db.<mark>query</mark>(COVERAGES_TABLE, null, ID_FIELD + "='" + id + "'", null, null, null, null);
        Provider provider = getProviderFromCursor(dbresult);

        dbresult = db.<mark>query</mark>(LAYERS_TABLE, null, ID_FIELD + "='" + id + "'", null, null, null, null);
        if (dbresult.getCount() >= 1) {
            boolean haveEntry = dbresult.moveToFirst();
            if (haveEntry) {
                initLayerFieldIndices(dbresult);
                layer = getLayerFromCursor(context, provider, dbresult);
            }
        }
        dbresult.close();
        return layer;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>haiwen_____seadroid_____DatabaseHelper_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/haiwen_____seadroid_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Return the number of cached dirs that reference a specific dirID.
     * Used for cache cleaning.
     *
     * @param dirID
     * @return
     */     */
    public boolean repoDirExists(Account account, String dir) {
        String[] projection = {
            REPODIR_COLUMN_REPO_DIR
        };

        String selectClause = String.format("%s = ? and %s = ?",
                                            REPODIR_COLUMN_ACCOUNT,
                                            REPODIR_COLUMN_REPO_DIR);
        String[] selectArgs = { account.getSignature(), dir };

        Cursor cursor = database.<mark>query</mark>(
            REPODIR_TABLE_NAME,
            projection,
            selectClause,
            selectArgs,
            null,   // don't group the rows
            null,   // don't filter by row groups
            null);  // The sort order

        boolean exist = true;
        if (!cursor.moveToFirst()) {
            exist = false;
        }
        cursor.close();

        return exist;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>LitePalFramework_____LitePal_____DataHandler_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/LitePalFramework_____LitePal_____DataHandler.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Get the foreign key associations of the specified class.
	 * 
	 * @param className
	 *            The full class name.
	 * @param isEager
	 *            True to load the associated models, false not.
	 * @return The foreign key associations of the specified class
	 */	@SuppressWarnings("unchecked")
	protected <T> T mathQuery(String tableName, String[] columns, String[] conditions, Class<T> type) {
		BaseUtility.checkConditionsCorrect(conditions);
		Cursor cursor = null;
		T result = null;
		try {
			cursor = mDatabase.<mark>query</mark>(tableName, columns, getWhereClause(conditions),
					getWhereArgs(conditions), null, null, null);
			if (cursor.moveToFirst()) {
				Class<?> cursorClass = cursor.getClass();
				Method method = cursorClass.getMethod(genGetColumnMethod(type), int.class);
				result = (T) method.invoke(cursor, 0);
			}
		} catch (Exception e) {
			throw new LitePalSupportException(e.getMessage(), e);
		} finally {
			if (cursor != null) {
				cursor.close();
			}
		}
		return result;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Return a list of all of the tasks matching selection */    /** Return a list of all active tasks with deadlines */
    public ArrayList<TaskModelForNotify> getTasksWithDeadlines() {
        ArrayList<TaskModelForNotify> list = new ArrayList<TaskModelForNotify>();
        Cursor cursor = database.<mark>query</mark>(tasksTable, TaskModelForNotify.FIELD_LIST,
                String.format("%s < %d AND (%s != 0 OR %s != 0)",
                        AbstractTaskModel.PROGRESS_PERCENTAGE,
                        AbstractTaskModel.COMPLETE_PERCENTAGE,
                        AbstractTaskModel.DEFINITE_DUE_DATE,
                        AbstractTaskModel.PREFERRED_DUE_DATE), null, null, null, null, null);

        try {
            if(cursor.getCount() == 0)
                return list;

            do {
                cursor.moveToNext();
                list.add(new TaskModelForNotify(cursor));
            } while(!cursor.isLast());

            return list;
        } finally {
            cursor.close();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>aws_____aws-sdk-android_____SQLiteLocalStorage_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/aws_____aws-sdk-android_____SQLiteLocalStorage.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Internal helper function to update one dataset metadata.
     * 
     * @param db SQLiteDatabase handler
     * @param identityId identity id of the datasets
     * @param metadata dataset metadata to update
     * @return true if update successfully, false otherwise
     */    @Override
    public List<Record> getModifiedRecords(String identityId, String datasetName) {
        List<Record> records = new ArrayList<Record>();

        SQLiteDatabase db = helper.getWritableDatabase();
        Cursor c = db.<mark>query</mark>(TABLE_RECORDS, RecordColumns.ALL,
                RecordColumns.IDENTITY_ID + " = ? AND " + RecordColumns.DATASET_NAME + " = ? AND "
                        + RecordColumns.MODIFIED + " = ?",
                new String[] {
                        identityId, datasetName,
                        String.valueOf(1)
                }, null, null, null);
        while (c.moveToNext()) {
            records.add(cursorToRecord(c));
        }
        c.close();

        return records;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>connectbot_____connectbot_____HostDatabase_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/connectbot_____connectbot_____HostDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Update the parameters of a port forward in the database.
	 * @param pfb {@link PortForwardBean} to save
	 * @return true on success
	 */	@Override
	public List<String> getHostKeyAlgorithmsForHost(String hostname, int port) {
		HashMap<String, String> selection = new HashMap<>();
		selection.put(FIELD_HOST_HOSTNAME, hostname);
		selection.put(FIELD_HOST_PORT, String.valueOf(port));
		HostBean hostBean = findHost(selection);

		if (hostBean == null) {
			return null;
		}

		ArrayList<String> knownAlgorithms = new ArrayList<>();

		Cursor c = mDb.<mark>query</mark>(TABLE_KNOWNHOSTS, new String[] {FIELD_KNOWNHOSTS_HOSTKEYALGO},
				FIELD_KNOWNHOSTS_HOSTID + " = ?",
				new String[] {String.valueOf(hostBean.getId())}, null, null, null);

		if (c != null) {
			int COL_ALGO = c.getColumnIndexOrThrow(FIELD_KNOWNHOSTS_HOSTKEYALGO);

			while (c.moveToNext()) {
				String keyAlgo = c.getString(COL_ALGO);
				if (keyAlgo != null) {
					knownAlgorithms.add(keyAlgo);
				}
			}

			c.close();
		}

		return knownAlgorithms;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_packages_apps_browser_____BrowserProvider2_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_packages_apps_browser_____BrowserProvider2.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.update
android.database.sqlite.SQLiteDatabase.insertOrThrow

/**
     * Settings are unique, so perform an UPSERT manually since SQLite doesn't support them.
     */
    long queryDefaultFolderId(String accountName, String accountType) {
        if (!isNullAccount(accountName) && !isNullAccount(accountType)) {
            final SQLiteDatabase db = mOpenHelper.getReadableDatabase();
            Cursor c = db.<mark>query</mark>(TABLE_BOOKMARKS, new String[] { Bookmarks._ID },
                    ChromeSyncColumns.SERVER_UNIQUE + " = ?" +
                    " AND account_type = ? AND account_name = ?",
                    new String[] { ChromeSyncColumns.FOLDER_NAME_BOOKMARKS_BAR,
                    accountType, accountName }, null, null, null);
            try {
                if (c.moveToFirst()) {
                    return c.getLong(0);
                }
            } finally {
                c.close();
            }
        }
        return FIXED_ID_ROOT;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>Yuncun_____AbusiveGymReminder_____MsgAndDayRecords_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/Yuncun_____AbusiveGymReminder_____MsgAndDayRecords.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

    /** MESSAGES STUFF **/
    public Message createMessage(Message msg, Date date) {
        ContentValues values = new ContentValues();
        values.put(MsgDBHelper.COLUMN_MESSAGE_HEADER, msg.getHeader());
        values.put(MsgDBHelper.COLUMN_MESSAGE_BODY, msg.getBody());
        values.put(MsgDBHelper.COLUMN_DATE, Util.dateToString(date));
        values.put(MsgDBHelper.COLUMN_REASON, msg.getReason());
        values.put(MsgDBHelper.COLUMN_REPO_ID, msg.getRepoId());
        values.put(MsgDBHelper.COLUMN_READ, (msg.getRead()) ? 1 : 0);
        long insertId = mDatabase.insert(MsgDBHelper.TABLE_MESSAGES, null,
                values);
        Cursor cursor = mDatabase.<mark>query</mark>(MsgDBHelper.TABLE_MESSAGES,
                allColumnsMessages, MsgDBHelper.COLUMN_ID + " = " + insertId, null,
                null, null, null);
        cursor.moveToFirst();
        Message newComment = cursorToMessage(cursor);
        cursor.close();
        return newComment;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/** Return a list of all of the tasks with progress < COMPLETE_PERCENTAGE */    /** Return a list of all active tasks with notifications */
    public HashSet<TaskModelForNotify> getTasksWithNotifications() {
        HashSet<TaskModelForNotify> list = new HashSet<TaskModelForNotify>();
        Cursor cursor = database.<mark>query</mark>(tasksTable, TaskModelForNotify.FIELD_LIST,
                String.format("%s < %d AND (%s != 0 OR %s != 0)",
                        AbstractTaskModel.PROGRESS_PERCENTAGE,
                        AbstractTaskModel.COMPLETE_PERCENTAGE,
                        AbstractTaskModel.NOTIFICATIONS,
                        AbstractTaskModel.NOTIFICATION_FLAGS), null, null, null, null, null);

        try {
            if(cursor.getCount() == 0)
                return list;
            do {
                cursor.moveToNext();
                list.add(new TaskModelForNotify(cursor));
            } while(!cursor.isLast());

            return list;
        } finally {
            cursor.close();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____DatabaseAdapter_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____DatabaseAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Returns the currency code (according to the ISO 4217 standard) of the account
     * with unique Identifier <code>accountUID</code>
     * @param accountUID Unique Identifier of the account
     * @return Currency code of the account. "" if accountUID
     *      does not exist in DB
     */     */
    public long getID(@NonNull String uid){
        Cursor cursor = mDb.<mark>query</mark>(mTableName,
                new String[] {DatabaseSchema.CommonColumns._ID},
                DatabaseSchema.CommonColumns.COLUMN_UID + " = ?",
                new String[]{uid},
                null, null, null);
        long result = -1;
        try{
            if (cursor.moveToFirst()) {
                result = cursor.getLong(cursor.getColumnIndexOrThrow(DatabaseSchema.CommonColumns._ID));
            } else {
                throw new IllegalArgumentException(mTableName + " with GUID " + uid + " does not exist in the db");
            }
        } finally {
            cursor.close();
        }
        return result;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____DatabaseAdapter_8.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____DatabaseAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Updates a record in the table
     * @param recordId Database ID of the record to be updated
     * @param columnKey Name of column to be updated
     * @param newValue  New value to be assigned to the columnKey
     * @return Number of records affected
     */     */
    public String getCommodityUID(String currencyCode){
        String where = DatabaseSchema.CommodityEntry.COLUMN_MNEMONIC + "= ?";
        String[] whereArgs = new String[]{currencyCode};

        Cursor cursor = mDb.<mark>query</mark>(DatabaseSchema.CommodityEntry.TABLE_NAME,
                new String[]{DatabaseSchema.CommodityEntry.COLUMN_UID},
                where, whereArgs, null, null, null);
        try {
            if (cursor.moveToNext()) {
                return cursor.getString(cursor.getColumnIndexOrThrow(DatabaseSchema.CommodityEntry.COLUMN_UID));
            } else {
                throw new IllegalArgumentException("Currency code not found in commodities");
            }
        } finally {
            cursor.close();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>UweTrottmann_____SeriesGuide_____PurchaseDataSource_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/UweTrottmann_____SeriesGuide_____PurchaseDataSource.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.insertWithOnConflict

/**
     * Cancel the specified Entitlement record by setting the cancel date.
     */     */
    public final List<PurchaseRecord> getPurchaseRecords(final String userId) {
        Timber.d("getPurchaseRecords: userId (%s)", userId);

        final String where = AmazonBillingSQLiteHelper.COLUMN_USER_ID + " = ?";
        final Cursor cursor = database.<mark>query</mark>(AmazonBillingSQLiteHelper.TABLE_PURCHASES,
                allColumns,
                where,
                new String[] { userId },
                null,
                null,
                null);
        cursor.moveToFirst();
        final List<PurchaseRecord> results = new ArrayList<>();
        while (!cursor.isAfterLast()) {
            final PurchaseRecord subsRecord = cursorToPurchaseRecord(cursor);
            results.add(subsRecord);
            cursor.moveToNext();
        }
        Timber.d("getPurchaseRecords: found %s records", results.size());
        cursor.close();
        return results;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>UweTrottmann_____SeriesGuide_____PurchaseDataSource_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/UweTrottmann_____SeriesGuide_____PurchaseDataSource.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Return all purchase records for the user.
     *
     * @param userId user id used to verify the purchase record.
     */    @Nullable
    public PurchaseRecord getEntitlementRecordByReceiptId(final String receiptId) {
        Timber.d("getEntitlementRecordByReceiptId: receiptId (%s)", receiptId);

        final String where = AmazonBillingSQLiteHelper.COLUMN_RECEIPT_ID + "= ?";
        final Cursor cursor = database.<mark>query</mark>(AmazonBillingSQLiteHelper.TABLE_PURCHASES,
                allColumns,
                where,
                new String[] { receiptId },
                null,
                null,
                null);
        final PurchaseRecord result;
        cursor.moveToFirst();
        if (cursor.isAfterLast()) {
            result = null;
            Timber.d("getEntitlementRecordByReceiptId: no record found ");
        } else {
            result = cursorToPurchaseRecord(cursor);
            Timber.d("getEntitlementRecordByReceiptId: found ");
        }
        cursor.close();
        return result;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker24_____Talon-for-Twitter_____ActivityDataSource_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker24_____Talon-for-Twitter_____ActivityDataSource.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

/**
     * Find out if the tweet is in the database
     * @param tweetId
     * @param account
     * @return number of retweets on that tweet
     */
    public synchronized boolean tweetExists(long tweetId, int account) {
        Cursor cursor;
        try {
            cursor = database.<mark>query</mark>(ActivitySQLiteHelper.TABLE_ACTIVITY,
                    allColumns, ActivitySQLiteHelper.COLUMN_ACCOUNT + " = " + account + " AND " + ActivitySQLiteHelper.COLUMN_TWEET_ID + " = " + tweetId, null, null, null, ActivitySQLiteHelper.COLUMN_TWEET_ID + " ASC");
        } catch (Exception e) {
            open();
            cursor = database.<mark>query</mark>(ActivitySQLiteHelper.TABLE_ACTIVITY,
                    allColumns, ActivitySQLiteHelper.COLUMN_ACCOUNT + " = " + account + " AND " + ActivitySQLiteHelper.COLUMN_TWEET_ID + " = " + tweetId, null, null, null, ActivitySQLiteHelper.COLUMN_TWEET_ID + " ASC");
        }

        boolean exists = cursor.getCount() > 0;
        cursor.close();
        return exists;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>frostwire_____frostwire_____RecentStore_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/frostwire_____frostwire_____RecentStore.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Clear the cache.
     */     */
    public String getSongName(final String key) {
        if (TextUtils.isEmpty(key)) {
            return null;
        }
        final String[] projection = new String[]{
                BaseColumns._ID,
                AudioColumns.TITLE,
                AudioColumns.ARTIST,
                RecentStoreColumns.LAST_TIME_PLAYED
        };
        final String selection = AudioColumns.ARTIST + "=?";
        final String[] having = new String[]{ key };
        Cursor cursor = readableDatabase.<mark>query</mark>(TABLE_NAME, projection,
                selection, having,null, null, RecentStoreColumns.LAST_TIME_PLAYED +
                        " DESC", null);

        if (cursor != null && cursor.moveToFirst()) {
            cursor.moveToFirst();
            final String song = cursor.getString(
                    cursor.getColumnIndexOrThrow(AudioColumns.TITLE));
            cursor.close();
            return song;
        }
        if (cursor != null && !cursor.isClosed()) {
            cursor.close();
        }
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>tomahawk-player_____tomahawk-android_____DatabaseHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/tomahawk-player_____tomahawk-android_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * @param hatchetId the id by which to get the correct {@link org.tomahawk.libtomahawk.collection.Playlist}
     * @return the playlist's local id, null if playlist not found
     */     */
    public List<Playlist> getPlaylists() {
        final List<Playlist> playListList = new ArrayList<>();
        String[] columns = new String[]{TomahawkSQLiteHelper.PLAYLISTS_COLUMN_ID};

        Cursor playlistsCursor = mDatabase.<mark>query</mark>(TomahawkSQLiteHelper.TABLE_PLAYLISTS,
                columns, TomahawkSQLiteHelper.PLAYLISTS_COLUMN_ID + " != ?",
                new String[]{LOVEDITEMS_PLAYLIST_ID}, null, null, null);
        playlistsCursor.moveToFirst();
        while (!playlistsCursor.isAfterLast()) {
            Playlist playlist = getEmptyPlaylist(playlistsCursor.getString(0));
            if (playlist != null) {
                playListList.add(playlist);
            }
            playlistsCursor.moveToNext();
        }
        playlistsCursor.close();
        Collections.sort(playListList, new PlaylistComparator());
        return playListList;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>connectbot_____connectbot_____HostDatabase_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/connectbot_____connectbot_____HostDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Record the given hostkey into database under this nickname.
	 * @param hostname hostname to match
	 * @param port port to match
	 * @param hostkeyalgo algorithm for host key
	 * @param hostkey the bytes of the host key itself
	 */	@Override
	public HostBean findHost(Map<String, String> selection) {
		StringBuilder selectionBuilder = new StringBuilder();

		Iterator<Entry<String, String>> i = selection.entrySet().iterator();

		List<String> selectionValuesList = new ArrayList<>();
		int n = 0;
		while (i.hasNext()) {
			Entry<String, String> entry = i.next();

			if (entry.getValue() == null)
				continue;

			if (n++ > 0)
				selectionBuilder.append(" AND ");

			selectionBuilder.append(entry.getKey())
				.append(" = ?");

			selectionValuesList.add(entry.getValue());
		}

		String selectionValues[] = new String[selectionValuesList.size()];
		selectionValuesList.toArray(selectionValues);

		Cursor c = mDb.<mark>query</mark>(TABLE_HOSTS, null,
				selectionBuilder.toString(),
				selectionValues,
				null, null, null);

		HostBean host = getFirstHostBean(c);

		return host;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____MapTileProviderDataBase_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____MapTileProviderDataBase.java

android.database.sqlite.SQLiteDatabase.isOpen
android.database.sqlite.SQLiteStatement.bindString
android.database.sqlite.SQLiteStatement.bindLong
android.database.sqlite.SQLiteStatement.bindLong
android.database.sqlite.SQLiteStatement.bindLong
android.database.sqlite.SQLiteStatement.simpleQueryForBlobFileDescriptor
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteException.getMessage

/**
     * Remove old tiles until enough space is present
     * 
     * @param pSizeNeeded the extra size we need
     * @return the size we actually gained
     */     */
    public boolean isInvalid(@NonNull final MapTile aTile) {
        boolean existed = false;
        if (mDatabase.<mark>isOpen</mark>()) {
            final String[] args = new String[] { aTile.rendererID, Integer.toString(aTile.zoomLevel), Integer.toString(aTile.x), Integer.toString(aTile.y) };
            final Cursor c = mDatabase.<mark>query</mark>(T_FSCACHE, new String[] { T_FSCACHE_RENDERER_ID }, T_FSCACHE_WHERE_INVALID, args, null, null, null);
            existed = c.getCount() > 0;
            c.close();
        }
        return existed;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>vx_____connectbot_____HostDatabase_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/vx_____connectbot_____HostDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Record the given hostkey into database under this nickname.
	 * @param hostname
	 * @param port
	 * @param hostkeyalgo
	 * @param hostkey
	 */	 */
	public HostBean findHost(Map<String, String> selection) {
		StringBuilder selectionBuilder = new StringBuilder();

		Iterator<Entry<String, String>> i = selection.entrySet().iterator();

		List<String> selectionValuesList = new LinkedList<String>();
		int n = 0;
		while (i.hasNext()) {
			Entry<String, String> entry = i.next();

			if (entry.getValue() == null)
				continue;

			if (n++ > 0)
				selectionBuilder.append(" AND ");

			selectionBuilder.append(entry.getKey())
				.append(" = ?");

			selectionValuesList.add(entry.getValue());
		}

		String selectionValues[] = new String[selectionValuesList.size()];
		selectionValuesList.toArray(selectionValues);
		selectionValuesList = null;

		HostBean host;

		synchronized (dbLock) {
			SQLiteDatabase db = getReadableDatabase();

			Cursor c = db.<mark>query</mark>(TABLE_HOSTS, null,
					selectionBuilder.toString(),
					selectionValues,
					null, null, null);

			host = getFirstHostBean(c);
		}

		return host;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____MigrationHelper_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____MigrationHelper.java

android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.update

/**
     * Code for upgrading the database to version 7 from version 6.<br>
     * Tasks accomplished in migration:
     *  <ul>
     *      <li>Added new splits table for transaction splits</li>
     *      <li>Extract existing info from transactions table to populate split table</li>
     *  </ul>
     * @param db SQLite Database
     * @return The new database version if upgrade was successful, or the old db version if it failed
     */     */
    private static String getGnuCashRootAccountUID(SQLiteDatabase db){
        String condition = AccountEntry.COLUMN_TYPE + "= '" + AccountType.ROOT.name() + "'";
        Cursor cursor =  db.<mark>query</mark>(AccountEntry.TABLE_NAME,
                null, condition, null, null, null,
                AccountEntry.COLUMN_NAME + " ASC");
        String rootUID = null;
        if (cursor != null && cursor.moveToFirst()){
            rootUID = cursor.getString(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_UID));
            cursor.close();
        }
        return rootUID;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TagController_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TagController.java

android.database.sqlite.SQLiteDatabase.query

/** Returns a list of task identifiers in the provided set that are UNtagged.
     *
     * The calling SubActivity must provide the set of tasks, since
     * TagController cannot access the appropriate instance of TaskController.
     *
     * The current implementation is not very efficient, because queries
     * the TagToTask map once for each active task.
     **/    /** Get a list of tag identifiers for the given task */
    public LinkedList<TagIdentifier> getTaskTags(TaskIdentifier
            taskId) throws SQLException {
        LinkedList<TagIdentifier> list = new LinkedList<TagIdentifier>();
        Cursor cursor = tagToTaskMapDatabase.<mark>query</mark>(tagTaskTable,
                TagToTaskMapping.FIELD_LIST, TagToTaskMapping.TASK + " = ?",
                new String[] { taskId.idAsString() }, null, null, null);

        try {
	        if(cursor.getCount() == 0)
	            return list;
	        do {
	            cursor.moveToNext();
	            list.add(new TagToTaskMapping(cursor).getTag());
	        } while(!cursor.isLast());
        } finally {
        	cursor.close();
        }

        return list;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>frostwire_____frostwire_____FavoritesStore_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/frostwire_____frostwire_____FavoritesStore.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Toggle the current song as favorite
     */     */
    public Long getSongId(final Long songId) {
        if (songId <= -1) {
            return null;
        }
        try {
            final String[] projection = new String[]{
                    FavoriteColumns.ID, FavoriteColumns.SONGNAME, FavoriteColumns.ALBUMNAME,
                    FavoriteColumns.ARTISTNAME, FavoriteColumns.PLAYCOUNT
            };
            final String selection = FavoriteColumns.ID + "=?";
            final String[] having = new String[]{
                    String.valueOf(songId)
            };
            Cursor cursor = readableDatabase.<mark>query</mark>(FavoriteColumns.NAME, projection, selection, having, null,
                    null, null, null);
            if (cursor != null && cursor.moveToFirst()) {
                final Long id = cursor.getLong(cursor.getColumnIndexOrThrow(FavoriteColumns.ID));
                cursor.close();
                return id;
            }
            if (cursor != null) {
                cursor.close();
            }
        } catch (Throwable e) {
            return null;
        }
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>cgeo_____cgeo_____DataStore_9.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/cgeo_____cgeo_____DataStore.java

android.database.sqlite.SQLiteDatabase.query

/**
     * checks if this is a newly created database
     */    @NonNull
    public static StoredList getList(final int id) {
        init();
        if (id >= customListIdOffset) {
            final Cursor cursor = database.<mark>query</mark>(
                    dbTableLists,
                    new String[]{"_id", "title"},
                    "_id = ? ",
                    new String[] { String.valueOf(id - customListIdOffset) },
                    null,
                    null,
                    null);
            final List<StoredList> lists = getListsFromCursor(cursor);
            if (!lists.isEmpty()) {
                return lists.get(0);
            }
        }

        final Resources res = CgeoApplication.getInstance().getResources();
        if (id == PseudoList.ALL_LIST.id) {
            return new StoredList(PseudoList.ALL_LIST.id, res.getString(R.string.list_all_lists), getAllCachesCount());
        }

        // fall back to standard list in case of invalid list id
        return new StoredList(StoredList.STANDARD_LIST_ID, res.getString(R.string.list_inbox), (int) PreparedStatement.COUNT_CACHES_ON_STANDARD_LIST.simpleQueryForLong());
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>firebase_____firebase-android-sdk_____SQLiteEventStore_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/firebase_____firebase-android-sdk_____SQLiteEventStore.java

android.database.sqlite.SQLiteDatabase.query

/** Populate metadata into the events. */  /** Loads all events for a backend. */
  private List<PersistedEvent> loadEvents(SQLiteDatabase db, TransportContext transportContext) {
    List<PersistedEvent> events = new ArrayList<>();
    Long contextId = getTransportContextId(db, transportContext);
    if (contextId == null) {
      return events;
    }

    try (Cursor cursor =
        db.<mark>query</mark>(
            "events",
            new String[] {"_id", "transport_name", "timestamp_ms", "uptime_ms", "payload"},
            "context_id = ?",
            new String[] {contextId.toString()},
            null,
            null,
            null,
            String.valueOf(config.getLoadBatchSize()))) {
      while (cursor.moveToNext()) {
        long id = cursor.getLong(0);
        EventInternal event =
            EventInternal.builder()
                .setTransportName(cursor.getString(1))
                .setEventMillis(cursor.getLong(2))
                .setUptimeMillis(cursor.getLong(3))
                .setPayload(cursor.getBlob(4))
                .build();
        events.add(PersistedEvent.create(id, transportContext, event));
      }
    }
    return events;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____AdvancedPrefDatabase_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____AdvancedPrefDatabase.java

android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.update
android.database.sqlite.SQLiteDatabase.close

/**
     * Move a preset to a new position
     * 
     * @param oldPos index of old position
     * @param newPos index of new position
     */    @NonNull
    private synchronized PresetInfo[] getPresets(@Nullable String value, boolean byURL) {
        SQLiteDatabase db = getReadableDatabase();
        Cursor dbresult = db.<mark>query</mark>(PRESETS_TABLE, new String[] { ID_FIELD, "name", "url", "lastupdate", "active", "usetranslations" },
                value == null ? null : (byURL ? "url = ?" : "id = ?"), value == null ? null : new String[] { value }, null, null, POSITION_FIELD);
        PresetInfo[] result = new PresetInfo[dbresult.getCount()];
        dbresult.moveToFirst();
        for (int i = 0; i < result.length; i++) {
            result[i] = new PresetInfo(dbresult.getString(0), dbresult.getString(1), dbresult.getString(2), dbresult.getString(3), dbresult.getInt(4) == 1,
                    dbresult.getInt(5) == 1);
            dbresult.moveToNext();
        }
        dbresult.<mark>close</mark>();
        db.<mark>close</mark>();
        return result;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>quran_____quran_android_____DatabaseHandler_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/quran_____quran_android_____DatabaseHandler.java

android.database.sqlite.SQLiteDatabase.query

/**
   * @deprecated use {@link #getVerses(VerseRange, int)} instead
   * @param sura the sura
   * @param ayah the ayah
   * @return the result
   */
  private List<QuranText> expandHyperlinks(String table, List<QuranText> data, String rowIds) {
    SparseArray<String> expansions = new SparseArray<>();

    Cursor cursor = null;
    try {
      cursor = database.<mark>query</mark>(table, new String[]{ "rowid as _id", COL_TEXT },
          "rowid in (" + rowIds + ")", null, null, null, "rowid");
      while (cursor != null && cursor.moveToNext()) {
        int id = cursor.getInt(0);
        String text = cursor.getString(1);
        expansions.put(id, text);
      }
    } finally {
      DatabaseUtils.closeCursor(cursor);
    }

    List<QuranText> result = new ArrayList<>();
    for (int i = 0, size = data.size(); i < size; i++) {
      final QuranText ayah = data.get(i);
      final Integer linkId = TranslationUtil.getHyperlinkAyahId(ayah);
      if (linkId == null) {
        result.add(ayah);
      } else {
        final String expandedText = expansions.get(linkId);
        result.add(new QuranText(ayah.getSura(), ayah.getAyah(), ayah.getText(), expandedText));
      }
    }
    return result;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>pwnall_____chromeview_____HttpAuthDatabase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/pwnall_____chromeview_____HttpAuthDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Clears the HTTP authentication password database.
     */     */
    public String[] getHttpAuthUsernamePassword(String host, String realm) {
        if (host == null || realm == null || !waitForInit()){
            return null;
        }

        final String[] columns = new String[] {
            HTTPAUTH_USERNAME_COL, HTTPAUTH_PASSWORD_COL
        };
        final String selection = "(" + HTTPAUTH_HOST_COL + " == ?) AND " +
                "(" + HTTPAUTH_REALM_COL + " == ?)";

        String[] ret = null;
        Cursor cursor = null;
        try {
            cursor = mDatabase.<mark>query</mark>(HTTPAUTH_TABLE_NAME, columns, selection,
                    new String[] { host, realm }, null, null, null);
            if (cursor.moveToFirst()) {
                ret = new String[] {
                        cursor.getString(cursor.getColumnIndex(HTTPAUTH_USERNAME_COL)),
                        cursor.getString(cursor.getColumnIndex(HTTPAUTH_PASSWORD_COL)),
                };
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, "getHttpAuthUsernamePassword", e);
        } finally {
            if (cursor != null) cursor.close();
        }
        return ret;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>mogoweb_____chromium_webview_____HttpAuthDatabase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/mogoweb_____chromium_webview_____HttpAuthDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Clears the HTTP authentication password database.
     */     */
    public String[] getHttpAuthUsernamePassword(String host, String realm) {
        if (host == null || realm == null || !waitForInit()) {
            return null;
        }

        final String[] columns = new String[] {
            HTTPAUTH_USERNAME_COL, HTTPAUTH_PASSWORD_COL
        };
        final String selection = "(" + HTTPAUTH_HOST_COL + " == ?) AND " +
                "(" + HTTPAUTH_REALM_COL + " == ?)";

        String[] ret = null;
        Cursor cursor = null;
        try {
            cursor = mDatabase.<mark>query</mark>(HTTPAUTH_TABLE_NAME, columns, selection,
                    new String[] { host, realm }, null, null, null);
            if (cursor.moveToFirst()) {
                ret = new String[] {
                        cursor.getString(cursor.getColumnIndex(HTTPAUTH_USERNAME_COL)),
                        cursor.getString(cursor.getColumnIndex(HTTPAUTH_PASSWORD_COL)),
                };
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, "getHttpAuthUsernamePassword", e);
        } finally {
            if (cursor != null) cursor.close();
        }
        return ret;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>LitePalFramework_____LitePal_____DBUtility_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/LitePalFramework_____LitePal_____DBUtility.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Test if the table name passed in exists in the database. Cases are
	 * ignored.
	 * 
	 * @param tableName
	 *            The table name.
	 * @return Return true if there's already a same name table exist, otherwise
	 *         return false.
	 */	 */
	public static boolean isIntermediateTable(String tableName, SQLiteDatabase db) {
		if (!TextUtils.isEmpty(tableName)) {
			if (tableName.matches("[0-9a-zA-Z]+_[0-9a-zA-Z]+")) {
				Cursor cursor = null;
				try {
					cursor = db.<mark>query</mark>(Const.TableSchema.TABLE_NAME, null, null, null, null, null,
							null);
					if (cursor.moveToFirst()) {
						do {
							String tableNameDB = cursor.getString(cursor
									.getColumnIndexOrThrow(Const.TableSchema.COLUMN_NAME));
							if (tableName.equalsIgnoreCase(tableNameDB)) {
								int tableType = cursor.getInt(cursor
										.getColumnIndexOrThrow(Const.TableSchema.COLUMN_TYPE));
								if (tableType == Const.TableSchema.INTERMEDIATE_JOIN_TABLE) {
									return true;
								}
								break;
							}
						} while (cursor.moveToNext());
					}
				} catch (Exception e) {
					e.printStackTrace();
				} finally {
					if (cursor != null) {
						cursor.close();
					}
				}
			}
		}
		return false;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matt-allen_____repay-android_____DatabaseHandler_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/matt-allen_____repay-android_____DatabaseHandler.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
	 * Replace friend data in database with that passed in here
	 * @param friend
	 */	 */
	public ArrayList<Debt> getDebtsByRepayID(final String repayID) throws SQLException, ParseException,
			CursorIndexOutOfBoundsException, NullPointerException {
		ArrayList<Debt> debts = null;
		SQLiteDatabase db = this.getReadableDatabase();
		Cursor c = db.<mark>query</mark>(Names.D_TABLENAME, new String[]{Names.D_DEBTID, Names.D_DATE, Names.D_AMOUNT, Names.D_DESCRIPTION},
				Names.D_REPAYID+"=?", new String[]{repayID}, null, null, null);

		if(c != null && c.getCount() > 0){
			c.moveToFirst();
			debts = new ArrayList<Debt>();
			do{
				SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);
				String description, dateString;
				Date date;
				// Try and catch errors to stop this failing silently
				try{
					dateString = c.getString(1);
					date = sdf.parse(dateString);
				} catch (Exception e){
					date = new Date();
				}
				try{
					description = c.getString(3);
				} catch (Exception e){
					description = "";
				}
				debts.add(new Debt(c.getInt(0), repayID, date, new BigDecimal(c.getString(2)), description));
			} while(c.moveToNext());
		}
		db.<mark>close</mark>();
		return debts;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____AdvancedPrefDatabase_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____AdvancedPrefDatabase.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * adds a new Preset with the given values to the Preset database
     * 
     * @param id the id
     * @param name the name of the new Preset
     * @param url any url for the preset
     * @param active if true this will be included in the currently avaliable presets
     */    @NonNull
    public PresetInfo[] getActivePresets() {
        SQLiteDatabase db = getReadableDatabase();
        Cursor dbresult = db.<mark>query</mark>(PRESETS_TABLE, new String[] { ID_FIELD, "name", "url", "lastupdate", "active", "usetranslations" }, "active=1", null, null,
                null, POSITION_FIELD);
        PresetInfo[] result = new PresetInfo[dbresult.getCount()];
        Log.d(LOGTAG, "#prefs " + result.length);
        dbresult.moveToFirst();
        for (int i = 0; i < result.length; i++) {
            Log.d(LOGTAG, "Reading pref " + i + " " + dbresult.getString(1));
            result[i] = new PresetInfo(dbresult.getString(0), dbresult.getString(1), dbresult.getString(2), dbresult.getString(3), dbresult.getInt(4) == 1,
                    dbresult.getInt(5) == 1);
            dbresult.moveToNext();
        }
        dbresult.<mark>close</mark>();
        db.<mark>close</mark>();
        return result;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>vanilla-music_____vanilla_____CoverCache_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/vanilla-music_____vanilla_____CoverCache.java

android.database.sqlite.SQLiteDatabase.query

/**
		 * Stores a bitmap in the disk cache, does not update existing objects
		 *
		 * @param key The cover key to use
		 * @param Bitmap The bitmap to store
		 */		 */
		private void trim(long maxCacheSize) {
			SQLiteDatabase dbh = getWritableDatabase();
			long availableSpace = maxCacheSize - getUsedSpace();

			if (maxCacheSize == 0) {
				// Just drop the whole database (probably a call from evictAll)
				dbh.delete(TABLE_NAME, "1", null);
			} else if (availableSpace < 0) {
				// Try to evict all expired entries first
				int affected = dbh.delete(TABLE_NAME, "expires < ?", new String[] { Long.toString(getUnixTime())});
				if (affected > 0)
					availableSpace = maxCacheSize - getUsedSpace();

				if (availableSpace < 0) {
					// still not enough space: purge by expire date (this kills random rows as expire times are random)
					Cursor cursor = dbh.<mark>query</mark>(TABLE_NAME, META_PROJECTION, null, null, null, null, "expires ASC");
					if (cursor != null) {
						while (cursor.moveToNext() && availableSpace < 0) {
							int id = cursor.getInt(0);
							int size = cursor.getInt(1);
							dbh.delete(TABLE_NAME, "id=?", new String[] { Long.toString(id) });
							availableSpace += size;
						}
						cursor.close();
					}
				}
			}
		}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____AdvancedPrefDatabase_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____AdvancedPrefDatabase.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.update
android.database.sqlite.SQLiteDatabase.close

/**
     * Gets the preset data path for a preset with the given ID
     * 
     * @param id the id for the Preset
     * @return the preset data path
     */     */
    public synchronized void deletePreset(@NonNull String id) {
        if (ID_DEFAULT.equals(id)) {
            throw new IllegalOperationException("Cannot delete default");
        }
        SQLiteDatabase db = getWritableDatabase();
        db.delete(PRESETS_TABLE, "id = ?", new String[] { id });
        // need to renumber after deleting
        Cursor dbresult = db.<mark>query</mark>(PRESETS_TABLE, new String[] { ID_FIELD }, null, null, null, null, POSITION_FIELD);
        dbresult.moveToFirst();
        int count = dbresult.getCount();
        for (int i = 0; i < count; i++) {
            ContentValues values = new ContentValues();
            values.put(POSITION_FIELD, i);
            db.<mark>update</mark>(PRESETS_TABLE, values, "id = ?", new String[] { dbresult.getString(0) });
            dbresult.moveToNext();
        }
        dbresult.<mark>close</mark>();
        db.<mark>close</mark>();
        removePresetDirectory(id);
        if (id.equals(getCurrentAPI().preset)) {
            App.resetPresets();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>Neamar_____KISS_____DBHelper_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/Neamar_____KISS_____DBHelper.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.delete

/**
     * Insert new tags for given id
     *
     * @param context android context
     * @param tag     tag to insert
     * @param record  record to insert
     */
    public static ArrayList<ShortcutRecord> getShortcuts(Context context) {
        ArrayList<ShortcutRecord> records = new ArrayList<>();
        SQLiteDatabase db = getDatabase(context);

        // Cursor query (String table, String[] columns, String selection,
        // String[] selectionArgs, String groupBy, String having, String
        // orderBy)
        Cursor cursor = db.<mark>query</mark>("shortcuts", new String[]{"name", "package", "icon", "intent_uri", "icon_blob"},
                null, null, null, null, null);

        cursor.moveToFirst();
        while (!cursor.isAfterLast()) {
            ShortcutRecord entry = new ShortcutRecord();

            entry.name = cursor.getString(0);
            entry.packageName = cursor.getString(1);
            entry.iconResource = cursor.getString(2);
            entry.intentUri = cursor.getString(3);
            entry.icon_blob = cursor.getBlob(4);

            records.add(entry);
            cursor.moveToNext();
        }
        cursor.close();

        return records;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____ValidatorRulesDatabase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____ValidatorRulesDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Get all entries for a specific ruleset
     * 
     * @param database the database to query
     * @param name the ruleset name or null if we want the default entries
     * @return a Cursor pointing to the first entry
     */    @Nullable
    public static MultiHashMap<String, PatternAndAge> getDefaultResurvey(@NonNull SQLiteDatabase database) {
        MultiHashMap<String, PatternAndAge> result = null;
        Cursor dbresult = database.<mark>query</mark>(RESURVEY_TABLE, new String[] { KEY_FIELD, VALUE_FIELD, ISREGEXP_FIELD, DAYS_FIELD },
                RULESET_FIELD + " = " + DEFAULT_RULESET, null, null, null, KEY_FIELD + "," + VALUE_FIELD);

        if (dbresult.getCount() >= 1) {
            result = new MultiHashMap<>();
            boolean haveEntry = dbresult.moveToFirst();
            while (haveEntry) {
                PatternAndAge v = new PatternAndAge();
                v.setValue(dbresult.getString(1));
                v.setIsRegexp(dbresult.getInt(2) == 1 ? true : false);
                v.setAge(dbresult.getLong(3) * 24 * 3600); // days -> secs
                result.add(dbresult.getString(0), v);
                haveEntry = dbresult.moveToNext();
            }
        }
        dbresult.close();
        return result;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>Yuncun_____AbusiveGymReminder_____MsgAndDayRecords_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/Yuncun_____AbusiveGymReminder_____MsgAndDayRecords.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

    /**DAY RECORDS STUFF**/
    public DayRecord createDayRecord(DayRecord day) {
        String comment=day.getComment();
        Date date = day.getDate();
        boolean isGymDay = day.isGymDay();
        boolean beenToGym = day.beenToGym();
        String servis = day.getSerializedVisitsList();

        ContentValues values = new ContentValues();
        values.put(MsgDBHelper.COLUMN_DAYRECORDS, comment);
        values.put(MsgDBHelper.COLUMN_DATE, Util.dateToString(date));
        values.put(MsgDBHelper.COLUMN_BEENTOGYM, (beenToGym) ? 1 : 0);
        values.put(MsgDBHelper.COLUMN_ISGYMDAY, (isGymDay) ? 1 : 0);

        if (servis==null){
            values.putNull(MsgDBHelper.COLUMN_VISITS);
        }else{

            values.put(MsgDBHelper.COLUMN_VISITS, servis);
        }
        long insertId = mDatabase.insert(MsgDBHelper.TABLE_DAYRECORDS, null,
                values);
        Cursor cursor = mDatabase.<mark>query</mark>(MsgDBHelper.TABLE_DAYRECORDS,
                allColumnsDayRecords, MsgDBHelper.COLUMN_ID + " = " + insertId, null,
                null, null, null);
        cursor.moveToFirst();
        DayRecord newComment = cursorToDayRecord(cursor);
        cursor.close();
        return newComment;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codeka_____wwmmo_____ChatStore_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codeka_____wwmmo_____ChatStore.java

android.database.sqlite.SQLiteOpenHelper.getReadableDatabase
android.database.sqlite.SQLiteDatabase.query

  /** Gets count messages starting from startTime and going back in time. */
  public List<ChatMessage> getMessagesAfter(Long roomId, long time) {
    String query;
    if (roomId == null) {
      query = "room_id IS NULL";
    } else {
      query = "room_id = ?";
    }
    query += " AND date_posted > ?";

    String[] queryArgs = new String[roomId == null ? 1 : 2];
    int index = 0;
    if (roomId != null) {
      queryArgs[index++] = String.format(Locale.US, "%d", roomId);
    }
    queryArgs[index] = String.format(Locale.US, "%d", time);

    ArrayList<ChatMessage> msgs = new ArrayList<>();
    SQLiteDatabase db = helper.<mark>getReadableDatabase</mark>();
    try (
        Cursor cursor = db.<mark>query</mark>(
            name + "_messages",
            new String[] { "msg" } /* columns */,
            query /* selection */,
            queryArgs/* selectionArgs */,
            null /* groupBy */,
            null /* having */,
            "date_posted DESC" /* orderBy */)) {
      while (cursor.moveToNext()) {
        msgs.add(ChatMessage.ADAPTER.decode(cursor.getBlob(0)));
      }
      Collections.reverse(msgs); // Make it oldest-first.
    } catch (IOException e) {
      log.error("Error fetching chat messages.", e);
    }
    return msgs;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_frameworks_base_____RecoverableKeyStoreDb_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_frameworks_base_____RecoverableKeyStoreDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Returns the public key of the recovery service.
     *
     * @param userId The userId of the profile the application is running under.
     * @param uid The uid of the application who initializes the local recovery components.
     *
     * @hide
     */     */
    public int getPlatformKeyGenerationId(int userId) {
        SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();
        String[] projection = {
                UserMetadataEntry.COLUMN_NAME_PLATFORM_KEY_GENERATION_ID};
        String selection =
                UserMetadataEntry.COLUMN_NAME_USER_ID + " = ?";
        String[] selectionArguments = {
                Integer.toString(userId)};

        try (
            Cursor cursor = db.<mark>query</mark>(
                UserMetadataEntry.TABLE_NAME,
                projection,
                selection,
                selectionArguments,
                /*groupBy=*/ null,
                /*having=*/ null,
                /*orderBy=*/ null)
        ) {
            if (cursor.getCount() == 0) {
                return -1;
            }
            cursor.moveToFirst();
            return cursor.getInt(
                    cursor.getColumnIndexOrThrow(
                            UserMetadataEntry.COLUMN_NAME_PLATFORM_KEY_GENERATION_ID));
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>Pkmmte_____PkRSS_____FavoriteDatabase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/Pkmmte_____PkRSS_____FavoriteDatabase.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
	 * Removes a specified Article from this database based on its ID value.
	 * @param article Article to remove. May contain dummy data as long as the id is valid.
	 */	 */
	public Article get(int id) {
		// Get Read Access
		SQLiteDatabase db = this.getReadableDatabase();

		// Execute query with specified id
		Cursor cursor = db.<mark>query</mark>(TABLE_ARTICLES,
		                         new String[] {KEY_TAGS, KEY_MEDIA_CONTENT, KEY_SOURCE, KEY_IMAGE, KEY_TITLE, KEY_DESCRIPTION, KEY_CONTENT, KEY_COMMENTS, KEY_AUTHOR,
			                         KEY_DATE, KEY_ID}, KEY_ID + "=?", new String[] {String.valueOf(id)}, null, null, null, null);
		Article article = null;

		try {
			// Attempt to retrieve article
			if (cursor != null) {
				cursor.moveToFirst();
				article = new Article(null, Arrays.asList(cursor.getString(0).split("_PCX_")), Article.MediaContent.fromByteArray(cursor.getBlob(1)), Uri.parse(cursor.getString(2)),
				                      Uri.parse(cursor.getString(3)), cursor.getString(4), cursor.getString(5), cursor.getString(6),
				                      cursor.getString(7), cursor.getString(8), cursor.getLong(9), cursor.getInt(10));
			}
		} finally {
			// Close Cursor
			if (cursor != null) cursor.<mark>close</mark>();
		}

		// Close & Return
		db.<mark>close</mark>();
		return article;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dsolonenko_____financisto_____ReportDataByPeriod_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dsolonenko_____financisto_____ReportDataByPeriod.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * @return The list of data points (month period and value)
	 */	 */
	private void init(Context context, Calendar startDate, int periodLength, Currency currency, String filterColumn, int[] filterId, MyEntityManager em) {
		this.context = context;
		this.periodLength = periodLength;
		startDate.set(startDate.get(Calendar.YEAR), startDate.get(Calendar.MONTH), 01, 00, 00, 00);
		this.startDate = startDate;
		
		SQLiteDatabase db = em.db();
		Cursor cursor = null;

		fillEmptyList(startDate, periodLength);

		try {
			// search accounts for which the reference currency is the given currency
			int[] accounts = getAccountsByCurrency(currency, db);
			if (accounts.length==0) {
				max=min=0;
				absMax=absMin=0;
				return;
			}
			
			// prepare query based on given report parameters
			String where = getWhereClause(filterColumn, filterId, accounts);
			String[] pars = getWherePars(startDate, periodLength, filterId, accounts);
			// query data
			cursor = db.<mark>query</mark>(TRANSACTION_TABLE, new String[]{filterColumn, TransactionColumns.from_amount.name(), TransactionColumns.datetime.name(), TransactionColumns.datetime.name()},
					   where, pars, null, null, TransactionColumns.datetime.name());
			// extract data and fill statistics
			extractData(cursor); 

		} finally {
			if (cursor!=null) cursor.close();
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>hushnymous_____android_frameworks_base_____WebViewDatabaseClassic_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/hushnymous_____android_frameworks_base_____WebViewDatabaseClassic.java

android.database.sqlite.SQLiteDatabase.query

/**
     * @see WebViewDatabase#hasHttpAuthUsernamePassword
     */     */
    String[] getUsernamePassword(String schemePlusHost) {
        if (schemePlusHost == null || !checkInitialized()) {
            return null;
        }

        final String[] columns = new String[] {
                PASSWORD_USERNAME_COL, PASSWORD_PASSWORD_COL
        };
        final String selection = "(" + PASSWORD_HOST_COL + " == ?)";
        synchronized (mPasswordLock) {
            String[] ret = null;
            Cursor cursor = null;
            try {
                cursor = sDatabase.<mark>query</mark>(mTableNames[TABLE_PASSWORD_ID],
                        columns, selection, new String[] { schemePlusHost }, null,
                        null, null);
                if (cursor.moveToFirst()) {
                    ret = new String[2];
                    ret[0] = cursor.getString(
                            cursor.getColumnIndex(PASSWORD_USERNAME_COL));
                    ret[1] = cursor.getString(
                            cursor.getColumnIndex(PASSWORD_PASSWORD_COL));
                }
            } catch (IllegalStateException e) {
                Log.e(LOGTAG, "getUsernamePassword", e);
            } finally {
                if (cursor != null) cursor.close();
            }
            return ret;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____MeasurementManager_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____MeasurementManager.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.insert
android.database.sqlite.SQLiteDatabase.close

/**
     * Gets a list of deleted measurements IDs.
     *
     * @return
     */     */
    public String getPicID(String ID, PicTypes type) {
        Log.d(TAG, "picID");
        String name = null;
        switch (type) {
            case FRONT:
                name = DBContract.Measurement.COLUMN_NAME_PIC_FRONT_ID;
                break;
            case SIDE:
                name = DBContract.Measurement.COLUMN_NAME_PIC_SIDE_ID;
                break;
            case BACK:
                name = DBContract.Measurement.COLUMN_NAME_PIC_BACK_ID;
                break;
        }
        this.database = this.dbHandler.getReadableDatabase();
        Cursor cursor = database
                .<mark>query</mark>(DBContract.Measurement.TABLE_NAME,
                        new String[]{name},
                        DBContract.Measurement.COLUMN_NAME_ID + " = '" + ID + "'"
                        , null, null, null, null);
        if (cursor.moveToFirst()) {
            String val = cursor.getString(0);
            cursor.<mark>close</mark>();
            database.<mark>close</mark>();
            return val;
        }
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fashiontec_____bodyapps-android_____MeasurementManager_8.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fashiontec_____bodyapps-android_____MeasurementManager.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Removes the given ID from delete table.
     *
     * @param ID
     */     */
    public void delMeasurement(String ID, int personID) {
        Log.d(TAG, "delMeasurement");
        this.database = this.dbHandler.getReadableDatabase();
        boolean delPerson = false;
        Cursor cursor = database
                .<mark>query</mark>(DBContract.Measurement.TABLE_NAME,
                        new String[]{DBContract.Measurement.COLUMN_NAME_ID},
                        DBContract.Measurement.COLUMN_NAME_PERSON_ID + " = '" + personID + "'"
                        , null, null, null, null);
        if (!cursor.moveToFirst()) {
            delPerson = true;
        }
        cursor.close();
        database.close();
        this.database = this.dbHandler.getWritableDatabase();
        if (delPerson) {
            database.delete(DBContract.Person.TABLE_NAME,
                    DBContract.Person.COLUMN_NAME_ID + " ='" + ID + "'",
                    null);
        }
        database.delete(DBContract.Measurement.TABLE_NAME,
                DBContract.Measurement.COLUMN_NAME_ID + " ='" + ID + "'",
                null);
        ContentValues values = new ContentValues();
        values.put(DBContract.Delete.COLUMN_NAME_FILE_ID, ID);
        database.insert(DBContract.Delete.TABLE_NAME, null, values);
        database.close();
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>UweTrottmann_____SeriesGuide_____PurchaseDataSource_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/UweTrottmann_____SeriesGuide_____PurchaseDataSource.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Insert or update the subscription record by receiptId
     *
     * @param receiptId The receipt id
     * @param userId Amazon user id
     * @param dateFrom Timestamp for subscription's valid from date
     * @param dateTo Timestamp for subscription's valid to date. less than 1 means cancel date not
     * set, the subscription in active status.
     * @param sku The sku
     */    @Nullable
    public PurchaseRecord getLatestEntitlementRecordBySku(String userId, String sku) {
        Timber.d("getEntitlementRecordBySku: userId (%s), sku (%s)", userId, sku);

        final String where = AmazonBillingSQLiteHelper.COLUMN_USER_ID + " = ? and "
                + AmazonBillingSQLiteHelper.COLUMN_SKU + " = ?";
        final Cursor cursor = database.<mark>query</mark>(AmazonBillingSQLiteHelper.TABLE_PURCHASES, allColumns,
                where, new String[] { userId, sku }, null, null,
                AmazonBillingSQLiteHelper.COLUMN_DATE_FROM + " desc ");
        final PurchaseRecord result;
        cursor.moveToFirst();
        if (cursor.isAfterLast()) {
            result = null;
            Timber.d("getEntitlementRecordBySku: no record found ");
        } else {
            result = cursorToPurchaseRecord(cursor);
            Timber.d("getEntitlementRecordBySku: found ");
        }
        cursor.close();
        return result;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>vx_____connectbot_____HostDatabase_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/vx_____connectbot_____HostDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Update the parameters of a port forward in the database.
	 * @param pfb {@link PortForwardBean} to save
	 * @return true on success
	 */	 */
	public KnownHosts getKnownHosts() {
		KnownHosts known = new KnownHosts();

		synchronized (dbLock) {
			SQLiteDatabase db = this.getReadableDatabase();
			Cursor c = db.<mark>query</mark>(TABLE_HOSTS, new String[] { FIELD_HOST_HOSTNAME,
					FIELD_HOST_PORT, FIELD_HOST_HOSTKEYALGO, FIELD_HOST_HOSTKEY },
					null, null, null, null, null);

			if (c != null) {
				int COL_HOSTNAME = c.getColumnIndexOrThrow(FIELD_HOST_HOSTNAME),
					COL_PORT = c.getColumnIndexOrThrow(FIELD_HOST_PORT),
					COL_HOSTKEYALGO = c.getColumnIndexOrThrow(FIELD_HOST_HOSTKEYALGO),
					COL_HOSTKEY = c.getColumnIndexOrThrow(FIELD_HOST_HOSTKEY);

				while (c.moveToNext()) {
					String hostname = c.getString(COL_HOSTNAME),
						hostkeyalgo = c.getString(COL_HOSTKEYALGO);
					int port = c.getInt(COL_PORT);
					byte[] hostkey = c.getBlob(COL_HOSTKEY);

					if (hostkeyalgo == null || hostkeyalgo.length() == 0) continue;
					if (hostkey == null || hostkey.length == 0) continue;

					try {
						known.addHostkey(new String[] { String.format("%s:%d", hostname, port) }, hostkeyalgo, hostkey);
					} catch(Exception e) {
						Log.e(TAG, "Problem while adding a known host from database", e);
					}
				}

				c.close();
			}
		}

		return known;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>xamarin_____XobotOS_____WebViewDatabase_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/xamarin_____XobotOS_____WebViewDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
     *  Find out if there are any HTTP authentication passwords saved.   
     *
     * @return TRUE if there are passwords saved
     */     */
    String[] getUsernamePassword(String schemePlusHost) {
        if (schemePlusHost == null || !checkInitialized()) {
            return null;
        }

        final String[] columns = new String[] {
                PASSWORD_USERNAME_COL, PASSWORD_PASSWORD_COL
        };
        final String selection = "(" + PASSWORD_HOST_COL + " == ?)";
        synchronized (mPasswordLock) {
            String[] ret = null;
            Cursor cursor = null;
            try {
                cursor = mDatabase.<mark>query</mark>(mTableNames[TABLE_PASSWORD_ID],
                        columns, selection, new String[] { schemePlusHost }, null,
                        null, null);
                if (cursor.moveToFirst()) {
                    ret = new String[2];
                    ret[0] = cursor.getString(
                            cursor.getColumnIndex(PASSWORD_USERNAME_COL));
                    ret[1] = cursor.getString(
                            cursor.getColumnIndex(PASSWORD_PASSWORD_COL));
                }
            } catch (IllegalStateException e) {
                Log.e(LOGTAG, "getUsernamePassword", e);
            } finally {
                if (cursor != null) cursor.close();
            }
            return ret;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>connectbot_____connectbot_____HostDatabase_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/connectbot_____connectbot_____HostDatabase.java

android.database.sqlite.SQLiteDatabase.query

/**
	 * Unset any hosts using a pubkey ID that has been deleted.
	 * @param pubkeyId
	 */	@Override
	public KnownHosts getKnownHosts() {
		KnownHosts known = new KnownHosts();

		Cursor c = mDb.<mark>query</mark>(TABLE_HOSTS + " LEFT OUTER JOIN " + TABLE_KNOWNHOSTS
						+ " ON " + TABLE_HOSTS + "._id = "
						+ TABLE_KNOWNHOSTS + "." + FIELD_KNOWNHOSTS_HOSTID,
				new String[] {FIELD_HOST_HOSTNAME, FIELD_HOST_PORT, FIELD_KNOWNHOSTS_HOSTKEYALGO,
						FIELD_KNOWNHOSTS_HOSTKEY},
				null, null, null, null, null);

		if (c != null) {
			int COL_HOSTNAME = c.getColumnIndexOrThrow(FIELD_HOST_HOSTNAME),
					COL_PORT = c.getColumnIndexOrThrow(FIELD_HOST_PORT),
					COL_HOSTKEYALGO = c.getColumnIndexOrThrow(FIELD_KNOWNHOSTS_HOSTKEYALGO),
					COL_HOSTKEY = c.getColumnIndexOrThrow(FIELD_KNOWNHOSTS_HOSTKEY);

			while (c.moveToNext()) {
				String hostname = c.getString(COL_HOSTNAME);
				String hostkeyalgo = c.getString(COL_HOSTKEYALGO);
				int port = c.getInt(COL_PORT);
				byte[] hostkey = c.getBlob(COL_HOSTKEY);

				if (hostkeyalgo == null || hostkeyalgo.length() == 0) continue;
				if (hostkey == null || hostkey.length == 0) continue;

				try {
					known.addHostkey(new String[] {String.format(Locale.US, "%s:%d", hostname, port)},
							hostkeyalgo, hostkey);
				} catch (Exception e) {
					Log.e(TAG, "Problem while adding a known host from database", e);
				}
			}

			c.close();
		}

		return known;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_frameworks_base_____RecoverableKeyStoreDb_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_frameworks_base_____RecoverableKeyStoreDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Sets the {@code generationId} of the platform key for user {@code userId}.
     *
     * @return The primary key ID of the relation.
     */     */
    public @NonNull Map<String, Integer> getStatusForAllKeys(int uid) {
        SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();
        String[] projection = {
                KeysEntry._ID,
                KeysEntry.COLUMN_NAME_ALIAS,
                KeysEntry.COLUMN_NAME_RECOVERY_STATUS};
        String selection =
                KeysEntry.COLUMN_NAME_UID + " = ?";
        String[] selectionArguments = {Integer.toString(uid)};

        try (
            Cursor cursor = db.<mark>query</mark>(
                KeysEntry.TABLE_NAME,
                projection,
                selection,
                selectionArguments,
                /*groupBy=*/ null,
                /*having=*/ null,
                /*orderBy=*/ null)
        ) {
            HashMap<String, Integer> statuses = new HashMap<>();
            while (cursor.moveToNext()) {
                String alias = cursor.getString(
                        cursor.getColumnIndexOrThrow(KeysEntry.COLUMN_NAME_ALIAS));
                int recoveryStatus = cursor.getInt(
                        cursor.getColumnIndexOrThrow(KeysEntry.COLUMN_NAME_RECOVERY_STATUS));
                statuses.put(alias, recoveryStatus);
            }
            return statuses;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codeka_____wwmmo_____ChatStore_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codeka_____wwmmo_____ChatStore.java

android.database.sqlite.SQLiteOpenHelper.getReadableDatabase
android.database.sqlite.SQLiteDatabase.query

/** Gets all messages, regardless of room, from the given start time. */  /** Gets count messages starting from startTime and going back in time. */
  public List<ChatMessage> getMessages(Long roomId, long startTime, int count) {
    String query;
    if (roomId == null) {
      query = "room_id IS NULL";
    } else {
      query = "room_id = ?";
    }
    query += " AND date_posted <= ?";

    String[] queryArgs = new String[roomId == null ? 1 : 2];
    int index = 0;
    if (roomId != null) {
      queryArgs[index++] = String.format(Locale.US, "%d", roomId);
    }
    queryArgs[index] = String.format(Locale.US, "%d", startTime);

    ArrayList<ChatMessage> msgs = new ArrayList<>();
    SQLiteDatabase db = helper.<mark>getReadableDatabase</mark>();
    try (
        Cursor cursor = db.<mark>query</mark>(
            name + "_messages",
            new String[] { "msg" } /* columns */,
            query /* selection */,
            queryArgs/* selectionArgs */,
            null /* groupBy */,
            null /* having */,
            "date_posted DESC" /* orderBy */,
            String.format(Locale.US, "%d", count) /* limit */)) {
      while (cursor.moveToNext()) {
        msgs.add(ChatMessage.ADAPTER.decode(cursor.getBlob(0)));
      }
      Collections.reverse(msgs); // Make it oldest-first.
    } catch (IOException e) {
      log.error("Error fetching chat messages.", e);
    }
    return msgs;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_frameworks_base_____RecoverableKeyStoreDb_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_frameworks_base_____RecoverableKeyStoreDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Active root of trust for the recovery agent.
     *
     * @param userId The userId of the profile the application is running under.
     * @param uid The uid of the application.
     * @param rootAlias The root of trust alias.
     * @return The primary key of the updated row, or -1 if failed.
     *
     * @hide
     */     */
    public @NonNull List<Integer> getRecoveryAgents(int userId) {
        SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();

        String[] projection = { RecoveryServiceMetadataEntry.COLUMN_NAME_UID };
        String selection = RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID + " = ?";
        String[] selectionArguments = { Integer.toString(userId) };

        try (
            Cursor cursor = db.<mark>query</mark>(
                    RecoveryServiceMetadataEntry.TABLE_NAME,
                    projection,
                    selection,
                    selectionArguments,
                    /*groupBy=*/ null,
                    /*having=*/ null,
                    /*orderBy=*/ null)
        ) {
            int count = cursor.getCount();
            ArrayList<Integer> result = new ArrayList<>(count);
            while (cursor.moveToNext()) {
                int uid = cursor.getInt(
                        cursor.getColumnIndexOrThrow(RecoveryServiceMetadataEntry.COLUMN_NAME_UID));
                result.add(uid);
            }
            return result;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TaskController_15.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TaskController.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Open the notes database. If it cannot be opened, try to create a new
     * instance of the database. If it cannot be created, throw an exception to
     * signal the failure
     *
     * @return this (self reference, allowing this to be chained in an
     *         initialization call)
     * @throws SQLException if the database could be neither opened or created
     */
    public ArrayList<TaskModelForWidget> getTasksForWidget(String limit) {

    	Cursor cursor = database.<mark>query</mark>(tasksTable, TaskModelForWidget.FIELD_LIST,
    	        AbstractTaskModel.PROGRESS_PERCENTAGE + " < " +
                AbstractTaskModel.COMPLETE_PERCENTAGE + " AND (" +
                AbstractTaskModel.HIDDEN_UNTIL + " ISNULL OR " + AbstractTaskModel.HIDDEN_UNTIL + " < " +
                System.currentTimeMillis() + ")", null, null, null,
                AbstractTaskModel.IMPORTANCE + " * " + (5 * 24 * 3600 * 1000L) +
                    " + CASE WHEN MAX(pdd, ddd) = 0 THEN " +
                    (System.currentTimeMillis() + (7 * 24 * 3600 * 1000L)) +
                    " ELSE (CASE WHEN pdd = 0 THEN ddd ELSE pdd END) END ASC", limit);

    	try {
            ArrayList<TaskModelForWidget> list = new ArrayList<TaskModelForWidget>();
            for(cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext())
                list.add(new TaskModelForWidget(cursor));
            return list;
    	} finally {
    	    cursor.close();
    	}
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>todoroo_____astrid_____TagController_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/todoroo_____astrid_____TagController.java

android.database.sqlite.SQLiteDatabase.query

/** Returns a TaskModelForView corresponding to the given TagIdentifier */     **/
    public LinkedList<TaskIdentifier> getUntaggedTasks() throws SQLException {
    	HashSet<Long> ids = new HashSet<Long>();

    	String[] tagMapColumns = new String[] { TagToTaskMapping.TASK };
    	Cursor tagMapCursor = tagToTaskMapDatabase.<mark>query</mark>(tagTaskTable,
    			tagMapColumns, null, null, TagToTaskMapping.TASK, null,
    			TagToTaskMapping.TASK + " ASC");

    	SQLiteDatabase taskDatabase = new TaskModelDatabaseHelper(context,
    			tasksTable, tasksTable).getReadableDatabase();
    	String[] taskColumns = new String[] { KEY_ROWID };
    	Cursor taskCursor = taskDatabase.<mark>query</mark>(tasksTable, taskColumns,
    			null, null, null, null, KEY_ROWID + " ASC");

    	LinkedList<TaskIdentifier> list = new LinkedList<TaskIdentifier>();
        try {
        	if(taskCursor.getCount() == 0)
        		return list;

        	do {
        		taskCursor.moveToNext();
                ids.add(taskCursor.getLong(0));
            } while(!taskCursor.isLast());

        	if(tagMapCursor.getCount() > 0) {
        		do {
        			tagMapCursor.moveToNext();
                    ids.remove(tagMapCursor.getLong(0));
                } while(!tagMapCursor.isLast());
        	}
        } finally {
        	taskCursor.close();
        	tagMapCursor.close();
        	taskDatabase.close();
        }

        for(Long id : ids)
        	list.add(new TaskIdentifier(id));
    	return list;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>hushnymous_____android_frameworks_base_____WebViewDatabaseClassic_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/hushnymous_____android_frameworks_base_____WebViewDatabaseClassic.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Set password. Tuple (PASSWORD_HOST_COL, PASSWORD_USERNAME_COL) is unique.
     *
     * @param schemePlusHost The scheme and host for the password
     * @param username The username for the password. If it is null, it means
     *            password can't be saved.
     * @param password The password
     */
    private static void upgradeDatabaseFromV10ToV11() {
        int oldVersion = sDatabase.getVersion();

        if (oldVersion >= 11) {
            // Nothing to do.
            return;
        }

        // Clear out old java stack cookies - this data is now stored in
        // a separate database managed by the Chrome stack.
        sDatabase.execSQL("DROP TABLE IF EXISTS cookies");

        // Likewise for the old cache table.
        sDatabase.execSQL("DROP TABLE IF EXISTS cache");

        // Update form autocomplete  URLs to match new ICS formatting.
        Cursor c = sDatabase.<mark>query</mark>(mTableNames[TABLE_FORMURL_ID], null, null,
                null, null, null, null);
        while (c.moveToNext()) {
            String urlId = Long.toString(c.getLong(c.getColumnIndex(ID_COL)));
            String url = c.getString(c.getColumnIndex(FORMURL_URL_COL));
            ContentValues cv = new ContentValues(1);
            cv.put(FORMURL_URL_COL, WebTextView.urlForAutoCompleteData(url));
            sDatabase.update(mTableNames[TABLE_FORMURL_ID], cv, ID_COL + "=?",
                    new String[] { urlId });
        }
        c.close();
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fookwood_____Launcher3_____LauncherProvider_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fookwood_____Launcher3_____LauncherProvider.java

android.database.sqlite.SQLiteDatabase.query

/**
         * Replaces all shortcuts of type {@link Favorites#ITEM_TYPE_SHORTCUT} which have a valid
         * launcher activity target with {@link Favorites#ITEM_TYPE_APPLICATION}.
         */     */
    private ArrayList<Long> deleteEmptyFolders() {
        ArrayList<Long> folderIds = new ArrayList<>();
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        try (SQLiteTransaction t = new SQLiteTransaction(db)) {
            // Select folders whose id do not match any container value.
            String selection = LauncherSettings.Favorites.ITEM_TYPE + " = "
                    + LauncherSettings.Favorites.ITEM_TYPE_FOLDER + " AND "
                    + LauncherSettings.Favorites._ID +  " NOT IN (SELECT " +
                            LauncherSettings.Favorites.CONTAINER + " FROM "
                                + Favorites.TABLE_NAME + ")";
            try (Cursor c = db.<mark>query</mark>(Favorites.TABLE_NAME,
                    new String[] {LauncherSettings.Favorites._ID},
                    selection, null, null, null, null)) {
                LauncherDbUtils.iterateCursor(c, 0, folderIds);
            }
            if (!folderIds.isEmpty()) {
                db.delete(Favorites.TABLE_NAME, Utilities.createDbSelectionQuery(
                        LauncherSettings.Favorites._ID, folderIds), null);
            }
            t.commit();
        } catch (SQLException ex) {
            Log.e(TAG, ex.getMessage(), ex);
            folderIds.clear();
        }
        return folderIds;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker41_____article-android_____DataSource_8.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker41_____article-android_____DataSource.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Gets a list of categories and the number of articles that each contains, since the provided
     * timestamp.
     *
     * @param timestamp the timestamp to query articles starting at.
     * @return a list of categories.
     */     */
    public Source getSource(long remoteId) {
        Cursor cursor = database.<mark>query</mark>(
                SourceModel.TABLE + " s left outer join " + CategoryModel.TABLE + " c on " +
                        "s." + SourceModel.COLUMN_CATEGORY_ID + " = " +
                        "c." + CategoryModel.COLUMN_ID,
                new String[] {
                        "s." + SourceModel.COLUMN_ID + " as s" + SourceModel.COLUMN_ID,
                        "s." + SourceModel.COLUMN_NAME + " as s" + SourceModel.COLUMN_NAME,
                        "s." + SourceModel.COLUMN_IMAGE_URL + " as s" + SourceModel.COLUMN_IMAGE_URL,
                        "s." + SourceModel.COLUMN_REMOTE_ID + " as s" + SourceModel.COLUMN_REMOTE_ID,
                        "c." + CategoryModel.COLUMN_ID + " as c" + CategoryModel.COLUMN_ID,
                        "c." + CategoryModel.COLUMN_NAME + " as c" + CategoryModel.COLUMN_NAME
                },
                "s." + SourceModel.COLUMN_REMOTE_ID + "=?",
                new String[] {Long.toString(remoteId)},
                null,
                null,
                null);

        if (cursor.moveToFirst()) {
            Source source = new Source(cursor);
            cursor.close();
            return source;
        } else {
            return null;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____DatabaseAdapter_9.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____DatabaseAdapter.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Returns an attribute from a specific column in the database for a specific record and specific table.
     * <p>The attribute is returned as a string which can then be converted to another type if
     * the caller was expecting something other type </p>
     * <p>This method is an override of {@link #getAttribute(String, String)} which allows to select a value from a
     * different table than the one of current adapter instance
     * </p>
     * @param tableName Database table name. See {@link DatabaseSchema}
     * @param recordUID GUID of the record
     * @param columnName Name of the column to be retrieved
     * @return String value of the column entry
     * @throws IllegalArgumentException if either the {@code recordUID} or {@code columnName} do not exist in the database
     */     */
    public AccountType getAccountType(@NonNull String accountUID){
        String type = "";
        Cursor c = mDb.<mark>query</mark>(DatabaseSchema.AccountEntry.TABLE_NAME,
                new String[]{DatabaseSchema.AccountEntry.COLUMN_TYPE},
                DatabaseSchema.AccountEntry.COLUMN_UID + "=?",
                new String[]{accountUID}, null, null, null);
        try {
            if (c.moveToFirst()) {
                type = c.getString(c.getColumnIndexOrThrow(DatabaseSchema.AccountEntry.COLUMN_TYPE));
            } else {
                throw new IllegalArgumentException("account " + accountUID + " does not exist in DB");
            }
        } finally {
            c.close();
        }
        return AccountType.valueOf(type);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____AdvancedPrefDatabase_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____AdvancedPrefDatabase.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Fetches all Geocoders matching the given ID, or all Geocoders if id is null
     * 
     * @param id null to fetch all Geocoders, or the id to fetch a specific one
     * @return an array of Geocoder objects
     */     */
    public synchronized void movePreset(int oldPos, int newPos) {
        if (oldPos == newPos) {
            return;
        }
        SQLiteDatabase db = getWritableDatabase();
        Cursor dbresult = db.<mark>query</mark>(PRESETS_TABLE, new String[] { ID_FIELD }, null, null, null, null, POSITION_FIELD);
        dbresult.moveToFirst();
        int count = dbresult.getCount();
        for (int i = 0; i < count; i++) {
            ContentValues values = new ContentValues();
            if (i == oldPos) {
                values.put(POSITION_FIELD, newPos);
            } else if (oldPos < newPos) { // moving down
                if (i < oldPos || i > newPos) {
                    dbresult.moveToNext();
                    continue;
                }
                values.put(POSITION_FIELD, i - 1); // move everything in between up
            } else {
                if (i > oldPos || i < newPos) {
                    dbresult.moveToNext();
                    continue;
                }
                values.put(POSITION_FIELD, i + 1); // move everything in between down
            }
            db.update(PRESETS_TABLE, values, "id = ?", new String[] { dbresult.getString(0) });
            dbresult.moveToNext();
        }
        dbresult.<mark>close</mark>();
        db.<mark>close</mark>();
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker41_____article-android_____DataSource_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker41_____article-android_____DataSource.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Gets a list of categories and the number of articles that each contains, since the provided
     * timestamp.
     *
     * @param timestamp the timestamp to query articles starting at.
     * @return a list of categories.
     */     */
    public List<Source> getSources() {
        Cursor cursor = database.<mark>query</mark>(
                SourceModel.TABLE + " s left outer join " + CategoryModel.TABLE + " c on " +
                        "s." + SourceModel.COLUMN_CATEGORY_ID + " = " +
                        "c." + CategoryModel.COLUMN_ID,
                new String[] {
                        "s." + SourceModel.COLUMN_ID + " as s" + SourceModel.COLUMN_ID,
                        "s." + SourceModel.COLUMN_NAME + " as s" + SourceModel.COLUMN_NAME,
                        "s." + SourceModel.COLUMN_IMAGE_URL + " as s" + SourceModel.COLUMN_IMAGE_URL,
                        "s." + SourceModel.COLUMN_REMOTE_ID + " as s" + SourceModel.COLUMN_REMOTE_ID,
                        "c." + CategoryModel.COLUMN_ID + " as c" + CategoryModel.COLUMN_ID,
                        "c." + CategoryModel.COLUMN_NAME + " as c" + CategoryModel.COLUMN_NAME
                },
                null,
                null,
                null,
                null,
                "s" + SourceModel.COLUMN_NAME + " asc");

        List<Source> sources = new ArrayList<>();
        if (cursor != null && cursor.moveToFirst()) {
            do {
                sources.add(new Source(cursor));
            } while (cursor.moveToNext());
            cursor.close();
        }

        return sources;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>enricocid_____LaunchEnr_____LauncherProvider_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/enricocid_____LaunchEnr_____LauncherProvider.java

android.database.sqlite.SQLiteDatabase.query

/**
         * Replaces all shortcuts of type {@link Favorites#ITEM_TYPE_SHORTCUT} which have a valid
         * launcher activity target with {@link Favorites#ITEM_TYPE_APPLICATION}.
         */     */
    private ArrayList<Long> deleteEmptyFolders() {
        ArrayList<Long> folderIds = new ArrayList<>();
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        db.beginTransaction();
        try {
            // Select folders whose id do not match any container value.
            String selection = LauncherSettings.Favorites.ITEM_TYPE + " = "
                    + LauncherSettings.Favorites.ITEM_TYPE_FOLDER + " AND "
                    + LauncherSettings.Favorites._ID +  " NOT IN (SELECT " +
                            LauncherSettings.Favorites.CONTAINER + " FROM "
                                + Favorites.TABLE_NAME + ")";
            Cursor c = db.<mark>query</mark>(Favorites.TABLE_NAME,
                    new String[] {LauncherSettings.Favorites._ID},
                    selection, null, null, null, null);
            while (c.moveToNext()) {
                folderIds.add(c.getLong(0));
            }
            c.close();
            if (!folderIds.isEmpty()) {
                db.delete(Favorites.TABLE_NAME, Utilities.createDbSelectionQuery(
                        LauncherSettings.Favorites._ID, folderIds), null);
            }
            db.setTransactionSuccessful();
        } catch (SQLException ex) {
            ex.printStackTrace();
            folderIds.clear();
        } finally {
            db.endTransaction();
        }
        return folderIds;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>tomahawk-player_____tomahawk-android_____DatabaseHelper_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/tomahawk-player_____tomahawk-android_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

/**
     * @param playlistId the id by which to get the correct {@link org.tomahawk.libtomahawk.collection.Playlist}
     * @return the stored {@link org.tomahawk.libtomahawk.collection.Playlist} with playlistId as
     * its id
     */     */
    public Playlist getEmptyPlaylist(String playlistId) {
        String[] columns = new String[]{TomahawkSQLiteHelper.PLAYLISTS_COLUMN_NAME,
                TomahawkSQLiteHelper.PLAYLISTS_COLUMN_CURRENTREVISION,
                TomahawkSQLiteHelper.PLAYLISTS_COLUMN_HATCHETID,
                TomahawkSQLiteHelper.PLAYLISTS_COLUMN_TOPARTISTS};

        Cursor playlistsCursor = mDatabase.<mark>query</mark>(TomahawkSQLiteHelper.TABLE_PLAYLISTS,
                columns, TomahawkSQLiteHelper.PLAYLISTS_COLUMN_ID + " = ?",
                new String[]{playlistId}, null, null, null);
        if (playlistsCursor.moveToFirst()) {
            Playlist playlist = Playlist.get(playlistId);
            playlist.setName(playlistsCursor.getString(0));
            playlist.setCurrentRevision(playlistsCursor.getString(1));
            playlist.setHatchetId(playlistsCursor.getString(2));
            String rawTopArtistsString = playlistsCursor.getString(3);
            if (rawTopArtistsString != null && rawTopArtistsString.length() > 0) {
                playlist.setTopArtistNames(rawTopArtistsString.split("\t\t"));
            }
            playlistsCursor.close();
            playlist.setCount(getPlaylistTrackCount(playlistId));
            return playlist;
        }
        playlistsCursor.close();
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>tomahawk-player_____tomahawk-android_____DatabaseHelper_8.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/tomahawk-player_____tomahawk-android_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Store the given query as a lovedItem, if isLoved is true. Otherwise remove(unlove) the
     * query.
     */     */
    public long getPlaylistTrackCount(String playlistId) {
        long trackCount = -1;
        String[] columns = new String[]{TomahawkSQLiteHelper.PLAYLISTS_COLUMN_TRACKCOUNT};
        Cursor playlistsCursor = mDatabase.<mark>query</mark>(TomahawkSQLiteHelper.TABLE_PLAYLISTS,
                columns, TomahawkSQLiteHelper.PLAYLISTS_COLUMN_ID + " = ?",
                new String[]{playlistId}, null, null, null);
        if (playlistsCursor.moveToFirst()) {
            if (playlistsCursor.isNull(0)) {
                // if no trackcount is stored, we calculate it and store it
                trackCount = DatabaseUtils.queryNumEntries(mDatabase,
                        TomahawkSQLiteHelper.TABLE_TRACKS,
                        TomahawkSQLiteHelper.TRACKS_COLUMN_PLAYLISTID + " = ?",
                        new String[]{playlistId});
                mDatabase.beginTransaction();
                ContentValues values = new ContentValues();
                values.put(TomahawkSQLiteHelper.PLAYLISTS_COLUMN_TRACKCOUNT, trackCount);
                mDatabase.update(TomahawkSQLiteHelper.TABLE_PLAYLISTS, values,
                        TomahawkSQLiteHelper.PLAYLISTS_COLUMN_ID + " = ?",
                        new String[]{playlistId});
                mDatabase.setTransactionSuccessful();
                mDatabase.endTransaction();
            } else {
                trackCount = playlistsCursor.getLong(0);
            }
        }
        playlistsCursor.close();
        return trackCount;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>xamarin_____XobotOS_____WebViewDatabase_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/xamarin_____XobotOS_____WebViewDatabase.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.insert
android.database.sqlite.SQLiteDatabase.insert

/**
     * Get all the values for a form entry with "name" in a given site
     *
     * @param url The url of the site
     * @param name The name of the form entry
     * @return A list of values. Return empty list if nothing is found.
     */     */
    String[] getHttpAuthUsernamePassword(String host, String realm) {
        if (host == null || realm == null || !checkInitialized()){
            return null;
        }

        final String[] columns = new String[] {
                HTTPAUTH_USERNAME_COL, HTTPAUTH_PASSWORD_COL
        };
        final String selection = "(" + HTTPAUTH_HOST_COL + " == ?) AND ("
                + HTTPAUTH_REALM_COL + " == ?)";
        synchronized (mHttpAuthLock) {
            String[] ret = null;
            Cursor cursor = null;
            try {
                cursor = mDatabase.<mark>query</mark>(mTableNames[TABLE_HTTPAUTH_ID],
                        columns, selection, new String[] { host, realm }, null,
                        null, null);
                if (cursor.moveToFirst()) {
                    ret = new String[2];
                    ret[0] = cursor.getString(
                            cursor.getColumnIndex(HTTPAUTH_USERNAME_COL));
                    ret[1] = cursor.getString(
                            cursor.getColumnIndex(HTTPAUTH_PASSWORD_COL));
                }
            } catch (IllegalStateException e) {
                Log.e(LOGTAG, "getHttpAuthUsernamePassword", e);
            } finally {
                if (cursor != null) cursor.close();
            }
            return ret;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>hushnymous_____android_frameworks_base_____WebViewDatabaseClassic_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/hushnymous_____android_frameworks_base_____WebViewDatabaseClassic.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.insert
android.database.sqlite.SQLiteDatabase.insert

/**
     * Get all the values for a form entry with "name" in a given site
     *
     * @param url The url of the site
     * @param name The name of the form entry
     * @return A list of values. Return empty list if nothing is found.
     */     */
    String[] getHttpAuthUsernamePassword(String host, String realm) {
        if (host == null || realm == null || !checkInitialized()){
            return null;
        }

        final String[] columns = new String[] {
                HTTPAUTH_USERNAME_COL, HTTPAUTH_PASSWORD_COL
        };
        final String selection = "(" + HTTPAUTH_HOST_COL + " == ?) AND ("
                + HTTPAUTH_REALM_COL + " == ?)";
        synchronized (mHttpAuthLock) {
            String[] ret = null;
            Cursor cursor = null;
            try {
                cursor = sDatabase.<mark>query</mark>(mTableNames[TABLE_HTTPAUTH_ID],
                        columns, selection, new String[] { host, realm }, null,
                        null, null);
                if (cursor.moveToFirst()) {
                    ret = new String[2];
                    ret[0] = cursor.getString(
                            cursor.getColumnIndex(HTTPAUTH_USERNAME_COL));
                    ret[1] = cursor.getString(
                            cursor.getColumnIndex(HTTPAUTH_PASSWORD_COL));
                }
            } catch (IllegalStateException e) {
                Log.e(LOGTAG, "getHttpAuthUsernamePassword", e);
            } finally {
                if (cursor != null) cursor.close();
            }
            return ret;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>1hakr_____AnExplorer_____RecentsProvider_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/1hakr_____AnExplorer_____RecentsProvider.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete

/**
     * Purge all internal data whose authority matches the given
     * {@link Predicate}.
     */    @Override
    public Cursor <mark>query</mark>(Uri uri, String[] projection, String selection, String[] selectionArgs,
            String sortOrder) {
        final SQLiteDatabase db = mHelper.getReadableDatabase();
        switch (sMatcher.match(uri)) {
            case URI_RECENT:
                final long cutoff = System.currentTimeMillis() - MAX_HISTORY_IN_MILLIS;
                return db.<mark>query</mark>(TABLE_RECENT, projection, RecentColumns.TIMESTAMP + ">" + cutoff,
                        null, null, null, sortOrder);
            case URI_STATE:
                final String authority = uri.getPathSegments().get(1);
                final String rootId = uri.getPathSegments().get(2);
                final String documentId = uri.getPathSegments().get(3);
                return db.<mark>query</mark>(TABLE_STATE, projection, StateColumns.AUTHORITY + "=? AND "
                        + StateColumns.ROOT_ID + "=? AND " + StateColumns.DOCUMENT_ID + "=?",
                        new String[] { authority, rootId, documentId }, null, null, sortOrder);
            case URI_RESUME:
                final String packageName = uri.getPathSegments().get(1);
                return db.<mark>query</mark>(TABLE_RESUME, projection, ResumeColumns.PACKAGE_NAME + "=?",
                        new String[] { packageName }, null, null, sortOrder);
            default:
                return null;
                //throw new UnsupportedOperationException("Unsupported Uri " + uri);
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>fookwood_____Launcher3_____LauncherProvider_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/fookwood_____Launcher3_____LauncherProvider.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.compileStatement
android.database.sqlite.SQLiteStatement.bindLong
android.database.sqlite.SQLiteStatement.executeUpdateDelete

/**
         * Recreates workspace table and migrates data to the new table.
         */        @TargetApi(Build.VERSION_CODES.O)
        public void removeGhostWidgets(SQLiteDatabase db) {
            // Get all existing widget ids.
            final AppWidgetHost host = newLauncherWidgetHost();
            final int[] allWidgets;
            try {
                // Although the method was defined in O, it has existed since the beginning of time,
                // so it might work on older platforms as well.
                allWidgets = host.getAppWidgetIds();
            } catch (IncompatibleClassChangeError e) {
                Log.e(TAG, "getAppWidgetIds not supported", e);
                return;
            }
            final HashSet<Integer> validWidgets = new HashSet<>();
            try (Cursor c = db.<mark>query</mark>(Favorites.TABLE_NAME,
                    new String[] {Favorites.APPWIDGET_ID },
                    "itemType=" + Favorites.ITEM_TYPE_APPWIDGET, null, null, null, null)) {
                while (c.moveToNext()) {
                    validWidgets.add(c.getInt(0));
                }
            } catch (SQLException ex) {
                Log.w(TAG, "Error getting widgets list", ex);
                return;
            }
            for (int widgetId : allWidgets) {
                if (!validWidgets.contains(widgetId)) {
                    try {
                        FileLog.d(TAG, "Deleting invalid widget " + widgetId);
                        host.deleteAppWidgetId(widgetId);
                    } catch (RuntimeException e) {
                        // Ignore
                    }
                }
            }
        }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_packages_apps_browser_____BrowserProvider2_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_packages_apps_browser_____BrowserProvider2.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Does a query to find the matching bookmarks and updates each one with the provided values.
     */    // With this, that drops to 0 or 1, depending on if the thumbnail changed.
    private boolean shouldUpdateImages(
            SQLiteDatabase db, String url, ContentValues values) {
        final String[] projection = new String[] {
                Images.FAVICON,
                Images.THUMBNAIL,
                Images.TOUCH_ICON,
        };
        Cursor cursor = db.<mark>query</mark>(TABLE_IMAGES, projection, Images.URL + "=?",
                new String[] { url }, null, null, null);
        byte[] nfavicon = values.getAsByteArray(Images.FAVICON);
        byte[] nthumb = values.getAsByteArray(Images.THUMBNAIL);
        byte[] ntouch = values.getAsByteArray(Images.TOUCH_ICON);
        byte[] cfavicon = null;
        byte[] cthumb = null;
        byte[] ctouch = null;
        try {
            if (cursor.getCount() <= 0) {
                return nfavicon != null || nthumb != null || ntouch != null;
            }
            while (cursor.moveToNext()) {
                if (nfavicon != null) {
                    cfavicon = cursor.getBlob(0);
                    if (!Arrays.equals(nfavicon, cfavicon)) {
                        return true;
                    }
                }
                if (nthumb != null) {
                    cthumb = cursor.getBlob(1);
                    if (!Arrays.equals(nthumb, cthumb)) {
                        return true;
                    }
                }
                if (ntouch != null) {
                    ctouch = cursor.getBlob(2);
                    if (!Arrays.equals(ntouch, ctouch)) {
                        return true;
                    }
                }
            }
        } finally {
            cursor.close();
        }
        return false;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker24_____launcher3_____LauncherProvider_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker24_____launcher3_____LauncherProvider.java

android.database.sqlite.SQLiteDatabase.beginTransaction
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.setTransactionSuccessful
android.database.sqlite.SQLiteDatabase.endTransaction

/**
     * Overridden in tests
     */    @Override
    public int <mark>delete</mark>(Uri uri, String selection, String[] selectionArgs) {
        createDbIfNotExists();
        SqlArguments args = new SqlArguments(uri, selection, selectionArgs);

        SQLiteDatabase db = mOpenHelper.getWritableDatabase();

        if (Binder.getCallingPid() != Process.myPid()
                && Favorites.TABLE_NAME.equalsIgnoreCase(args.table)) {
            String widgetSelection = TextUtils.isEmpty(args.where) ? "1=1" : args.where;
            widgetSelection = String.format(Locale.ENGLISH, "%1$s = %2$d AND ( %3$s )",
                    Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPWIDGET, widgetSelection);
            try (Cursor c = db.<mark>query</mark>(Favorites.TABLE_NAME, new String[] { Favorites.APPWIDGET_ID },
                    widgetSelection, args.args, null, null, null)) {
                AppWidgetHost host = new AppWidgetHost(getContext(), Launcher.APPWIDGET_HOST_ID);
                while (c.moveToNext()) {
                    int widgetId = c.getInt(0);
                    if (widgetId != AppWidgetManager.INVALID_APPWIDGET_ID) {
                        try {
                            host.deleteAppWidgetId(widgetId);
                        } catch (RuntimeException e) {
                            Log.e(TAG, "Error deleting widget id " + widgetId, e);
                        }
                    }
                }
            }
        }
        int count = db.<mark>delete</mark>(args.table, args.where, args.args);
        if (count > 0) {
            notifyListeners();
            reloadLauncherIfExternal();
        }
        return count;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>Deletescape-Media_____Lawnchair_____LauncherProvider_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/Deletescape-Media_____Lawnchair_____LauncherProvider.java

android.database.sqlite.SQLiteDatabase.beginTransaction
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.setTransactionSuccessful
android.database.sqlite.SQLiteDatabase.endTransaction

/**
     * Overridden in tests
     */    @Override
    public int <mark>delete</mark>(@NonNull Uri uri, String selection, String[] selectionArgs) {
        createDbIfNotExists();
        SqlArguments args = new SqlArguments(uri, selection, selectionArgs);

        SQLiteDatabase db = mOpenHelper.getWritableDatabase();

        if (Binder.getCallingPid() != Process.myPid()
                && Favorites.TABLE_NAME.equalsIgnoreCase(args.table)) {
            String widgetSelection = TextUtils.isEmpty(args.where) ? "1=1" : args.where;
            widgetSelection = String.format(Locale.ENGLISH, "%1$s = %2$d AND ( %3$s )",
                    Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPWIDGET, widgetSelection);
            try (Cursor c = db.<mark>query</mark>(Favorites.TABLE_NAME, new String[]{Favorites.APPWIDGET_ID},
                    widgetSelection, args.args, null, null, null)) {
                AppWidgetHost host = new AppWidgetHost(getContext(), Launcher.APPWIDGET_HOST_ID);
                while (c.moveToNext()) {
                    int widgetId = c.getInt(0);
                    if (widgetId != AppWidgetManager.INVALID_APPWIDGET_ID) {
                        try {
                            host.deleteAppWidgetId(widgetId);
                        } catch (RuntimeException e) {
                            Log.e(TAG, "Error deleting widget id " + widgetId, e);
                        }
                    }
                }
            }
        }
        int count = db.<mark>delete</mark>(args.table, args.where, args.args);
        if (count > 0) {
            notifyListeners();
            reloadLauncherIfExternal();
        }
        return count;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>hushnymous_____android_frameworks_base_____WebViewDatabaseClassic_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/hushnymous_____android_frameworks_base_____WebViewDatabaseClassic.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

/**
     * @see WebViewDatabase#hasFormData
     */     */
    void setFormData(String url, HashMap<String, String> formdata) {
        if (url == null || formdata == null || !checkInitialized()) {
            return;
        }

        final String selection = "(" + FORMURL_URL_COL + " == ?)";
        synchronized (mFormLock) {
            long urlid = -1;
            Cursor cursor = null;
            try {
                cursor = sDatabase.<mark>query</mark>(mTableNames[TABLE_FORMURL_ID],
                        ID_PROJECTION, selection, new String[] { url }, null, null,
                        null);
                if (cursor.moveToFirst()) {
                    urlid = cursor.getLong(cursor.getColumnIndex(ID_COL));
                } else {
                    ContentValues c = new ContentValues();
                    c.put(FORMURL_URL_COL, url);
                    urlid = sDatabase.insert(
                            mTableNames[TABLE_FORMURL_ID], null, c);
                }
            } catch (IllegalStateException e) {
                Log.e(LOGTAG, "setFormData", e);
            } finally {
                if (cursor != null) cursor.close();
            }
            if (urlid >= 0) {
                Set<Entry<String, String>> set = formdata.entrySet();
                Iterator<Entry<String, String>> iter = set.iterator();
                ContentValues map = new ContentValues();
                map.put(FORMDATA_URLID_COL, urlid);
                while (iter.hasNext()) {
                    Entry<String, String> entry = iter.next();
                    map.put(FORMDATA_NAME_COL, entry.getKey());
                    map.put(FORMDATA_VALUE_COL, entry.getValue());
                    sDatabase.insert(mTableNames[TABLE_FORMDATA_ID], null, map);
                }
            }
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker24_____launcher3_____LauncherProvider_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker24_____launcher3_____LauncherProvider.java

android.database.sqlite.SQLiteDatabase.beginTransaction
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.compileStatement
android.database.sqlite.SQLiteStatement.bindLong
android.database.sqlite.SQLiteStatement.executeUpdateDelete
android.database.sqlite.SQLiteDatabase.setTransactionSuccessful
android.database.sqlite.SQLiteDatabase.endTransaction
android.database.sqlite.SQLiteStatement.close

/**
         * Recreates workspace table and migrates data to the new table.
         */     */
    private ArrayList<Long> deleteEmptyFolders() {
        ArrayList<Long> folderIds = new ArrayList<>();
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        db.<mark>beginTransaction</mark>();
        try {
            // Select folders whose id do not match any container value.
            String selection = LauncherSettings.Favorites.ITEM_TYPE + " = "
                    + LauncherSettings.Favorites.ITEM_TYPE_FOLDER + " AND "
                    + LauncherSettings.Favorites._ID +  " NOT IN (SELECT " +
                            LauncherSettings.Favorites.CONTAINER + " FROM "
                                + Favorites.TABLE_NAME + ")";
            Cursor c = db.<mark>query</mark>(Favorites.TABLE_NAME,
                    new String[] {LauncherSettings.Favorites._ID},
                    selection, null, null, null, null);
            while (c.moveToNext()) {
                folderIds.add(c.getLong(0));
            }
            c.<mark>close</mark>();
            if (!folderIds.isEmpty()) {
                db.delete(Favorites.TABLE_NAME, Utilities.createDbSelectionQuery(
                        LauncherSettings.Favorites._ID, folderIds), null);
            }
            db.<mark>setTransactionSuccessful</mark>();
        } catch (SQLException ex) {
            Log.e(TAG, ex.getMessage(), ex);
            folderIds.clear();
        } finally {
            db.<mark>endTransaction</mark>();
        }
        return folderIds;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>enricocid_____LaunchEnr_____LauncherProvider_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/enricocid_____LaunchEnr_____LauncherProvider.java

android.database.sqlite.SQLiteDatabase.beginTransaction
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.compileStatement
android.database.sqlite.SQLiteStatement.bindLong
android.database.sqlite.SQLiteStatement.executeUpdateDelete
android.database.sqlite.SQLiteDatabase.setTransactionSuccessful
android.database.sqlite.SQLiteDatabase.endTransaction
android.database.sqlite.SQLiteStatement.close

/**
         * Recreates workspace table and migrates data to the new table.
         */         */
        void removeGhostWidgets(SQLiteDatabase db) {
            // Get all existing widget ids.
            final AppWidgetHost host = newLauncherWidgetHost();
            final int[] allWidgets;
            try {
                Method getter = AppWidgetHost.class.getDeclaredMethod("getAppWidgetIds");
                getter.setAccessible(true);
                allWidgets = (int[]) getter.invoke(host);
            } catch (Exception e) {
                e.printStackTrace();
                return;
            }
            try {
                Cursor c = db.<mark>query</mark>(Favorites.TABLE_NAME,
                        new String[] {Favorites.APPWIDGET_ID },
                        "itemType=" + Favorites.ITEM_TYPE_APPWIDGET, null, null, null, null);
                HashSet<Integer> validWidgets = new HashSet<>();
                while (c.moveToNext()) {
                    validWidgets.add(c.getInt(0));
                }
                c.<mark>close</mark>();

                for (int widgetId : allWidgets) {
                    if (!validWidgets.contains(widgetId)) {
                        try {
                            host.deleteAppWidgetId(widgetId);
                        } catch (RuntimeException e) {
                            // Ignore
                        }
                    }
                }
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
        }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>wildabeast_____BarcodeScanner_____HistoryManager_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/wildabeast_____BarcodeScanner_____HistoryManager.java

android.database.sqlite.SQLiteOpenHelper.getWritableDatabase
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete

/**
   * <p>Builds a text representation of the scanning history. Each scan is encoded on one
   * line, terminated by a line break (\r\n). The values in each line are comma-separated,
   * and double-quoted. Double-quotes within values are escaped with a sequence of two
   * double-quotes. The fields output are:</p>
   *
   * <ul>
   *  <li>Raw text</li>
   *  <li>Display text</li>
   *  <li>Format (e.g. QR_CODE)</li>
   *  <li>Timestamp</li>
   *  <li>Formatted version of timestamp</li>
   * </ul>
   */
  public void addHistoryItemDetails(String itemID, String itemDetails) {
    // As we're going to do an update only we don't need need to worry
    // about the preferences; if the item wasn't saved it won't be udpated
    SQLiteOpenHelper helper = new DBHelper(activity);
    SQLiteDatabase db = null;    
    Cursor cursor = null;
    try {
      db = helper.<mark>getWritableDatabase</mark>();
      cursor = db.<mark>query</mark>(DBHelper.TABLE_NAME,
                        ID_DETAIL_COL_PROJECTION,
                        DBHelper.TEXT_COL + "=?",
                        new String[] { itemID },
                        null,
                        null,
                        DBHelper.TIMESTAMP_COL + " DESC",
                        "1");
      String oldID = null;
      String oldDetails = null;
      if (cursor.moveToNext()) {
        oldID = cursor.getString(0);
        oldDetails = cursor.getString(1);
      }

      if (oldID != null) {
        String newDetails = oldDetails == null ? itemDetails : oldDetails + " : " + itemDetails;
        ContentValues values = new ContentValues();
        values.put(DBHelper.DETAILS_COL, newDetails);
        db.update(DBHelper.TABLE_NAME, values, DBHelper.ID_COL + "=?", new String[] { oldID });
      }

    } finally {
      close(cursor, db);
    }
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>xamarin_____XobotOS_____WebViewDatabase_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/xamarin_____XobotOS_____WebViewDatabase.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

/**
     * Find out if there is form data saved.
     *
     * @return TRUE if there is form data in the database
     */     */
    void setFormData(String url, HashMap<String, String> formdata) {
        if (url == null || formdata == null || !checkInitialized()) {
            return;
        }

        final String selection = "(" + FORMURL_URL_COL + " == ?)";
        synchronized (mFormLock) {
            long urlid = -1;
            Cursor cursor = null;
            try {
                cursor = mDatabase.<mark>query</mark>(mTableNames[TABLE_FORMURL_ID],
                        ID_PROJECTION, selection, new String[] { url }, null, null,
                        null);
                if (cursor.moveToFirst()) {
                    urlid = cursor.getLong(cursor.getColumnIndex(ID_COL));
                } else {
                    ContentValues c = new ContentValues();
                    c.put(FORMURL_URL_COL, url);
                    urlid = mDatabase.insert(
                            mTableNames[TABLE_FORMURL_ID], null, c);
                }
            } catch (IllegalStateException e) {
                Log.e(LOGTAG, "setFormData", e);
            } finally {
                if (cursor != null) cursor.close();
            }
            if (urlid >= 0) {
                Set<Entry<String, String>> set = formdata.entrySet();
                Iterator<Entry<String, String>> iter = set.iterator();
                ContentValues map = new ContentValues();
                map.put(FORMDATA_URLID_COL, urlid);
                while (iter.hasNext()) {
                    Entry<String, String> entry = iter.next();
                    map.put(FORMDATA_NAME_COL, entry.getKey());
                    map.put(FORMDATA_VALUE_COL, entry.getValue());
                    mDatabase.insert(mTableNames[TABLE_FORMDATA_ID], null, map);
                }
            }
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____MigrationHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____MigrationHelper.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Copies the contents of the file in {@code src} to {@code dst} and then deletes the {@code src} if copy was successful.
     * If the file copy was unsuccessful, the src file will not be deleted.
     * @param src Source file
     * @param dst Destination file
     * @throws IOException if an error occurred during the file copy
     */     */
    static String getFullyQualifiedAccountName(SQLiteDatabase db, String accountUID){
        //get the parent account UID of the account
        Cursor cursor = db.<mark>query</mark>(AccountEntry.TABLE_NAME,
                new String[] {AccountEntry.COLUMN_PARENT_ACCOUNT_UID},
                AccountEntry.COLUMN_UID + " = ?",
                new String[]{accountUID},
                null, null, null, null);

        String parentAccountUID = null;
        if (cursor != null && cursor.moveToFirst()){
            parentAccountUID = cursor.getString(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_PARENT_ACCOUNT_UID));
            cursor.close();
        }

        //get the name of the account
        cursor = db.<mark>query</mark>(AccountEntry.TABLE_NAME,
                new String[]{AccountEntry.COLUMN_NAME},
                AccountEntry.COLUMN_UID + " = ?",
                new String[]{accountUID}, null, null, null);

        String accountName = null;
        if (cursor != null && cursor.moveToFirst()){
            accountName = cursor.getString(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_NAME));
            cursor.close();
        }

        String gnucashRootAccountUID = getGnuCashRootAccountUID(db);
        if (parentAccountUID == null || accountName == null
            || parentAccountUID.equalsIgnoreCase(gnucashRootAccountUID)){
            return accountName;
        }

        String parentAccountName = getFullyQualifiedAccountName(db, parentAccountUID);

        return parentAccountName + AccountsDbAdapter.ACCOUNT_NAME_SEPARATOR + accountName;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matt-allen_____repay-android_____DatabaseHandler_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/matt-allen_____repay-android_____DatabaseHandler.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
	 * Convenience method for knowing how many friend entries are in the database
	 * @return Number of friends in database
	 * @throws NullPointerException If no records are found
	 */	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
		if (oldVersion==1 && newVersion==2){
			// Change to include a debtID
			try{
				ArrayList<Debt> debts = new ArrayList<Debt>();
				Cursor c;
				// Get all current debts from database
				c = db.<mark>query</mark>(Names.D_TABLENAME, new String[]{Names.D_REPAYID, Names.D_DATE, Names.D_AMOUNT, Names.D_DESCRIPTION},
						null, null, null, null, null);
				c.moveToFirst();
				SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);
				do{
					// Entering 0 for debtID since it isn't put into the database
					debts.add(new Debt(0, c.getString(0), sdf.parse(c.getString(1)), new BigDecimal(c.getString(2)), c.getString(3)));
				} while (c.moveToNext());

				// Drop old table and create new one
				db.execSQL(String.format("ALTER TABLE %s RENAME TO oldDebts", Names.D_TABLENAME));
				db.execSQL(String.format("CREATE TABLE %s (%s INTEGER PRIMARY KEY AUTOINCREMENT, %s TEXT NOT NULL, "
								+ "%s TEXT, %s TEXT, %s TEXT, FOREIGN KEY(%s) REFERENCES %s(%s))", Names.D_TABLENAME,
						Names.D_DEBTID, Names.D_REPAYID, Names.D_DATE, Names.D_AMOUNT,
						Names.D_DESCRIPTION, Names.D_REPAYID, Names.F_TABLENAME, Names.F_REPAYID));

				// Add data back in new format
				ContentValues values;
				for(int i=0;i<=debts.size()-1;i++){
					values = new ContentValues();
					values.put(Names.D_REPAYID, debts.get(i).getRepayID());
					values.put(Names.D_AMOUNT, debts.get(i).getAmount().toString());
					values.put(Names.D_DATE, debts.get(i).getDate().toString());
					values.put(Names.D_DESCRIPTION, debts.get(i).getDescription());
					db.insert(Names.D_TABLENAME, null, values);
				}
			} catch (Exception e){
				Log.e(TAG, e.getMessage());
				e.printStackTrace();
			}
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_frameworks_base_____RecoverableKeyStoreDb_9.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_frameworks_base_____RecoverableKeyStoreDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Sets a binary value in the database.
     *
     * @param userId The userId of the profile the application is running under.
     * @param uid The uid of the application who initialized the local recovery components.
     * @param key defined in {@code RecoveryServiceMetadataEntry}
     * @param value new value.
     * @return The primary key of the inserted row, or -1 if failed.
     *
     * @hide
     */     */
    private Long getLong(int userId, int uid, String key) {
        SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();

        String[] projection = {
                RecoveryServiceMetadataEntry._ID,
                RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID,
                RecoveryServiceMetadataEntry.COLUMN_NAME_UID,
                key};
        String selection =
                RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID + " = ? AND "
                        + RecoveryServiceMetadataEntry.COLUMN_NAME_UID + " = ?";
        String[] selectionArguments = {Integer.toString(userId), Integer.toString(uid)};

        try (
            Cursor cursor = db.<mark>query</mark>(
                    RecoveryServiceMetadataEntry.TABLE_NAME,
                    projection,
                    selection,
                    selectionArguments,
                    /*groupBy=*/ null,
                    /*having=*/ null,
                    /*orderBy=*/ null)
        ) {
            int count = cursor.getCount();
            if (count == 0) {
                return null;
            }
            if (count > 1) {
                Log.wtf(TAG,
                        String.format(Locale.US,
                                "%d entries found for userId=%d uid=%d. "
                                        + "Should only ever be 0 or 1.", count, userId, uid));
                return null;
            }
            cursor.moveToFirst();
            int idx = cursor.getColumnIndexOrThrow(key);
            if (cursor.isNull(idx)) {
                return null;
            } else {
                return cursor.getLong(idx);
            }
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>mitoyarzun_____zxingfragmentlib_____HistoryManager_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/mitoyarzun_____zxingfragmentlib_____HistoryManager.java

android.database.sqlite.SQLiteOpenHelper.getWritableDatabase
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete

/**
   * <p>Builds a text representation of the scanning history. Each scan is encoded on one
   * line, terminated by a line break (\r\n). The values in each line are comma-separated,
   * and double-quoted. Double-quotes within values are escaped with a sequence of two
   * double-quotes. The fields output are:</p>
   *
   * <ul>
   *  <li>Raw text</li>
   *  <li>Display text</li>
   *  <li>Format (e.g. QR_CODE)</li>
   *  <li>Timestamp</li>
   *  <li>Formatted version of timestamp</li>
   * </ul>
   */
  public void addHistoryItemDetails(String itemID, String itemDetails) {
    // As we're going to do an update only we don't need need to worry
    // about the preferences; if the item wasn't saved it won't be udpated
    SQLiteOpenHelper helper = new DBHelper(activity);
    SQLiteDatabase db = null;    
    Cursor cursor = null;
    try {
      db = helper.<mark>getWritableDatabase</mark>();
      cursor = db.<mark>query</mark>(DBHelper.TABLE_NAME,
                        ID_DETAIL_COL_PROJECTION,
                        DBHelper.TEXT_COL + "=?",
                        new String[] { itemID },
                        null,
                        null,
                        DBHelper.TIMESTAMP_COL + " DESC",
                        "1");
      String oldID = null;
      String oldDetails = null;
      if (cursor.moveToNext()) {
        oldID = cursor.getString(0);
        oldDetails = cursor.getString(1);
      }

      if (oldID != null) {
        String newDetails;
        if (oldDetails == null) {
          newDetails = itemDetails;
        } else if (oldDetails.contains(itemDetails)) {
          newDetails = null;
        } else {
          newDetails = oldDetails + " : " + itemDetails;
        } 
        if (newDetails != null) {
          ContentValues values = new ContentValues();
          values.put(DBHelper.DETAILS_COL, newDetails);
          db.update(DBHelper.TABLE_NAME, values, DBHelper.ID_COL + "=?", new String[] { oldID });
        }
      }

    } finally {
      close(cursor, db);
    }
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_frameworks_base_____RecoverableKeyStoreDb_10.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_frameworks_base_____RecoverableKeyStoreDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Sets a binary value in the database.
     *
     * @param userId The userId of the profile the application is running under.
     * @param uid The uid of the application who initialized the local recovery components.
     * @param rootAlias The root of trust alias.
     * @param key defined in {@code RootOfTrustEntry}
     * @param value new value.
     * @return The primary key of the inserted row, or -1 if failed.
     *
     * @hide
     */     */
    private byte[] getBytes(int userId, int uid, String key) {
        SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();

        String[] projection = {
                RecoveryServiceMetadataEntry._ID,
                RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID,
                RecoveryServiceMetadataEntry.COLUMN_NAME_UID,
                key};
        String selection =
                RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID + " = ? AND "
                        + RecoveryServiceMetadataEntry.COLUMN_NAME_UID + " = ?";
        String[] selectionArguments = {Integer.toString(userId), Integer.toString(uid)};

        try (
            Cursor cursor = db.<mark>query</mark>(
                    RecoveryServiceMetadataEntry.TABLE_NAME,
                    projection,
                    selection,
                    selectionArguments,
                    /*groupBy=*/ null,
                    /*having=*/ null,
                    /*orderBy=*/ null)
        ) {
            int count = cursor.getCount();
            if (count == 0) {
                return null;
            }
            if (count > 1) {
                Log.wtf(TAG,
                        String.format(Locale.US,
                                "%d entries found for userId=%d uid=%d. "
                                        + "Should only ever be 0 or 1.", count, userId, uid));
                return null;
            }
            cursor.moveToFirst();
            int idx = cursor.getColumnIndexOrThrow(key);
            if (cursor.isNull(idx)) {
                return null;
            } else {
                return cursor.getBlob(idx);
            }
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>yukuku_____androidbible_____InternalDb_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/yukuku_____androidbible_____InternalDb.java

android.database.sqlite.SQLiteDatabase.beginTransactionNonExclusive
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.update
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.insert
android.database.sqlite.SQLiteDatabase.setTransactionSuccessful
android.database.sqlite.SQLiteDatabase.endTransaction

/**
	 * Get the highlight color rgb of several verses.
	 * @return the color rgb or -1 if there are multiple colors.
	 */	 */
	public void updateOrInsertPartialHighlight(final int ari, final int colorRgb, final CharSequence verseText, final int startOffset, final int endOffset) {
		final SQLiteDatabase db = helper.getWritableDatabase();

		db.<mark>beginTransactionNonExclusive</mark>();
		try {
			// order by modifyTime desc so we modify the latest one and remove earlier ones if they exist.
			final Cursor c = db.<mark>query</mark>(Db.TABLE_Marker, null, Db.Marker.ari + "=? and " + Db.Marker.kind + "=?", ToStringArray(ari, Marker.Kind.highlight.code), null, null, Db.Marker.modifyTime + " desc");
			try {
				final int hashCode = Highlights.hashCode(verseText.toString());
				final Date now = new Date();

				if (c.moveToNext()) { // check if marker exists
					{ // modify the latest one
						final Marker marker = markerFromCursor(c);
						marker.modifyTime = now;
						marker.caption = Highlights.encode(colorRgb, hashCode, startOffset, endOffset);
						db.<mark>update</mark>(Db.TABLE_Marker, markerToContentValues(marker), "_id=?", ToStringArray(marker._id));
					}

					// remove earlier ones if they exist (caused by sync)
					while (c.moveToNext()) {
						final long _id = c.getLong(c.getColumnIndexOrThrow("_id"));
						db.<mark>delete</mark>(Db.TABLE_Marker, "_id=?", ToStringArray(_id));
					}
				} else { // insert
					final Marker marker = Marker.createNewMarker(ari, Marker.Kind.highlight, Highlights.encode(colorRgb, hashCode, startOffset, endOffset), 1, now, now);
					db.<mark>insert</mark>(Db.TABLE_Marker, null, markerToContentValues(marker));
				}
			} finally {
				c.close();
			}
			db.<mark>setTransactionSuccessful</mark>();
		} finally {
			db.<mark>endTransaction</mark>();
		}

		Sync.notifySyncNeeded(SyncShadow.SYNC_SET_MABEL);
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_frameworks_base_____RecoverableKeyStoreDb_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_frameworks_base_____RecoverableKeyStoreDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Updates status for given key.
     * @param uid of the application
     * @param alias of the key
     * @param status - new status
     * @return number of updated entries.
     * @hide
     **/     */
    @Nullable public WrappedKey getKey(int uid, String alias) {
        SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();
        String[] projection = {
                KeysEntry._ID,
                KeysEntry.COLUMN_NAME_NONCE,
                KeysEntry.COLUMN_NAME_WRAPPED_KEY,
                KeysEntry.COLUMN_NAME_GENERATION_ID,
                KeysEntry.COLUMN_NAME_RECOVERY_STATUS};
        String selection =
                KeysEntry.COLUMN_NAME_UID + " = ? AND "
                + KeysEntry.COLUMN_NAME_ALIAS + " = ?";
        String[] selectionArguments = { Integer.toString(uid), alias };

        try (
            Cursor cursor = db.<mark>query</mark>(
                KeysEntry.TABLE_NAME,
                projection,
                selection,
                selectionArguments,
                /*groupBy=*/ null,
                /*having=*/ null,
                /*orderBy=*/ null)
        ) {
            int count = cursor.getCount();
            if (count == 0) {
                return null;
            }
            if (count > 1) {
                Log.wtf(TAG,
                        String.format(Locale.US,
                                "%d WrappedKey entries found for uid=%d alias='%s'. "
                                        + "Should only ever be 0 or 1.", count, uid, alias));
                return null;
            }
            cursor.moveToFirst();
            byte[] nonce = cursor.getBlob(
                    cursor.getColumnIndexOrThrow(KeysEntry.COLUMN_NAME_NONCE));
            byte[] keyMaterial = cursor.getBlob(
                    cursor.getColumnIndexOrThrow(KeysEntry.COLUMN_NAME_WRAPPED_KEY));
            int generationId = cursor.getInt(
                    cursor.getColumnIndexOrThrow(KeysEntry.COLUMN_NAME_GENERATION_ID));
            int recoveryStatus = cursor.getInt(
                    cursor.getColumnIndexOrThrow(KeysEntry.COLUMN_NAME_RECOVERY_STATUS));
            return new WrappedKey(nonce, keyMaterial, generationId, recoveryStatus);
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>zxing_____zxing_____HistoryManager_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/zxing_____zxing_____HistoryManager.java

android.database.sqlite.SQLiteOpenHelper.getWritableDatabase
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete

/**
   * <p>Builds a text representation of the scanning history. Each scan is encoded on one
   * line, terminated by a line break (\r\n). The values in each line are comma-separated,
   * and double-quoted. Double-quotes within values are escaped with a sequence of two
   * double-quotes. The fields output are:</p>
   *
   * <ol>
   *  <li>Raw text</li>
   *  <li>Display text</li>
   *  <li>Format (e.g. QR_CODE)</li>
   *  <li>Unix timestamp (milliseconds since the epoch)</li>
   *  <li>Formatted version of timestamp</li>
   *  <li>Supplemental info (e.g. price info for a product barcode)</li>
   * </ol>
   */
  public void addHistoryItemDetails(String itemID, String itemDetails) {
    // As we're going to do an update only we don't need need to worry
    // about the preferences; if the item wasn't saved it won't be udpated
    SQLiteOpenHelper helper = new DBHelper(activity);
    try (SQLiteDatabase db = helper.<mark>getWritableDatabase</mark>();
         Cursor cursor = db.<mark>query</mark>(DBHelper.TABLE_NAME,
                                  ID_DETAIL_COL_PROJECTION,
                                  DBHelper.TEXT_COL + "=?",
                                  new String[] { itemID },
                                  null,
                                  null,
                                  DBHelper.TIMESTAMP_COL + " DESC",
                                  "1")) {
      String oldID = null;
      String oldDetails = null;
      if (cursor.moveToNext()) {
        oldID = cursor.getString(0);
        oldDetails = cursor.getString(1);
      }

      if (oldID != null) {
        String newDetails;
        if (oldDetails == null) {
          newDetails = itemDetails;
        } else if (oldDetails.contains(itemDetails)) {
          newDetails = null;
        } else {
          newDetails = oldDetails + " : " + itemDetails;
        } 
        if (newDetails != null) {
          ContentValues values = new ContentValues();
          values.put(DBHelper.DETAILS_COL, newDetails);
          db.update(DBHelper.TABLE_NAME, values, DBHelper.ID_COL + "=?", new String[] { oldID });
        }
      }
    } catch (SQLException sqle) {
      Log.w(TAG, sqle);
    }
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>cyclestreets_____android_____DatabaseHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/cyclestreets_____android_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.compileStatement
android.database.sqlite.SQLiteStatement.bindString
android.database.sqlite.SQLiteStatement.bindString
android.database.sqlite.SQLiteStatement.execute
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.compileStatement
android.database.sqlite.SQLiteStatement.bindString
android.database.sqlite.SQLiteStatement.bindString
android.database.sqlite.SQLiteStatement.execute

/**
   * Helper function that parses a given table into a string
   * and returns it for easy printing. The string consists of
   * the table name and then each row is iterated through with
   * column_name: value pairs printed out.
   *
   * Courtesy of https://stackoverflow.com/a/27003490/2108057
   *
   * @param db the database to get the table from
   * @param tableName the the name of the table to parse
   */
  private void upgradeTo2(final SQLiteDatabase db) {
    try {
      db.<mark>execSQL</mark>("ALTER TABLE route ADD COLUMN waypoints TEXT");
      final Cursor cursor = db.<mark>query</mark>(ROUTE_TABLE,
          new String[] { BaseColumns._ID, "start_lat", "start_long", "end_lat", "end_long" },
          null,
          null,
          null,
          null,
          null);
      if (cursor.moveToFirst())
        do {
          final StringBuilder sb = new StringBuilder();
          sb.append("UPDATE route SET waypoints='")
            .append(cursor.getInt(1))
            .append(',')
            .append(cursor.getInt(2))
            .append('|')
            .append(cursor.getInt(3))
            .append(',')
            .append(cursor.getInt(4))
            .append("' WHERE ")
            .append(BaseColumns._ID).append(" = ").append(cursor.getInt(0));

          final String updateStmt = sb.toString();
          db.<mark>compileStatement</mark>(updateStmt).<mark>execute</mark>();
        } while (cursor.moveToNext());

      if (!cursor.isClosed())
        cursor.close();
    } catch (Exception e) {
      System.out.println(e.getMessage());
    }
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_frameworks_base_____RecoverableKeyStoreDb_11.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_frameworks_base_____RecoverableKeyStoreDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Sets a long value in the database.
     *
     * @param userId The userId of the profile the application is running under.
     * @param uid The uid of the application who initialized the local recovery components.
     * @param rootAlias The root of trust alias.
     * @param key defined in {@code RootOfTrustEntry}
     * @param value new value.
     * @return The primary key of the inserted row, or -1 if failed.
     *
     * @hide
     */     */
    private byte[] getBytes(int userId, int uid, String rootAlias, String key) {
        rootAlias = mTestOnlyInsecureCertificateHelper.getDefaultCertificateAliasIfEmpty(rootAlias);
        SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();

        String[] projection = {
                RootOfTrustEntry._ID,
                RootOfTrustEntry.COLUMN_NAME_USER_ID,
                RootOfTrustEntry.COLUMN_NAME_UID,
                RootOfTrustEntry.COLUMN_NAME_ROOT_ALIAS,
                key};
        String selection =
                RootOfTrustEntry.COLUMN_NAME_USER_ID + " = ? AND "
                        + RootOfTrustEntry.COLUMN_NAME_UID + " = ? AND "
                        + RootOfTrustEntry.COLUMN_NAME_ROOT_ALIAS + " = ?";
        String[] selectionArguments = {Integer.toString(userId), Integer.toString(uid), rootAlias};

        try (
            Cursor cursor = db.<mark>query</mark>(
                    RootOfTrustEntry.TABLE_NAME,
                    projection,
                    selection,
                    selectionArguments,
                    /*groupBy=*/ null,
                    /*having=*/ null,
                    /*orderBy=*/ null)
        ) {
            int count = cursor.getCount();
            if (count == 0) {
                return null;
            }
            if (count > 1) {
                Log.wtf(TAG,
                        String.format(Locale.US,
                                "%d entries found for userId=%d uid=%d. "
                                        + "Should only ever be 0 or 1.", count, userId, uid));
                return null;
            }
            cursor.moveToFirst();
            int idx = cursor.getColumnIndexOrThrow(key);
            if (cursor.isNull(idx)) {
                return null;
            } else {
                return cursor.getBlob(idx);
            }
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>klinker41_____article-android_____DataSource_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/klinker41_____article-android_____DataSource.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Gets all saved articles in the database.
     *
     * NOTE: this method does not return the content associated with the article, that would be
     *       slow as some articles can get very large.
     */     */
    public Article getArticle(String url) {
        // remove any extra query parameters from the url
        url = ArticleUtils.removeUrlParameters(url);

        Cursor cursor = database.<mark>query</mark>(
                ArticleModel.TABLE + " a left outer join " + ContentModel.TABLE + " c " +
                        "on a." + ArticleModel.COLUMN_ID + " = c." + ContentModel.COLUMN_ARTICLE_ID,
                new String[] {
                        "a." + ArticleModel.COLUMN_ID + " as " + ArticleModel.COLUMN_ID,
                        "a." + ArticleModel.COLUMN_ALIAS + " as " + ArticleModel.COLUMN_ALIAS,
                        "a." + ArticleModel.COLUMN_URL + " as " + ArticleModel.COLUMN_URL,
                        "a." + ArticleModel.COLUMN_TITLE + " as " + ArticleModel.COLUMN_TITLE,
                        "a." + ArticleModel.COLUMN_DESCRIPTION + " as " + ArticleModel.COLUMN_DESCRIPTION,
                        "a." + ArticleModel.COLUMN_IMAGE + " as " + ArticleModel.COLUMN_IMAGE,
                        "a." + ArticleModel.COLUMN_AUTHOR + " as " + ArticleModel.COLUMN_AUTHOR,
                        "a." + ArticleModel.COLUMN_SOURCE + " as " + ArticleModel.COLUMN_SOURCE,
                        "a." + ArticleModel.COLUMN_DOMAIN + " as " + ArticleModel.COLUMN_DOMAIN,
                        "a." + ArticleModel.COLUMN_DURATION + " as " + ArticleModel.COLUMN_DURATION,
                        "a." + ArticleModel.COLUMN_INSERTED_AT + " as " + ArticleModel.COLUMN_INSERTED_AT,
                        "a." + ArticleModel.COLUMN_IS_ARTICLE + " as " + ArticleModel.COLUMN_IS_ARTICLE,
                        "a." + ArticleModel.COLUMN_SAVED + " as " + ArticleModel.COLUMN_SAVED,
                        "c." + ContentModel.COLUMN_CONTENT + " as " + ContentModel.COLUMN_CONTENT,
                },
                ArticleModel.COLUMN_URL + "=?",
                new String[] { url },
                null,
                null,
                null);

        if (cursor != null && cursor.moveToFirst()) {
            Article article = new Article(cursor);
            cursor.close();
            return article;
        } else {
            return null;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_frameworks_base_____RecoverableKeyStoreDb_8.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_frameworks_base_____RecoverableKeyStoreDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Sets a long value in the database.
     *
     * @param userId The userId of the profile the application is running under.
     * @param uid The uid of the application who initialized the local recovery components.
     * @param key defined in {@code RecoveryServiceMetadataEntry}
     * @param value new value.
     * @return The primary key of the inserted row, or -1 if failed.
     *
     * @hide
     */     */
    public @Nullable String getActiveRootOfTrust(int userId, int uid) {
        SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();

        String[] projection = {
                RecoveryServiceMetadataEntry._ID,
                RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID,
                RecoveryServiceMetadataEntry.COLUMN_NAME_UID,
                RecoveryServiceMetadataEntry.COLUMN_NAME_ACTIVE_ROOT_OF_TRUST};
        String selection =
                RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID + " = ? AND "
                        + RecoveryServiceMetadataEntry.COLUMN_NAME_UID + " = ?";
        String[] selectionArguments = {Integer.toString(userId), Integer.toString(uid)};

        try (
                Cursor cursor = db.<mark>query</mark>(
                        RecoveryServiceMetadataEntry.TABLE_NAME,
                        projection,
                        selection,
                        selectionArguments,
                        /*groupBy=*/ null,
                        /*having=*/ null,
                        /*orderBy=*/ null)
        ) {
            int count = cursor.getCount();
            if (count == 0) {
                return null;
            }
            if (count > 1) {
                Log.wtf(TAG,
                        String.format(Locale.US,
                                "%d deviceId entries found for userId=%d uid=%d. "
                                        + "Should only ever be 0 or 1.", count, userId, uid));
                return null;
            }
            cursor.moveToFirst();
            int idx = cursor.getColumnIndexOrThrow(
                    RecoveryServiceMetadataEntry.COLUMN_NAME_ACTIVE_ROOT_OF_TRUST);
            if (cursor.isNull(idx)) {
                return null;
            }
            String result = cursor.getString(idx);
            if (TextUtils.isEmpty(result)) {
                return null;
            }
            return result;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_frameworks_base_____RecoverableKeyStoreDb_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_frameworks_base_____RecoverableKeyStoreDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Updates the public key of the recovery service into the database.
     *
     * @param userId The uid of the profile the application is running under.
     * @param uid The uid of the application to whom the key belongs.
     * @param publicKey The public key of the recovery service.
     * @return The primary key of the inserted row, or -1 if failed.
     *
     * @hide
     */     */
    public Map<String, WrappedKey> getAllKeys(int userId, int recoveryAgentUid,
            int platformKeyGenerationId) {
        SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();
        String[] projection = {
                KeysEntry._ID,
                KeysEntry.COLUMN_NAME_NONCE,
                KeysEntry.COLUMN_NAME_WRAPPED_KEY,
                KeysEntry.COLUMN_NAME_ALIAS,
                KeysEntry.COLUMN_NAME_RECOVERY_STATUS};
        String selection =
                KeysEntry.COLUMN_NAME_USER_ID + " = ? AND "
                + KeysEntry.COLUMN_NAME_UID + " = ? AND "
                + KeysEntry.COLUMN_NAME_GENERATION_ID + " = ?";
        String[] selectionArguments = {
                Integer.toString(userId),
                Integer.toString(recoveryAgentUid),
                Integer.toString(platformKeyGenerationId)
            };

        try (
            Cursor cursor = db.<mark>query</mark>(
                KeysEntry.TABLE_NAME,
                projection,
                selection,
                selectionArguments,
                /*groupBy=*/ null,
                /*having=*/ null,
                /*orderBy=*/ null)
        ) {
            HashMap<String, WrappedKey> keys = new HashMap<>();
            while (cursor.moveToNext()) {
                byte[] nonce = cursor.getBlob(
                        cursor.getColumnIndexOrThrow(KeysEntry.COLUMN_NAME_NONCE));
                byte[] keyMaterial = cursor.getBlob(
                        cursor.getColumnIndexOrThrow(KeysEntry.COLUMN_NAME_WRAPPED_KEY));
                String alias = cursor.getString(
                        cursor.getColumnIndexOrThrow(KeysEntry.COLUMN_NAME_ALIAS));
                int recoveryStatus = cursor.getInt(
                        cursor.getColumnIndexOrThrow(KeysEntry.COLUMN_NAME_RECOVERY_STATUS));
                keys.put(alias, new WrappedKey(nonce, keyMaterial, platformKeyGenerationId,
                        recoveryStatus));
            }
            return keys;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____MBTileProviderDataBase_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____MBTileProviderDataBase.java

android.database.sqlite.SQLiteDatabase.isOpen
android.database.sqlite.SQLiteDatabase.query

/**
     * Get min and max zoom from the existing tiles
     * 
     * This tries first MBTiles 1.3 metadata snd then checks the tiles, likely rather expensive for a large number of
     * tiles
     * 
     * @return an int array holding the min zoom in the first, max zoom in the second element or null
     */     */
    public InputStream getTileStream(@NonNull final MapTile aTile) throws IOException {
        if (DEBUGMODE) {
            Log.d(MapTileFilesystemProvider.DEBUG_TAG, "Trying to retrieve " + aTile + " from db");
        }
        try {
            if (mDatabase.<mark>isOpen</mark>()) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                    SQLiteStatement get = null;
                    try {
                        get = getStatements.acquire();
                        if (get == null) {
                            Log.e(DEBUG_TAG, "statement null");
                            return null;
                        }
                        bindTile(aTile, get);
                        return new ParcelFileDescriptor.AutoCloseInputStream(get.simpleQueryForBlobFileDescriptor());
                    } catch (SQLiteDoneException sde) {
                        // nothing found
                        return null;
                    } finally {
                        if (get != null) {
                            getStatements.release(get);
                        }
                    }
                } else { // old and slow
                    final Cursor c = mDatabase.<mark>query</mark>(T_MBTILES, new String[] { T_MBTILES_DATA }, T_MBTILES_WHERE,
                            new String[] { aTile.rendererID, Integer.toString(aTile.zoomLevel), Integer.toString(aTile.x), Integer.toString(aTile.y) }, null,
                            null, null);
                    try {
                        if (c.moveToFirst()) {
                            return new ByteArrayInputStream(c.getBlob(c.getColumnIndexOrThrow(T_MBTILES_DATA)));
                        }
                    } finally {
                        c.close();
                    }
                }
            }
        } catch (SQLiteException sex) { // handle these exceptions the same
            throw new IOException(sex.getMessage());
        }
        if (DEBUGMODE) {
            Log.d(MapTileFilesystemProvider.DEBUG_TAG, "Tile not found in DB");
        }
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android_____platform_frameworks_base_____RecoverableKeyStoreDb_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/android_____platform_frameworks_base_____RecoverableKeyStoreDb.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Updates the counterId
     *
     * @param userId The userId of the profile the application is running under.
     * @param uid The uid of the application.
     * @param counterId The counterId.
     * @return The primary key of the inserted row, or -1 if failed.
     *
     * @hide
     */     */
    public @NonNull int[] getRecoverySecretTypes(int userId, int uid) {
        SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();

        String[] projection = {
                RecoveryServiceMetadataEntry._ID,
                RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID,
                RecoveryServiceMetadataEntry.COLUMN_NAME_UID,
                RecoveryServiceMetadataEntry.COLUMN_NAME_SECRET_TYPES};
        String selection =
                RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID + " = ? AND "
                        + RecoveryServiceMetadataEntry.COLUMN_NAME_UID + " = ?";
        String[] selectionArguments = {Integer.toString(userId), Integer.toString(uid)};

        try (
                Cursor cursor = db.<mark>query</mark>(
                        RecoveryServiceMetadataEntry.TABLE_NAME,
                        projection,
                        selection,
                        selectionArguments,
                        /*groupBy=*/ null,
                        /*having=*/ null,
                        /*orderBy=*/ null)
        ) {
            int count = cursor.getCount();
            if (count == 0) {
                return new int[]{};
            }
            if (count > 1) {
                Log.wtf(TAG,
                        String.format(Locale.US,
                                "%d deviceId entries found for userId=%d uid=%d. "
                                        + "Should only ever be 0 or 1.", count, userId, uid));
                return new int[]{};
            }
            cursor.moveToFirst();
            int idx = cursor.getColumnIndexOrThrow(
                    RecoveryServiceMetadataEntry.COLUMN_NAME_SECRET_TYPES);
            if (cursor.isNull(idx)) {
                return new int[]{};
            }
            String csv = cursor.getString(idx);
            if (TextUtils.isEmpty(csv)) {
                return new int[]{};
            }
            String[] types = csv.split(",");
            int[] result = new int[types.length];
            for (int i = 0; i < types.length; i++) {
                try {
                    result[i] = Integer.parseInt(types[i]);
                } catch (NumberFormatException e) {
                    Log.wtf(TAG, "String format error " + e);
                }
            }
            return result;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dmfs_____opentasks_____FTSDatabaseHelper_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dmfs_____opentasks_____FTSDatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete

/**
     * Queries the task database to get a cursor with the search results.
     *
     * @param db
     *         The {@link SQLiteDatabase}.
     * @param searchString
     *         The search query string.
     * @param projection
     *         The database projection for the query.
     * @param selection
     *         The selection for the query.
     * @param selectionArgs
     *         The arguments for the query.
     * @param sortOrder
     *         The sorting order of the query.
     *
     * @return A cursor of the task database with the search result.
     */     */
    private static Set<Long> ngramIds(SQLiteDatabase db, Set<String> ngrams)
    {
        if (ngrams.size() == 0)
        {
            return Collections.emptySet();
        }

        Set<String> missingNgrams = new HashSet<>(ngrams);
        Set<Long> ngramIds = new HashSet<>(ngrams.size() * 2);

        for (Iterable<String> chunk : new Chunked<>(NGRAM_SEARCH_CHUNK_SIZE, ngrams))
        {
            // build selection and arguments for each chunk
            // we can't do this in a single query because the length of sql statement and number of arguments is limited.

            StringBuilder selection = new StringBuilder(NGramColumns.TEXT);
            selection.append(" in (");
            boolean first = true;
            List<String> arguments = new ArrayList<>(NGRAM_SEARCH_CHUNK_SIZE);
            for (String ngram : chunk)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    selection.append(",");
                }
                selection.append("?");
                arguments.add(ngram);
            }
            selection.append(" )");

            try (Cursor c = db.<mark>query</mark>(FTS_NGRAM_TABLE, new String[] { NGramColumns.NGRAM_ID, NGramColumns.TEXT }, selection.toString(),
                    arguments.toArray(new String[0]), null, null, null))
            {
                while (c.moveToNext())
                {
                    // remove the ngrams we already have in the table
                    missingNgrams.remove(c.getString(1));
                    // remember its id
                    ngramIds.add(c.getLong(0));
                }
            }
        }

        ContentValues values = new ContentValues(1);

        // now insert the missing ngrams and store their ids
        for (String ngram : missingNgrams)
        {
            values.put(NGramColumns.TEXT, ngram);
            ngramIds.add(db.insert(FTS_NGRAM_TABLE, null, values));
        }
        return ngramIds;

    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>naman14_____Timber_____SongPlayCount_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/naman14_____Timber_____SongPlayCount.java

android.database.sqlite.SQLiteDatabase.beginTransaction
android.database.sqlite.SQLiteDatabase.delete
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.setTransactionSuccessful
android.database.sqlite.SQLiteDatabase.endTransaction

/**
     * @param songId The song Id to remove.
     */     */
    public long[] getTopPlayedResultsForList(long[] ids) {
        final int MAX_NUMBER_SONGS_TO_ANALYZE = 250;

        if (ids == null || ids.length == 0) {
            return null;
        }

        HashSet<Long> uniqueIds = new HashSet<Long>(ids.length);

        // create the list of ids to select against
        StringBuilder selection = new StringBuilder();
        selection.append(SongPlayCountColumns.ID);
        selection.append(" IN (");

        // add the first element to handle the separator case for the first element
        uniqueIds.add(ids[0]);
        selection.append(ids[0]);

        for (int i = 1; i < ids.length; i++) {
            // if the new id doesn't exist
            if (uniqueIds.add(ids[i])) {
                // append a separator
                selection.append(",");

                // append the id
                selection.append(ids[i]);

                // for performance reasons, only look at a certain number of songs
                // in case their playlist is ridiculously large
                if (uniqueIds.size() >= MAX_NUMBER_SONGS_TO_ANALYZE) {
                    break;
                }
            }
        }

        // close out the selection
        selection.append(")");

        long[] sortedList = new long[uniqueIds.size()];

        // now query for the songs
        final SQLiteDatabase database = mMusicDatabase.getReadableDatabase();
        Cursor topSongsCursor = null;
        int idx = 0;

        try {
            topSongsCursor = database.<mark>query</mark>(SongPlayCountColumns.NAME,
                    new String[]{SongPlayCountColumns.ID}, selection.toString(), null, null,
                    null, SongPlayCountColumns.PLAYCOUNTSCORE + " DESC");

            if (topSongsCursor != null && topSongsCursor.moveToFirst()) {
                do {
                    // for each id found, add it to the list and remove it from the unique ids
                    long id = topSongsCursor.getLong(0);
                    sortedList[idx++] = id;
                    uniqueIds.remove(id);
                } while (topSongsCursor.moveToNext());
            }
        } finally {
            if (topSongsCursor != null) {
                topSongsCursor.close();
                topSongsCursor = null;
            }
        }

        // append the remaining items - these are songs that haven't been played recently
        Iterator<Long> iter = uniqueIds.iterator();
        while (iter.hasNext()) {
            sortedList[idx++] = iter.next();
        }

        return sortedList;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____MBTileProviderDataBase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____MBTileProviderDataBase.java

android.database.sqlite.SQLiteDatabase.isOpen
android.database.sqlite.SQLiteStatement.simpleQueryForBlobFileDescriptor
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteException.getMessage

/**
     * Bind the tile values to the prepared statement
     * 
     * @param aTile the tile descriptor
     * @param get the prepared statement
     */     */
    public byte[] getTile(@NonNull final MapTile aTile) throws IOException {
        if (DEBUGMODE) {
            Log.d(MapTileFilesystemProvider.DEBUG_TAG, "Trying to retrieve " + aTile + " from db");
        }
        try {
            if (mDatabase.<mark>isOpen</mark>()) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                    SQLiteStatement get = null;
                    try {
                        get = getStatements.acquire();
                        if (get == null) {
                            Log.e(DEBUG_TAG, "statement null");
                            return null;
                        }
                        bindTile(aTile, get);
                        ParcelFileDescriptor.AutoCloseInputStream acis = new ParcelFileDescriptor.AutoCloseInputStream(get.<mark>simpleQueryForBlobFileDescriptor</mark>());
                        ByteArrayOutputStream bos = new ByteArrayOutputStream();

                        byte[] buffer = new byte[4096];
                        int bytesRead;
                        while ((bytesRead = acis.read(buffer)) != -1) {
                            bos.write(buffer, 0, bytesRead);
                        }
                        acis.close();
                        return bos.toByteArray();
                    } catch (SQLiteDoneException sde) {
                        // nothing found
                        return null;
                    } finally {
                        if (get != null) {
                            getStatements.release(get);
                        }
                    }
                } else { // old and slow
                    final Cursor c = mDatabase.<mark>query</mark>(T_MBTILES, new String[] { T_MBTILES_DATA }, T_MBTILES_WHERE,
                            new String[] { aTile.rendererID, Integer.toString(aTile.zoomLevel), Integer.toString(aTile.x), Integer.toString(aTile.y) }, null,
                            null, null);
                    try {
                        if (c.moveToFirst()) {
                            return c.getBlob(c.getColumnIndexOrThrow(T_MBTILES_DATA));
                        }
                    } finally {
                        c.close();
                    }
                }
            }
        } catch (SQLiteException sex) { // handle these exceptions the same
            throw new IOException(sex.<mark>getMessage</mark>());
        }
        if (DEBUGMODE) {
            Log.d(MapTileFilesystemProvider.DEBUG_TAG, "Tile not found in DB");
        }
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____MigrationHelper_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____MigrationHelper.java

android.database.sqlite.SQLiteDatabase.beginTransaction
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.insert
android.database.sqlite.SQLiteDatabase.update
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.setTransactionSuccessful
android.database.sqlite.SQLiteDatabase.endTransaction

/**
     * Cancel the existing alarm for the scheduled service and restarts/reschedules the service
     */     */
    static int upgradeDbToVersion11(SQLiteDatabase db){
        Log.i(DatabaseHelper.LOG_TAG, "Upgrading database to version 9");
        int oldVersion = 10;

        db.<mark>beginTransaction</mark>();
        try {
            Cursor cursor = db.<mark>query</mark>(ScheduledActionEntry.TABLE_NAME, null,
                    ScheduledActionEntry.COLUMN_TYPE + "= ?",
                    new String[]{ScheduledAction.ActionType.BACKUP.name()}, null, null, null);

            Map<String, String> uidToTagMap = new HashMap<>();
            while (cursor.moveToNext()) {
                String uid = cursor.getString(cursor.getColumnIndexOrThrow(ScheduledActionEntry.COLUMN_UID));
                String tag = cursor.getString(cursor.getColumnIndexOrThrow(ScheduledActionEntry.COLUMN_TAG));
                String[] tokens = tag.split(";");
                try {
                    Timestamp timestamp = TimestampHelper.getTimestampFromUtcString(tokens[2]);
                } catch (IllegalArgumentException ex) {
                    tokens[2] = TimestampHelper.getUtcStringFromTimestamp(PreferencesHelper.getLastExportTime());
                } finally {
                    tag = TextUtils.join(";", tokens);
                }
                uidToTagMap.put(uid, tag);
            }

            cursor.close();

            ContentValues contentValues = new ContentValues();
            for (Map.Entry<String, String> entry : uidToTagMap.entrySet()) {
                contentValues.clear();
                contentValues.put(ScheduledActionEntry.COLUMN_TAG, entry.getValue());
                db.<mark>update</mark>(ScheduledActionEntry.TABLE_NAME, contentValues,
                        ScheduledActionEntry.COLUMN_UID + " = ?", new String[]{entry.getKey()});
            }

            db.<mark>setTransactionSuccessful</mark>();
            oldVersion = 11;
        } finally {
            db.<mark>endTransaction</mark>();
        }
        return oldVersion;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dreeves_____TagTime_____PingsDbAdapter_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dreeves_____TagTime_____PingsDbAdapter.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query

/**
	 * Update the indicated ping using the details provided.
	 * 
	 * @param pingid
	 *            id of ping to update
	 * @param pingnotes
	 *            new note to associate with the ping
	 * @return true if the note was successfully updated, false otherwise
	 */		@Override
		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
			if (oldVersion < 2) {
				Log.w(TAG, "Upgrading database from version " + oldVersion + " to " + newVersion
						+ ", which will destroy all old data");
				db.execSQL("DROP TABLE IF EXISTS pings");
				db.execSQL("DROP TABLE IF EXISTS tags");
				db.execSQL("DROP TABLE IF EXISTS tag_ping");
				onCreate(db);
			} else {
				if (oldVersion < 5 && newVersion >= 5) {
					Log.w(TAG, "Upgrading database from version " + oldVersion + " to " + newVersion
							+ " calculating caches..");
					db.execSQL("ALTER TABLE tags ADD COLUMN used_cache integer");
					db.beginTransaction();
					try {
						// Calculate the first cache.
						Cursor all_tags = db.<mark>query</mark>(TAGS_TABLE, new String[] { KEY_ROWID, KEY_TAG }, null, null, null,
								null, null);
						Integer current_tag_id = 0;
						ContentValues uses_values = new ContentValues();

						all_tags.moveToFirst();
						while (!all_tags.isAfterLast()) {
							current_tag_id = all_tags.getInt(0);
							Cursor count_cr = db.rawQuery("SELECT COUNT(_id) FROM tag_ping WHERE tag_id = ?",
									new String[] { current_tag_id.toString() });
							count_cr.moveToFirst();
							uses_values.put(KEY_USED_CACHE, count_cr.getInt(0));

							if (LOCAL_LOGV) Log.v(TAG, "upgrading the tag entry cache - " + all_tags.getString(1)
									+ " has " + uses_values.getAsString(KEY_USED_CACHE));
							db.update(TAGS_TABLE, uses_values, "_id = ?", new String[] { current_tag_id.toString() });
							all_tags.moveToNext();
						}
						db.setTransactionSuccessful();
					} finally {
						db.endTransaction();
					}
				}

				if (oldVersion < 6 && newVersion >= 6) {
					Log.w(TAG, "Upgrading database from version " + oldVersion + " to " + newVersion
							+ " adding missing ping durations (45 mins)...");
					db.execSQL("ALTER TABLE pings ADD COLUMN period integer");
					db.beginTransaction();
					try {
						// Calculate the first cache.
						Cursor all_pings = db.<mark>query</mark>(PINGS_TABLE, new String[] { KEY_ROWID }, null, null, null, null,
								null);
						Integer current_ping_id = 0;
						ContentValues period_values = new ContentValues();
						period_values.put(KEY_PERIOD, 45);

						all_pings.moveToFirst();
						while (!all_pings.isAfterLast()) {
							current_ping_id = all_pings.getInt(0);

							db.update(PINGS_TABLE, period_values, "_id = ?",
									new String[] { current_ping_id.toString() });
							all_pings.moveToNext();
						}
						db.setTransactionSuccessful();
					} finally {
						db.endTransaction();
					}
				}
			}
		}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____AdvancedPrefDatabase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____AdvancedPrefDatabase.java

android.database.sqlite.SQLiteDatabase.query

/** @return the API object representing the currently selected API */    @Override
    public synchronized void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        Log.d(LOGTAG, "Upgrading API DB");
        if (oldVersion <= 1 && newVersion >= 2) {
            db.execSQL("ALTER TABLE apis ADD COLUMN showicon INTEGER DEFAULT 0");
        }
        if (oldVersion <= 2 && newVersion >= 3) {
            db.execSQL("ALTER TABLE apis ADD COLUMN oauth INTEGER DEFAULT 0");
            db.execSQL("ALTER TABLE apis ADD COLUMN accesstoken TEXT DEFAULT NULL");
            db.execSQL("ALTER TABLE apis ADD COLUMN accesstokensecret TEXT DEFAULT NULL");
            db.execSQL("UPDATE apis SET url='" + Urls.DEFAULT_API + "' WHERE id='" + ID_DEFAULT + "'");
        }
        if (oldVersion <= 3 && newVersion >= 4) {
            db.execSQL("ALTER TABLE presets ADD COLUMN active INTEGER DEFAULT 0");
            db.execSQL("UPDATE presets SET active=1 WHERE id='default'");
        }
        if (oldVersion <= 4 && newVersion >= 5) {
            db.execSQL("UPDATE apis SET url='" + Urls.DEFAULT_API + "' WHERE id='" + ID_DEFAULT + "'");
        }
        if (oldVersion <= 5 && newVersion >= 6) {
            db.execSQL("ALTER TABLE apis ADD COLUMN readonlyurl TEXT DEFAULT NULL");
            db.execSQL("ALTER TABLE apis ADD COLUMN notesurl TEXT DEFAULT NULL");
        }
        if (oldVersion <= 6 && newVersion >= 7) {
            addAPI(db, ID_DEFAULT_NO_HTTPS, Urls.DEFAULT_API_NO_HTTPS_NAME, Urls.DEFAULT_API_NO_HTTPS, null, "", "", ID_DEFAULT_NO_HTTPS, true);
        }
        if (oldVersion <= 7 && newVersion >= 8) {
            db.execSQL("CREATE TABLE geocoders (id TEXT, type TEXT, version INTEGER DEFAULT 0, name TEXT, url TEXT, active INTEGER DEFAULT 0)");
            addGeocoder(db, ID_DEFAULT_GEOCODER_NOMINATIM, ID_DEFAULT_GEOCODER_NOMINATIM, GeocoderType.NOMINATIM, 0, Urls.DEFAULT_NOMINATIM_SERVER, true);
            addGeocoder(db, ID_DEFAULT_GEOCODER_PHOTON, ID_DEFAULT_GEOCODER_PHOTON, GeocoderType.PHOTON, 0, Urls.DEFAULT_PHOTON_SERVER, true);
        }
        if (oldVersion <= 8 && newVersion >= 9) {
            addAPI(db, ID_SANDBOX, Urls.DEFAULT_SANDBOX_API_NAME, Urls.DEFAULT_SANDBOX_API, null, "", "", ID_SANDBOX, true);
        }
        if (oldVersion <= 9 && newVersion >= 10) {
            db.execSQL("ALTER TABLE presets ADD COLUMN position INTEGER DEFAULT 0");
            Cursor dbresult = db.<mark>query</mark>(PRESETS_TABLE, new String[] { ID_FIELD }, null, null, null, null, null);
            dbresult.moveToFirst();
            int count = dbresult.getCount();
            for (int i = 0; i < count; i++) {
                ContentValues values = new ContentValues();
                values.put(POSITION_FIELD, i);
                db.update(PRESETS_TABLE, values, "id = ?", new String[] { dbresult.getString(0) });
                dbresult.moveToNext();
            }
            dbresult.close();
        }
        if (oldVersion <= 10 && newVersion >= 11) {
            db.execSQL("ALTER TABLE presets ADD COLUMN usetranslations INTEGER DEFAULT 1");
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____MigrationHelper_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____MigrationHelper.java

android.database.sqlite.SQLiteDatabase.beginTransaction
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.insert
android.database.sqlite.SQLiteDatabase.update
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.update
android.database.sqlite.SQLiteDatabase.insert
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.insert
android.database.sqlite.SQLiteDatabase.insert
android.database.sqlite.SQLiteDatabase.update
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.execSQL
android.database.sqlite.SQLiteDatabase.setTransactionSuccessful
android.database.sqlite.SQLiteDatabase.endTransaction

/**
     * Upgrades the database from version 8 to version 9.
     * <p>This migration accomplishes the following:
     *  <ul>
     *      <li>Adds a commodities table to the database</li>
     *      <li>Adds prices table to the database</li>
     *      <li>Add separate columns for split value and quantity</li>
     *      <li>Migrate amounts to use the correct denominations for the currency</li>
     *  </ul>
     * </p>
     * @param db SQLite Database to be upgraded
     * @return New database version (9) if upgrade successful, old version (8) if unsuccessful
     * @throws RuntimeException if the default commodities could not be imported
     */     */
    static int upgradeDbToVersion6(SQLiteDatabase db) {
        int oldVersion = 5;
        String addFullAccountNameQuery = " ALTER TABLE " + AccountEntry.TABLE_NAME
                + " ADD COLUMN " + AccountEntry.COLUMN_FULL_NAME + " varchar(255) ";
        db.<mark>execSQL</mark>(addFullAccountNameQuery);

        //update all existing accounts with their fully qualified name
        Cursor cursor = db.<mark>query</mark>(AccountEntry.TABLE_NAME,
                new String[]{AccountEntry._ID, AccountEntry.COLUMN_UID},
                null, null, null, null, null);
        while(cursor != null && cursor.moveToNext()){
            String uid = cursor.getString(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_UID));
            String fullName = getFullyQualifiedAccountName(db, uid);

            if (fullName == null)
                continue;

            ContentValues contentValues = new ContentValues();
            contentValues.put(AccountEntry.COLUMN_FULL_NAME, fullName);

            long id = cursor.getLong(cursor.getColumnIndexOrThrow(AccountEntry._ID));
            db.<mark>update</mark>(AccountEntry.TABLE_NAME, contentValues, AccountEntry._ID + " = " + id, null);
        }

        if (cursor != null) {
            cursor.close();
        }

        oldVersion = 6;
        return oldVersion;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MarcusWolschon_____osmeditor4android_____PhotoIndex_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/MarcusWolschon_____osmeditor4android_____PhotoIndex.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.close

/**
     * Query the in memory index for Photos
     * 
     * @param index the index
     * @param box the BoundingBox we are interested in
     * @return a List of Photos
     */     */
    public synchronized void createOrUpdateIndex() {
        Log.d(LOGTAG, "starting scan");
        // determine at least a few of the possible mount points
        File sdcard = Environment.getExternalStorageDirectory();
        ArrayList<String> mountPoints = new ArrayList<>();
        mountPoints.add(sdcard.getAbsolutePath());
        mountPoints.add(sdcard.getAbsolutePath() + Paths.DIRECTORY_PATH_EXTERNAL_SD_CARD);
        File storageDir = new File(Paths.DIRECTORY_PATH_STORAGE);
        File[] list = storageDir.listFiles();
        if (list != null) {
            for (File f : list) {
                if (f.exists() && f.isDirectory() && !sdcard.getAbsolutePath().equals(f.getAbsolutePath())) {
                    Log.d(LOGTAG, "Adding mount point " + f.getAbsolutePath());
                    mountPoints.add(f.getAbsolutePath());
                }
            }
        }

        try {
            SQLiteDatabase db = getWritableDatabase();
            Cursor dbresult = db.<mark>query</mark>("directories", new String[] { "dir", "last_scan" }, null, null, null, null, null, null);
            int dirCount = dbresult.getCount();
            dbresult.moveToFirst();
            // loop over the directories configured
            for (int i = 0; i < dirCount; i++) {
                String dir = dbresult.getString(0);
                long lastScan = dbresult.getLong(1);
                Log.d(LOGTAG, dbresult.getString(0) + " " + dbresult.getLong(1));
                // loop over all possible mount points
                for (String m : mountPoints) {
                    File indir = new File(m + "/" + dir);
                    Log.d(LOGTAG, "Scanning directory " + indir.getAbsolutePath());
                    if (indir.exists()) {
                        Cursor dbresult2 = db.<mark>query</mark>("photos", new String[] { "distinct dir" }, "dir LIKE '" + indir.getAbsolutePath() + "%'", null, null, null,
                                null, null);
                        int dirCount2 = dbresult2.getCount();
                        dbresult2.moveToFirst();
                        for (int j = 0; j < dirCount2; j++) {
                            String dir2 = dbresult2.getString(0);
                            Log.d(LOGTAG, "Checking dir " + dir2);
                            File pDir = new File(dir2);
                            if (!pDir.exists()) {
                                Log.d(LOGTAG, "Deleting entries for gone dir " + dir2);
                                db.delete("photos", "dir = ?", new String[] { dir2 });
                            }
                            dbresult2.moveToNext();
                        }
                        dbresult2.<mark>close</mark>();
                        scanDir(db, indir.getAbsolutePath(), lastScan);
                        ContentValues values = new ContentValues();
                        Log.d(LOGTAG, "updating last scan for " + indir.getName() + " to " + System.currentTimeMillis());
                        values.put("last_scan", System.currentTimeMillis());
                        db.update("directories", values, "dir = ?", new String[] { indir.getName() });
                    } else {
                        Log.d(LOGTAG, "Directory " + indir.getAbsolutePath() + " doesn't exist");
                        // remove all entries for this directory
                        db.delete("photos", "dir = ?", new String[] { indir.getAbsolutePath() });
                        db.delete("photos", "dir LIKE ?", new String[] { indir.getAbsolutePath() + "/%" });
                    }
                }
                dbresult.moveToNext();
            }
            dbresult.<mark>close</mark>();
            db.<mark>close</mark>();
        } catch (SQLiteException ex) {
            // Don't crash just report
            ACRAHelper.nocrashReport(ex, ex.getMessage());
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>kabouzeid_____Phonograph_____SongPlayCountStore_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/kabouzeid_____Phonograph_____SongPlayCountStore.java

android.database.sqlite.SQLiteDatabase.query

/**
     * This updates all the results for the getTopPlayedResults so that we can get an
     * accurate list of the top played results
     */     */
    private void updateExistingRow(@NonNull final SQLiteDatabase database, final long id, boolean bumpCount) {
        String stringId = String.valueOf(id);

        // begin the transaction
        database.beginTransaction();

        // get the cursor of this content inside the transaction
        final Cursor cursor = database.<mark>query</mark>(SongPlayCountColumns.NAME, null, WHERE_ID_EQUALS,
                new String[]{stringId}, null, null, null);

        // if we have a result
        if (cursor != null && cursor.moveToFirst()) {
            // figure how many weeks since we last updated
            int lastUpdatedIndex = cursor.getColumnIndex(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX);
            int lastUpdatedWeek = cursor.getInt(lastUpdatedIndex);
            int weekDiff = mNumberOfWeeksSinceEpoch - lastUpdatedWeek;

            // if it's more than the number of weeks we track, delete it and create a new entry
            if (Math.abs(weekDiff) >= NUM_WEEKS) {
                // this entry needs to be dropped since it is too outdated
                deleteEntry(database, stringId);
                if (bumpCount) {
                    createNewPlayedEntry(database, id);
                }
            } else if (weekDiff != 0) {
                // else, shift the weeks
                int[] playCounts = new int[NUM_WEEKS];

                if (weekDiff > 0) {
                    // time is shifted forwards
                    for (int i = 0; i < NUM_WEEKS - weekDiff; i++) {
                        playCounts[i + weekDiff] = cursor.getInt(getColumnIndexForWeek(i));
                    }
                } else if (weekDiff < 0) {
                    // time is shifted backwards (by user) - nor typical behavior but we
                    // will still handle it

                    // since weekDiff is -ve, NUM_WEEKS + weekDiff is the real # of weeks we have to
                    // transfer.  Then we transfer the old week i - weekDiff to week i
                    // for example if the user shifted back 2 weeks, ie -2, then for 0 to
                    // NUM_WEEKS + (-2) we set the new week i = old week i - (-2) or i+2
                    for (int i = 0; i < NUM_WEEKS + weekDiff; i++) {
                        playCounts[i] = cursor.getInt(getColumnIndexForWeek(i - weekDiff));
                    }
                }

                // bump the count
                if (bumpCount) {
                    playCounts[0]++;
                }

                float score = calculateScore(playCounts);

                // if the score is non-existant, then delete it
                if (score < .01f) {
                    deleteEntry(database, stringId);
                } else {
                    // create the content values
                    ContentValues values = new ContentValues(NUM_WEEKS + 2);
                    values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX, mNumberOfWeeksSinceEpoch);
                    values.put(SongPlayCountColumns.PLAY_COUNT_SCORE, score);

                    for (int i = 0; i < NUM_WEEKS; i++) {
                        values.put(getColumnNameForWeek(i), playCounts[i]);
                    }

                    // update the entry
                    database.update(SongPlayCountColumns.NAME, values, WHERE_ID_EQUALS,
                            new String[]{stringId});
                }
            } else if (bumpCount) {
                // else no shifting, just update the scores
                ContentValues values = new ContentValues(2);

                // increase the score by a single score amount
                int scoreIndex = cursor.getColumnIndex(SongPlayCountColumns.PLAY_COUNT_SCORE);
                float score = cursor.getFloat(scoreIndex) + getScoreMultiplierForWeek(0);
                values.put(SongPlayCountColumns.PLAY_COUNT_SCORE, score);

                // increase the play count by 1
                values.put(getColumnNameForWeek(0), cursor.getInt(getColumnIndexForWeek(0)) + 1);

                // update the entry
                database.update(SongPlayCountColumns.NAME, values, WHERE_ID_EQUALS,
                        new String[]{stringId});
            }

            cursor.close();
        } else if (bumpCount) {
            // if we have no existing results, create a new one
            createNewPlayedEntry(database, id);
        }

        database.setTransactionSuccessful();
        database.endTransaction();
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>naman14_____Timber_____SongPlayCount_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/naman14_____Timber_____SongPlayCount.java

android.database.sqlite.SQLiteDatabase.query

/**
     * Given a list of ids, it sorts the results based on the most played results
     *
     * @param ids list
     * @return sorted list - this may be smaller than the list passed in for performance reasons
     */     */
    private void updateExistingRow(final SQLiteDatabase database, final long id, boolean bumpCount) {
        String stringId = String.valueOf(id);

        // begin the transaction
        database.beginTransaction();

        // get the cursor of this content inside the transaction
        final Cursor cursor = database.<mark>query</mark>(SongPlayCountColumns.NAME, null, WHERE_ID_EQUALS,
                new String[]{stringId}, null, null, null);

        // if we have a result
        if (cursor != null && cursor.moveToFirst()) {
            // figure how many weeks since we last updated
            int lastUpdatedIndex = cursor.getColumnIndex(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX);
            int lastUpdatedWeek = cursor.getInt(lastUpdatedIndex);
            int weekDiff = mNumberOfWeeksSinceEpoch - lastUpdatedWeek;

            // if it's more than the number of weeks we track, delete it and create a new entry
            if (Math.abs(weekDiff) >= NUM_WEEKS) {
                // this entry needs to be dropped since it is too outdated
                deleteEntry(database, stringId);
                if (bumpCount) {
                    createNewPlayedEntry(database, id);
                }
            } else if (weekDiff != 0) {
                // else, shift the weeks
                int[] playCounts = new int[NUM_WEEKS];

                if (weekDiff > 0) {
                    // time is shifted forwards
                    for (int i = 0; i < NUM_WEEKS - weekDiff; i++) {
                        playCounts[i + weekDiff] = cursor.getInt(getColumnIndexForWeek(i));
                    }
                } else if (weekDiff < 0) {
                    // time is shifted backwards (by user) - nor typical behavior but we
                    // will still handle it

                    // since weekDiff is -ve, NUM_WEEKS + weekDiff is the real # of weeks we have to
                    // transfer.  Then we transfer the old week i - weekDiff to week i
                    // for example if the user shifted back 2 weeks, ie -2, then for 0 to
                    // NUM_WEEKS + (-2) we set the new week i = old week i - (-2) or i+2
                    for (int i = 0; i < NUM_WEEKS + weekDiff; i++) {
                        playCounts[i] = cursor.getInt(getColumnIndexForWeek(i - weekDiff));
                    }
                }

                // bump the count
                if (bumpCount) {
                    playCounts[0]++;
                }

                float score = calculateScore(playCounts);

                // if the score is non-existant, then delete it
                if (score < .01f) {
                    deleteEntry(database, stringId);
                } else {
                    // create the content values
                    ContentValues values = new ContentValues(NUM_WEEKS + 2);
                    values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX, mNumberOfWeeksSinceEpoch);
                    values.put(SongPlayCountColumns.PLAYCOUNTSCORE, score);

                    for (int i = 0; i < NUM_WEEKS; i++) {
                        values.put(getColumnNameForWeek(i), playCounts[i]);
                    }

                    // update the entry
                    database.update(SongPlayCountColumns.NAME, values, WHERE_ID_EQUALS,
                            new String[]{stringId});
                }
            } else if (bumpCount) {
                // else no shifting, just update the scores
                ContentValues values = new ContentValues(2);

                // increase the score by a single score amount
                int scoreIndex = cursor.getColumnIndex(SongPlayCountColumns.PLAYCOUNTSCORE);
                float score = cursor.getFloat(scoreIndex) + getScoreMultiplierForWeek(0);
                values.put(SongPlayCountColumns.PLAYCOUNTSCORE, score);

                // increase the play count by 1
                values.put(getColumnNameForWeek(0), cursor.getInt(getColumnIndexForWeek(0)) + 1);

                // update the entry
                database.update(SongPlayCountColumns.NAME, values, WHERE_ID_EQUALS,
                        new String[]{stringId});
            }

            cursor.close();
        } else if (bumpCount) {
            // if we have no existing results, create a new one
            createNewPlayedEntry(database, id);
        }

        database.setTransactionSuccessful();
        database.endTransaction();
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dmfs_____opentasks_____TaskProvider_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/dmfs_____opentasks_____TaskProvider.java

android.database.sqlite.SQLiteDatabase.replace
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.update
android.database.sqlite.SQLiteDatabase.update

/**
     * Update task due and task start notifications.
     */    @Override
    public int deleteInTransaction(final SQLiteDatabase db, Uri uri, String selection, String[] selectionArgs, final boolean isSyncAdapter)
    {
        int count = 0;
        String accountName = getAccountName(uri);
        String accountType = getAccountType(uri);

        switch (mUriMatcher.match(uri))
        {
            case SYNCSTATE_ID:
                // the id is ignored, we only match by account type and name given in the Uri
            case SYNCSTATE:
            {
                if (!isSyncAdapter)
                {
                    throw new IllegalAccessError("only sync adapters may access syncstate");
                }
                if (TextUtils.isEmpty(getAccountName(uri)) || TextUtils.isEmpty(getAccountType(uri)))
                {
                    throw new IllegalArgumentException("uri must contain an account when accessing syncstate");
                }
                selection = updateSelection(selectAccount(uri), selection);
                count = db.delete(Tables.SYNCSTATE, selection, selectionArgs);
                break;
            }
            /*
             * Deleting task lists is only allowed to sync adapters. They must provide ACCOUNT_NAME and ACCOUNT_TYPE.
             */
            case LIST_ID:
                // add _id to selection and fall through
                selection = updateSelection(selectId(uri), selection);
            case LISTS:
            {
                if (isSyncAdapter)
                {
                    if (TextUtils.isEmpty(accountType) || TextUtils.isEmpty(accountName))
                    {
                        throw new IllegalArgumentException("Sync adapters must specify an account and account type: " + uri);
                    }
                }

                // iterate over all lists that match the selection
                final Cursor cursor = db.<mark>query</mark>(Tables.LISTS, null, selection, selectionArgs, null, null, null, null);

                try
                {
                    while (cursor.moveToNext())
                    {
                        final ListAdapter list = new CursorContentValuesListAdapter(ListAdapter._ID.getFrom(cursor), cursor, new ContentValues());

                        mListProcessorChain.delete(db, list, isSyncAdapter);
                        mChanged.set(true);
                        count++;
                    }
                }
                finally
                {
                    cursor.close();
                }

                break;

            }
            /*
             * Task won't be removed, just marked as deleted if the caller isn't a sync adapter. Sync adapters can remove tasks immediately.
             */
            case TASK_ID:
                // add id to selection and fall through
                selection = updateSelection(selectId(uri), selection);

            case TASKS:
            {
                // TODO: filter by account name and type if present in uri.

                if (isSyncAdapter)
                {
                    if (TextUtils.isEmpty(accountType) || TextUtils.isEmpty(accountName))
                    {
                        throw new IllegalArgumentException("Sync adapters must specify an account and account type: " + uri);
                    }
                }

                // iterate over all tasks that match the selection
                final Cursor cursor = db.<mark>query</mark>(Tables.TASKS_VIEW, null, selection, selectionArgs, null, null, null, null);

                try
                {
                    while (cursor.moveToNext())
                    {
                        final TaskAdapter task = new CursorContentValuesTaskAdapter(cursor, new ContentValues());

                        mTaskProcessorChain.delete(db, task, isSyncAdapter);

                        mChanged.set(true);
                        count++;
                    }
                }
                finally
                {
                    cursor.close();
                }

                break;
            }

            case INSTANCE_ID:
                // add id to selection and fall through
                selection = updateSelection(selectId(uri), selection);

            case INSTANCES:
            {
                // iterate over all instances that match the selection
                try (Cursor cursor = db.<mark>query</mark>(Tables.INSTANCE_VIEW, null, selection, selectionArgs, null, null, null, null))
                {
                    while (cursor.moveToNext())
                    {
                        mInstanceProcessorChain.delete(db, new CursorContentValuesInstanceAdapter(cursor, new ContentValues()), isSyncAdapter);
                        count++;
                    }
                }

                break;
            }

            case ALARM_ID:
                // add id to selection and fall through
                selection = updateSelection(selectId(uri), selection);

            case ALARMS:

                count = db.delete(Tables.ALARMS, selection, selectionArgs);
                break;

            case PROPERTY_ID:
                selection = updateSelection(selectPropertyId(uri), selection);

            case PROPERTIES:
                // fetch all properties that match the selection
                Cursor cursor = db.<mark>query</mark>(Tables.PROPERTIES, null, selection, selectionArgs, null, null, null);

                try
                {
                    int propIdCol = cursor.getColumnIndex(Properties.PROPERTY_ID);
                    int taskIdCol = cursor.getColumnIndex(Properties.TASK_ID);
                    int mimeTypeCol = cursor.getColumnIndex(Properties.MIMETYPE);
                    while (cursor.moveToNext())
                    {
                        long propertyId = cursor.getLong(propIdCol);
                        long taskId = cursor.getLong(taskIdCol);
                        String mimeType = cursor.getString(mimeTypeCol);
                        if (mimeType != null)
                        {
                            PropertyHandler handler = PropertyHandlerFactory.get(mimeType);
                            count += handler.delete(db, taskId, propertyId, cursor, isSyncAdapter);
                        }
                    }
                }
                finally
                {
                    cursor.close();
                }
                postNotifyUri(Properties.getContentUri(mAuthority));
                break;

            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }

        if (count > 0)
        {
            postNotifyUri(uri);
            postNotifyUri(Instances.getContentUri(mAuthority));
            postNotifyUri(Tasks.getContentUri(mAuthority));
        }
        return count;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>codinguser_____gnucash-android_____MigrationHelper_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/codinguser_____gnucash-android_____MigrationHelper.java

android.database.sqlite.SQLiteDatabase.beginTransaction
android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.insert
android.database.sqlite.SQLiteDatabase.setTransactionSuccessful
android.database.sqlite.SQLiteDatabase.endTransaction

/**
     * Upgrade database to version 11
     * <p>
     *     Migrate scheduled backups and update export parameters to the new format
     * </p>
     * @param db SQLite database
     * @return 11 if upgrade was successful, 10 otherwise
     */     */
    static int upgradeDbToVersion8(SQLiteDatabase db) {
        Log.i(DatabaseHelper.LOG_TAG, "Upgrading database to version 8");
        int oldVersion = 7;
        new File(Exporter.LEGACY_BASE_FOLDER_PATH + "/backups/").mkdirs();
        new File(Exporter.LEGACY_BASE_FOLDER_PATH + "/exports/").mkdirs();
        //start moving the files in background thread before we do the database stuff
        new Thread(moveExportedFilesToNewDefaultLocation).start();

        db.<mark>beginTransaction</mark>();
        try {

            Log.i(DatabaseHelper.LOG_TAG, "Creating scheduled actions table");
            db.execSQL("CREATE TABLE " + ScheduledActionEntry.TABLE_NAME + " ("
                    + ScheduledActionEntry._ID                   + " integer primary key autoincrement, "
                    + ScheduledActionEntry.COLUMN_UID            + " varchar(255) not null UNIQUE, "
                    + ScheduledActionEntry.COLUMN_ACTION_UID    + " varchar(255) not null, "
                    + ScheduledActionEntry.COLUMN_TYPE           + " varchar(255) not null, "
                    + "period "                                 + " integer not null, "
                    + ScheduledActionEntry.COLUMN_LAST_RUN       + " integer default 0, "
                    + ScheduledActionEntry.COLUMN_START_TIME     + " integer not null, "
                    + ScheduledActionEntry.COLUMN_END_TIME       + " integer default 0, "
                    + ScheduledActionEntry.COLUMN_TAG            + " text, "
                    + ScheduledActionEntry.COLUMN_ENABLED        + " tinyint default 1, " //enabled by default
                    + ScheduledActionEntry.COLUMN_TOTAL_FREQUENCY + " integer default 0, "
                    + ScheduledActionEntry.COLUMN_EXECUTION_COUNT+ " integer default 0, "
                    + ScheduledActionEntry.COLUMN_CREATED_AT     + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, "
                    + ScheduledActionEntry.COLUMN_MODIFIED_AT    + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP "
                    + ");" + DatabaseHelper.createUpdatedAtTrigger(ScheduledActionEntry.TABLE_NAME));


            //==============================BEGIN TABLE MIGRATIONS ========================================
            Log.i(DatabaseHelper.LOG_TAG, "Migrating accounts table");
            // backup transaction table
            db.execSQL("ALTER TABLE " + AccountEntry.TABLE_NAME + " RENAME TO " + AccountEntry.TABLE_NAME + "_bak");
            // create new transaction table
            db.execSQL("CREATE TABLE " + AccountEntry.TABLE_NAME + " ("
                    + AccountEntry._ID + " integer primary key autoincrement, "
                    + AccountEntry.COLUMN_UID + " varchar(255) not null UNIQUE, "
                    + AccountEntry.COLUMN_NAME + " varchar(255) not null, "
                    + AccountEntry.COLUMN_TYPE + " varchar(255) not null, "
                    + AccountEntry.COLUMN_CURRENCY + " varchar(255) not null, "
                    + AccountEntry.COLUMN_DESCRIPTION + " varchar(255), "
                    + AccountEntry.COLUMN_COLOR_CODE + " varchar(255), "
                    + AccountEntry.COLUMN_FAVORITE + " tinyint default 0, "
                    + AccountEntry.COLUMN_HIDDEN + " tinyint default 0, "
                    + AccountEntry.COLUMN_FULL_NAME + " varchar(255), "
                    + AccountEntry.COLUMN_PLACEHOLDER + " tinyint default 0, "
                    + AccountEntry.COLUMN_PARENT_ACCOUNT_UID + " varchar(255), "
                    + AccountEntry.COLUMN_DEFAULT_TRANSFER_ACCOUNT_UID + " varchar(255), "
                    + AccountEntry.COLUMN_CREATED_AT + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, "
                    + AccountEntry.COLUMN_MODIFIED_AT + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP "
                    + ");" + DatabaseHelper.createUpdatedAtTrigger(AccountEntry.TABLE_NAME));

            // initialize new account table with data from old table
            db.execSQL("INSERT INTO " + AccountEntry.TABLE_NAME + " ( "
                            + AccountEntry._ID + ","
                            + AccountEntry.COLUMN_UID + " , "
                            + AccountEntry.COLUMN_NAME + " , "
                            + AccountEntry.COLUMN_TYPE + " , "
                            + AccountEntry.COLUMN_CURRENCY + " , "
                            + AccountEntry.COLUMN_COLOR_CODE + " , "
                            + AccountEntry.COLUMN_FAVORITE + " , "
                            + AccountEntry.COLUMN_FULL_NAME + " , "
                            + AccountEntry.COLUMN_PLACEHOLDER + " , "
                            + AccountEntry.COLUMN_HIDDEN + " , "
                            + AccountEntry.COLUMN_PARENT_ACCOUNT_UID + " , "
                            + AccountEntry.COLUMN_DEFAULT_TRANSFER_ACCOUNT_UID
                            + ") SELECT "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry._ID + " , "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry.COLUMN_UID + " , "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry.COLUMN_NAME + " , "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry.COLUMN_TYPE + " , "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry.COLUMN_CURRENCY + " , "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry.COLUMN_COLOR_CODE + " , "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry.COLUMN_FAVORITE + " , "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry.COLUMN_FULL_NAME + " , "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry.COLUMN_PLACEHOLDER + " , "
                            + " CASE WHEN " + AccountEntry.TABLE_NAME + "_bak.type = 'ROOT' THEN 1 ELSE 0 END, "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry.COLUMN_PARENT_ACCOUNT_UID + " , "
                            + AccountEntry.TABLE_NAME + "_bak." + AccountEntry.COLUMN_DEFAULT_TRANSFER_ACCOUNT_UID
                            + " FROM " + AccountEntry.TABLE_NAME + "_bak;"
            );

            Log.i(DatabaseHelper.LOG_TAG, "Migrating transactions table");
            // backup transaction table
            db.execSQL("ALTER TABLE " + TransactionEntry.TABLE_NAME + " RENAME TO " + TransactionEntry.TABLE_NAME + "_bak");
            // create new transaction table
            db.execSQL("CREATE TABLE " + TransactionEntry.TABLE_NAME + " ("
                    + TransactionEntry._ID + " integer primary key autoincrement, "
                    + TransactionEntry.COLUMN_UID + " varchar(255) not null UNIQUE, "
                    + TransactionEntry.COLUMN_DESCRIPTION + " varchar(255), "
                    + TransactionEntry.COLUMN_NOTES + " text, "
                    + TransactionEntry.COLUMN_TIMESTAMP + " integer not null, "
                    + TransactionEntry.COLUMN_EXPORTED + " tinyint default 0, "
                    + TransactionEntry.COLUMN_TEMPLATE + " tinyint default 0, "
                    + TransactionEntry.COLUMN_CURRENCY + " varchar(255) not null, "
                    + TransactionEntry.COLUMN_SCHEDX_ACTION_UID + " varchar(255), "
                    + TransactionEntry.COLUMN_CREATED_AT + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, "
                    + TransactionEntry.COLUMN_MODIFIED_AT + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, "
                    + "FOREIGN KEY (" + TransactionEntry.COLUMN_SCHEDX_ACTION_UID + ") REFERENCES " + ScheduledActionEntry.TABLE_NAME + " (" + ScheduledActionEntry.COLUMN_UID + ") ON DELETE SET NULL "
                    + ");" + DatabaseHelper.createUpdatedAtTrigger(TransactionEntry.TABLE_NAME));

            // initialize new transaction table with data from old table
            db.execSQL("INSERT INTO " + TransactionEntry.TABLE_NAME + " ( "
                            + TransactionEntry._ID + " , "
                            + TransactionEntry.COLUMN_UID + " , "
                            + TransactionEntry.COLUMN_DESCRIPTION + " , "
                            + TransactionEntry.COLUMN_NOTES + " , "
                            + TransactionEntry.COLUMN_TIMESTAMP + " , "
                            + TransactionEntry.COLUMN_EXPORTED + " , "
                            + TransactionEntry.COLUMN_CURRENCY + " , "
                            + TransactionEntry.COLUMN_TEMPLATE
                            + ")  SELECT "
                            + TransactionEntry.TABLE_NAME + "_bak." + TransactionEntry._ID + " , "
                            + TransactionEntry.TABLE_NAME + "_bak." + TransactionEntry.COLUMN_UID + " , "
                            + TransactionEntry.TABLE_NAME + "_bak." + TransactionEntry.COLUMN_DESCRIPTION + " , "
                            + TransactionEntry.TABLE_NAME + "_bak." + TransactionEntry.COLUMN_NOTES + " , "
                            + TransactionEntry.TABLE_NAME + "_bak." + TransactionEntry.COLUMN_TIMESTAMP + " , "
                            + TransactionEntry.TABLE_NAME + "_bak." + TransactionEntry.COLUMN_EXPORTED + " , "
                            + TransactionEntry.TABLE_NAME + "_bak." + TransactionEntry.COLUMN_CURRENCY + " , "
                            + " CASE WHEN " + TransactionEntry.TABLE_NAME + "_bak.recurrence_period > 0 THEN 1 ELSE 0 END "
                            + " FROM " + TransactionEntry.TABLE_NAME + "_bak;"
            );

            Log.i(DatabaseHelper.LOG_TAG, "Migrating splits table");
            // backup split table
            db.execSQL("ALTER TABLE " + SplitEntry.TABLE_NAME + " RENAME TO " + SplitEntry.TABLE_NAME + "_bak");
            // create new split table
            db.execSQL("CREATE TABLE " + SplitEntry.TABLE_NAME + " ("
                    + SplitEntry._ID + " integer primary key autoincrement, "
                    + SplitEntry.COLUMN_UID + " varchar(255) not null UNIQUE, "
                    + SplitEntry.COLUMN_MEMO + " text, "
                    + SplitEntry.COLUMN_TYPE + " varchar(255) not null, "
                    + "amount" + " varchar(255) not null, "
                    + SplitEntry.COLUMN_ACCOUNT_UID + " varchar(255) not null, "
                    + SplitEntry.COLUMN_TRANSACTION_UID + " varchar(255) not null, "
                    + SplitEntry.COLUMN_CREATED_AT + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, "
                    + SplitEntry.COLUMN_MODIFIED_AT + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, "
                    + "FOREIGN KEY (" + SplitEntry.COLUMN_ACCOUNT_UID + ") REFERENCES " + AccountEntry.TABLE_NAME + " (" + AccountEntry.COLUMN_UID + ") ON DELETE CASCADE, "
                    + "FOREIGN KEY (" + SplitEntry.COLUMN_TRANSACTION_UID + ") REFERENCES " + TransactionEntry.TABLE_NAME + " (" + TransactionEntry.COLUMN_UID + ") ON DELETE CASCADE "
                    + ");" + DatabaseHelper.createUpdatedAtTrigger(SplitEntry.TABLE_NAME));

            // initialize new split table with data from old table
            db.execSQL("INSERT INTO " + SplitEntry.TABLE_NAME + " ( "
                            + SplitEntry._ID + " , "
                            + SplitEntry.COLUMN_UID + " , "
                            + SplitEntry.COLUMN_MEMO + " , "
                            + SplitEntry.COLUMN_TYPE + " , "
                            + "amount" + " , "
                            + SplitEntry.COLUMN_ACCOUNT_UID + " , "
                            + SplitEntry.COLUMN_TRANSACTION_UID
                            + ")  SELECT "
                            + SplitEntry.TABLE_NAME + "_bak." + SplitEntry._ID + " , "
                            + SplitEntry.TABLE_NAME + "_bak." + SplitEntry.COLUMN_UID + " , "
                            + SplitEntry.TABLE_NAME + "_bak." + SplitEntry.COLUMN_MEMO + " , "
                            + SplitEntry.TABLE_NAME + "_bak." + SplitEntry.COLUMN_TYPE + " , "
                            + SplitEntry.TABLE_NAME + "_bak." + "amount" + " , "
                            + SplitEntry.TABLE_NAME + "_bak." + SplitEntry.COLUMN_ACCOUNT_UID + " , "
                            + SplitEntry.TABLE_NAME + "_bak." + SplitEntry.COLUMN_TRANSACTION_UID
                            + " FROM " + SplitEntry.TABLE_NAME + "_bak;"
            );



            //================================ END TABLE MIGRATIONS ================================

            // String timestamp to be used for all new created entities in migration
            String timestamp = TimestampHelper.getUtcStringFromTimestamp(TimestampHelper.getTimestampFromNow());

            //ScheduledActionDbAdapter scheduledActionDbAdapter = new ScheduledActionDbAdapter(db);
            //SplitsDbAdapter splitsDbAdapter = new SplitsDbAdapter(db);
            //TransactionsDbAdapter transactionsDbAdapter = new TransactionsDbAdapter(db, splitsDbAdapter);
            //AccountsDbAdapter accountsDbAdapter = new AccountsDbAdapter(db,transactionsDbAdapter);

            Log.i(DatabaseHelper.LOG_TAG, "Creating default root account if none exists");
            ContentValues contentValues = new ContentValues();
            //assign a root account to all accounts which had null as parent except ROOT (top-level accounts)
            String rootAccountUID;
            Cursor cursor = db.<mark>query</mark>(AccountEntry.TABLE_NAME,
                    new String[]{AccountEntry.COLUMN_UID},
                    AccountEntry.COLUMN_TYPE + "= ?",
                    new String[]{AccountType.ROOT.name()}, null, null, null);
            try {
                if (cursor.moveToFirst()) {
                    rootAccountUID = cursor.getString(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_UID));
                }
                else
                {
                    rootAccountUID = BaseModel.generateUID();
                    contentValues.clear();
                    contentValues.put(CommonColumns.COLUMN_UID, rootAccountUID);
                    contentValues.put(CommonColumns.COLUMN_CREATED_AT, timestamp);
                    contentValues.put(AccountEntry.COLUMN_NAME,         "ROOT");
                    contentValues.put(AccountEntry.COLUMN_TYPE,         "ROOT");
                    contentValues.put(AccountEntry.COLUMN_CURRENCY,     Money.DEFAULT_CURRENCY_CODE);
                    contentValues.put(AccountEntry.COLUMN_PLACEHOLDER,  0);
                    contentValues.put(AccountEntry.COLUMN_HIDDEN,       1);
                    contentValues.putNull(AccountEntry.COLUMN_COLOR_CODE);
                    contentValues.put(AccountEntry.COLUMN_FAVORITE, 0);
                    contentValues.put(AccountEntry.COLUMN_FULL_NAME,    " ");
                    contentValues.putNull(AccountEntry.COLUMN_PARENT_ACCOUNT_UID);
                    contentValues.putNull(AccountEntry.COLUMN_DEFAULT_TRANSFER_ACCOUNT_UID);
                    db.<mark>insert</mark>(AccountEntry.TABLE_NAME, null, contentValues);
                }
            } finally {
                cursor.close();
            }
            //String rootAccountUID = accountsDbAdapter.getOrCreateGnuCashRootAccountUID();
            contentValues.clear();
            contentValues.put(AccountEntry.COLUMN_PARENT_ACCOUNT_UID, rootAccountUID);
            db.update(AccountEntry.TABLE_NAME, contentValues, AccountEntry.COLUMN_PARENT_ACCOUNT_UID + " IS NULL AND " + AccountEntry.COLUMN_TYPE + " != ?", new String[]{"ROOT"});

            Log.i(DatabaseHelper.LOG_TAG, "Migrating existing recurring transactions");
            cursor = db.<mark>query</mark>(TransactionEntry.TABLE_NAME + "_bak", null, "recurrence_period > 0", null, null, null, null);
            long lastRun = System.currentTimeMillis();
            while (cursor.moveToNext()){
                contentValues.clear();
                Timestamp timestampT = new Timestamp(cursor.getLong(cursor.getColumnIndexOrThrow(TransactionEntry.COLUMN_TIMESTAMP)));
                contentValues.put(TransactionEntry.COLUMN_CREATED_AT, TimestampHelper.getUtcStringFromTimestamp(timestampT));
                long transactionId = cursor.getLong(cursor.getColumnIndexOrThrow(TransactionEntry._ID));
                db.update(TransactionEntry.TABLE_NAME, contentValues, TransactionEntry._ID + "=" + transactionId, null);

                //ScheduledAction scheduledAction = new ScheduledAction(ScheduledAction.ActionType.TRANSACTION);
                //scheduledAction.setActionUID(cursor.getString(cursor.getColumnIndexOrThrow(TransactionEntry.COLUMN_UID)));
                //long period = cursor.getLong(cursor.getColumnIndexOrThrow("recurrence_period"));
                //scheduledAction.setPeriod(period);
                //scheduledAction.setStartTime(timestampT.getTime()); //the start time is when the transaction was created
                //scheduledAction.setLastRun(System.currentTimeMillis()); //prevent this from being executed at the end of migration

                contentValues.clear();
                contentValues.put(CommonColumns.COLUMN_UID, BaseModel.generateUID());
                contentValues.put(CommonColumns.COLUMN_CREATED_AT, timestamp);
                contentValues.put(ScheduledActionEntry.COLUMN_ACTION_UID, cursor.getString(cursor.getColumnIndexOrThrow(TransactionEntry.COLUMN_UID)));
                contentValues.put("period", cursor.getLong(cursor.getColumnIndexOrThrow("recurrence_period")));
                contentValues.put(ScheduledActionEntry.COLUMN_START_TIME, timestampT.getTime());
                contentValues.put(ScheduledActionEntry.COLUMN_END_TIME, 0);
                contentValues.put(ScheduledActionEntry.COLUMN_LAST_RUN, lastRun);
                contentValues.put(ScheduledActionEntry.COLUMN_TYPE, "TRANSACTION");
                contentValues.put(ScheduledActionEntry.COLUMN_TAG, "");
                contentValues.put(ScheduledActionEntry.COLUMN_ENABLED, 1);
                contentValues.put(ScheduledActionEntry.COLUMN_TOTAL_FREQUENCY, 0);
                contentValues.put(ScheduledActionEntry.COLUMN_EXECUTION_COUNT, 0);
                //scheduledActionDbAdapter.addRecord(scheduledAction);
                db.<mark>insert</mark>(ScheduledActionEntry.TABLE_NAME, null, contentValues);

                //build intent for recurring transactions in the database
                Intent intent = new Intent(Intent.ACTION_INSERT);
                intent.setType(Transaction.MIME_TYPE);

                //cancel existing pending intent
                Context context = GnuCashApplication.getAppContext();
                PendingIntent recurringPendingIntent = PendingIntent.getBroadcast(context,
                        (int)transactionId, intent, PendingIntent.FLAG_CANCEL_CURRENT);
                AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
                alarmManager.cancel(recurringPendingIntent);
            }
            cursor.close();

            //auto-balance existing splits
            Log.i(DatabaseHelper.LOG_TAG, "Auto-balancing existing transaction splits");
            cursor = db.<mark>query</mark>(
                    TransactionEntry.TABLE_NAME + " , " + SplitEntry.TABLE_NAME + " ON "
                            + TransactionEntry.TABLE_NAME + "." + TransactionEntry.COLUMN_UID + "=" + SplitEntry.TABLE_NAME + "." + SplitEntry.COLUMN_TRANSACTION_UID
                            + " , " + AccountEntry.TABLE_NAME + " ON "
                            + SplitEntry.TABLE_NAME + "." + SplitEntry.COLUMN_ACCOUNT_UID + "=" + AccountEntry.TABLE_NAME + "." + AccountEntry.COLUMN_UID,
                    new String[]{
                            TransactionEntry.TABLE_NAME + "." + TransactionEntry.COLUMN_UID + " AS trans_uid",
                            TransactionEntry.TABLE_NAME + "." + TransactionEntry.COLUMN_CURRENCY + " AS trans_currency",
                            "TOTAL ( CASE WHEN " +
                                    SplitEntry.TABLE_NAME + "." + SplitEntry.COLUMN_TYPE + " = 'DEBIT' THEN " +
                                    SplitEntry.TABLE_NAME + "." + "amount" + " ELSE - " +
                                    SplitEntry.TABLE_NAME + "." + "amount" + " END ) AS trans_acct_balance",
                            "COUNT ( DISTINCT " +
                                    AccountEntry.TABLE_NAME + "." + AccountEntry.COLUMN_CURRENCY +
                                    " ) AS trans_currency_count"
                    },
                    TransactionEntry.TABLE_NAME + "." + TransactionEntry.COLUMN_TEMPLATE + " == 0",
                    null,
                    TransactionEntry.TABLE_NAME + "." + TransactionEntry.COLUMN_UID,
                    "trans_acct_balance != 0 AND trans_currency_count = 1",
                    null);
            try {
                while (cursor.moveToNext()){
                    double imbalance = cursor.getDouble(cursor.getColumnIndexOrThrow("trans_acct_balance"));
                    BigDecimal decimalImbalance = BigDecimal.valueOf(imbalance).setScale(2, BigDecimal.ROUND_HALF_UP);
                    if (decimalImbalance.compareTo(BigDecimal.ZERO) != 0) {
                        String currencyCode = cursor.getString(cursor.getColumnIndexOrThrow("trans_currency"));
                        String imbalanceAccountName = GnuCashApplication.getAppContext().getString(R.string.imbalance_account_name) + "-" + currencyCode;
                        String imbalanceAccountUID;
                        Cursor c = db.<mark>query</mark>(AccountEntry.TABLE_NAME, new String[]{AccountEntry.COLUMN_UID},
                                AccountEntry.COLUMN_FULL_NAME + "= ?", new String[]{imbalanceAccountName},
                                null, null, null);
                        try {
                            if (c.moveToFirst()) {
                                imbalanceAccountUID = c.getString(c.getColumnIndexOrThrow(AccountEntry.COLUMN_UID));
                            }
                            else {
                                imbalanceAccountUID = BaseModel.generateUID();
                                contentValues.clear();
                                contentValues.put(CommonColumns.COLUMN_UID, imbalanceAccountUID);
                                contentValues.put(CommonColumns.COLUMN_CREATED_AT, timestamp);
                                contentValues.put(AccountEntry.COLUMN_NAME,         imbalanceAccountName);
                                contentValues.put(AccountEntry.COLUMN_TYPE,         "BANK");
                                contentValues.put(AccountEntry.COLUMN_CURRENCY,     currencyCode);
                                contentValues.put(AccountEntry.COLUMN_PLACEHOLDER,  0);
                                contentValues.put(AccountEntry.COLUMN_HIDDEN,       GnuCashApplication.isDoubleEntryEnabled() ? 0 : 1);
                                contentValues.putNull(AccountEntry.COLUMN_COLOR_CODE);
                                contentValues.put(AccountEntry.COLUMN_FAVORITE, 0);
                                contentValues.put(AccountEntry.COLUMN_FULL_NAME,    imbalanceAccountName);
                                contentValues.put(AccountEntry.COLUMN_PARENT_ACCOUNT_UID, rootAccountUID);
                                contentValues.putNull(AccountEntry.COLUMN_DEFAULT_TRANSFER_ACCOUNT_UID);
                                db.<mark>insert</mark>(AccountEntry.TABLE_NAME, null, contentValues);
                            }
                        } finally {
                            c.close();
                        }
                        String TransactionUID = cursor.getString(cursor.getColumnIndexOrThrow("trans_uid"));
                        contentValues.clear();
                        contentValues.put(CommonColumns.COLUMN_UID, BaseModel.generateUID());
                        contentValues.put(CommonColumns.COLUMN_CREATED_AT, timestamp);
                        contentValues.put("amount",     decimalImbalance.abs().toPlainString());
                        contentValues.put(SplitEntry.COLUMN_TYPE,       decimalImbalance.compareTo(BigDecimal.ZERO) < 0 ? "DEBIT" : "CREDIT");
                        contentValues.put(SplitEntry.COLUMN_MEMO,       "");
                        contentValues.put(SplitEntry.COLUMN_ACCOUNT_UID, imbalanceAccountUID);
                        contentValues.put(SplitEntry.COLUMN_TRANSACTION_UID, TransactionUID);
                        db.<mark>insert</mark>(SplitEntry.TABLE_NAME, null, contentValues);
                        contentValues.clear();
                        contentValues.put(TransactionEntry.COLUMN_MODIFIED_AT, timestamp);
                        db.update(TransactionEntry.TABLE_NAME, contentValues, TransactionEntry.COLUMN_UID + " == ?",
                                new String[]{TransactionUID});
                    }
                }
            } finally {
                cursor.close();
            }

            Log.i(DatabaseHelper.LOG_TAG, "Dropping temporary migration tables");
            db.execSQL("DROP TABLE " + SplitEntry.TABLE_NAME + "_bak");
            db.execSQL("DROP TABLE " + AccountEntry.TABLE_NAME + "_bak");
            db.execSQL("DROP TABLE " + TransactionEntry.TABLE_NAME + "_bak");

            db.<mark>setTransactionSuccessful</mark>();
            oldVersion = 8;
        } finally {
            db.<mark>endTransaction</mark>();
        }

        GnuCashApplication.startScheduledActionExecutionService(GnuCashApplication.getAppContext());

        return oldVersion;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>hushnymous_____android_frameworks_base_____DatabaseHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/hushnymous_____android_frameworks_base_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) {
        Log.w(TAG, "Upgrading settings database from version " + oldVersion + " to "
                + currentVersion);

        int upgradeVersion = oldVersion;

        // Pattern for upgrade blocks:
        //
        //    if (upgradeVersion == [the DATABASE_VERSION you set] - 1) {
        //        .. your upgrade logic..
        //        upgradeVersion = [the DATABASE_VERSION you set]
        //    }

        if (upgradeVersion == 20) {
            /*
             * Version 21 is part of the volume control refresh. There is no
             * longer a UI-visible for setting notification vibrate on/off (in
             * our design), but the functionality still exists. Force the
             * notification vibrate to on.
             */
            loadVibrateSetting(db, true);

            upgradeVersion = 21;
        }

        if (upgradeVersion < 22) {
            upgradeVersion = 22;
            // Upgrade the lock gesture storage location and format
            upgradeLockPatternLocation(db);
        }

        if (upgradeVersion < 23) {
            db.execSQL("UPDATE favorites SET iconResource=0 WHERE iconType=0");
            upgradeVersion = 23;
        }

        if (upgradeVersion == 23) {
            db.beginTransaction();
            try {
                db.execSQL("ALTER TABLE favorites ADD spanX INTEGER");
                db.execSQL("ALTER TABLE favorites ADD spanY INTEGER");
                // Shortcuts, applications, folders
                db.execSQL("UPDATE favorites SET spanX=1, spanY=1 WHERE itemType<=0");
                // Photo frames, clocks
                db.execSQL(
                    "UPDATE favorites SET spanX=2, spanY=2 WHERE itemType=1000 or itemType=1002");
                // Search boxes
                db.execSQL("UPDATE favorites SET spanX=4, spanY=1 WHERE itemType=1001");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 24;
        }

        if (upgradeVersion == 24) {
            db.beginTransaction();
            try {
                // The value of the constants for preferring wifi or preferring mobile have been
                // swapped, so reload the default.
                db.execSQL("DELETE FROM system WHERE name='network_preference'");
                db.execSQL("INSERT INTO system ('name', 'value') values ('network_preference', '" +
                        ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + "')");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 25;
        }

        if (upgradeVersion == 25) {
            db.beginTransaction();
            try {
                db.execSQL("ALTER TABLE favorites ADD uri TEXT");
                db.execSQL("ALTER TABLE favorites ADD displayMode INTEGER");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 26;
        }

        if (upgradeVersion == 26) {
            // This introduces the new secure settings table.
            db.beginTransaction();
            try {
                createSecureTable(db);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 27;
        }

        if (upgradeVersion == 27) {
            String[] settingsToMove = {
                    Settings.Secure.ADB_ENABLED,
                    Settings.Secure.ANDROID_ID,
                    Settings.Secure.BLUETOOTH_ON,
                    Settings.Secure.DATA_ROAMING,
                    Settings.Secure.DEVICE_PROVISIONED,
                    Settings.Secure.HTTP_PROXY,
                    Settings.Secure.INSTALL_NON_MARKET_APPS,
                    Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
                    Settings.Secure.LOGGING_ID,
                    Settings.Secure.NETWORK_PREFERENCE,
                    Settings.Secure.PARENTAL_CONTROL_ENABLED,
                    Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,
                    Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,
                    Settings.Secure.SETTINGS_CLASSNAME,
                    Settings.Secure.USB_MASS_STORAGE_ENABLED,
                    Settings.Secure.USE_GOOGLE_MAIL,
                    Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
                    Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
                    Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,
                    Settings.Secure.WIFI_ON,
                    Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,
                    Settings.Secure.WIFI_WATCHDOG_AP_COUNT,
                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,
                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,
                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,
                    Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,
                    Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,
                    Settings.Secure.WIFI_WATCHDOG_ON,
                    Settings.Secure.WIFI_WATCHDOG_PING_COUNT,
                    Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,
                    Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS,
                };
            moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
            upgradeVersion = 28;
        }

        if (upgradeVersion == 28 || upgradeVersion == 29) {
            // Note: The upgrade to 28 was flawed since it didn't delete the old
            // setting first before inserting. Combining 28 and 29 with the
            // fixed version.

            // This upgrade adds the STREAM_NOTIFICATION type to the list of
            // types affected by ringer modes (silent, vibrate, etc.)
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
                int newValue = (1 << AudioManager.STREAM_RING)
                        | (1 << AudioManager.STREAM_NOTIFICATION)
                        | (1 << AudioManager.STREAM_SYSTEM);
                db.execSQL("INSERT INTO system ('name', 'value') values ('"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
                        + String.valueOf(newValue) + "')");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }

            upgradeVersion = 30;
        }

        if (upgradeVersion == 30) {
            /*
             * Upgrade 31 clears the title for all quick launch shortcuts so the
             * activities' titles will be resolved at display time. Also, the
             * folder is changed to '@quicklaunch'.
             */
            db.beginTransaction();
            try {
                db.execSQL("UPDATE bookmarks SET folder = '@quicklaunch'");
                db.execSQL("UPDATE bookmarks SET title = ''");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 31;
        }

        if (upgradeVersion == 31) {
            /*
             * Animations are now managed in preferences, and may be
             * enabled or disabled based on product resources.
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadDefaultAnimationSettings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 32;
        }

        if (upgradeVersion == 32) {
            // The Wi-Fi watchdog SSID list is now seeded with the value of
            // the property ro.com.android.wifi-watchlist
            String wifiWatchList = SystemProperties.get("ro.com.android.wifi-watchlist");
            if (!TextUtils.isEmpty(wifiWatchList)) {
                db.beginTransaction();
                try {
                    db.execSQL("INSERT OR IGNORE INTO secure(name,value) values('" +
                            Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + "','" +
                            wifiWatchList + "');");
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 33;
        }

        if (upgradeVersion == 33) {
            // Set the default zoom controls to: tap-twice to bring up +/-
            db.beginTransaction();
            try {
                db.execSQL("INSERT INTO system(name,value) values('zoom','2');");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 34;
        }

        if (upgradeVersion == 34) {
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadSecure35Settings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 35;
        }
            // due to a botched merge from donut to eclair, the initialization of ASSISTED_GPS_ENABLED
            // was accidentally done out of order here.
            // to fix this, ASSISTED_GPS_ENABLED is now initialized while upgrading from 38 to 39,
            // and we intentionally do nothing from 35 to 36 now.
        if (upgradeVersion == 35) {
            upgradeVersion = 36;
        }

        if (upgradeVersion == 36) {
           // This upgrade adds the STREAM_SYSTEM_ENFORCED type to the list of
            // types affected by ringer modes (silent, vibrate, etc.)
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
                int newValue = (1 << AudioManager.STREAM_RING)
                        | (1 << AudioManager.STREAM_NOTIFICATION)
                        | (1 << AudioManager.STREAM_SYSTEM)
                        | (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
                db.execSQL("INSERT INTO system ('name', 'value') values ('"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
                        + String.valueOf(newValue) + "')");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 37;
        }

        if (upgradeVersion == 37) {
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
                        + " VALUES(?,?);");
                loadStringSetting(stmt, Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,
                        R.string.airplane_mode_toggleable_radios);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 38;
        }

        if (upgradeVersion == 38) {
            db.beginTransaction();
            try {
                String value =
                        mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? "1" : "0";
                db.execSQL("INSERT OR IGNORE INTO secure(name,value) values('" +
                        Settings.Global.ASSISTED_GPS_ENABLED + "','" + value + "');");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }

            upgradeVersion = 39;
        }

        if (upgradeVersion == 39) {
            upgradeAutoBrightness(db);
            upgradeVersion = 40;
        }

        if (upgradeVersion == 40) {
            /*
             * All animations are now turned on by default!
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadDefaultAnimationSettings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 41;
        }

        if (upgradeVersion == 41) {
            /*
             * Initialize newly public haptic feedback setting
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.HAPTIC_FEEDBACK_ENABLED + "'");
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadDefaultHapticSettings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 42;
        }

        if (upgradeVersion == 42) {
            /*
             * Initialize new notification pulse setting
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.System.NOTIFICATION_LIGHT_PULSE,
                        R.bool.def_notification_pulse);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 43;
        }

        if (upgradeVersion == 43) {
            /*
             * This upgrade stores bluetooth volume separately from voice volume
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
                        + " VALUES(?,?);");
                loadSetting(stmt, Settings.System.VOLUME_BLUETOOTH_SCO,
                        AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 44;
        }

        if (upgradeVersion == 44) {
            /*
             * Gservices was moved into vendor/google.
             */
            db.execSQL("DROP TABLE IF EXISTS gservices");
            db.execSQL("DROP INDEX IF EXISTS gservicesIndex1");
            upgradeVersion = 45;
        }

        if (upgradeVersion == 45) {
             /*
              * New settings for MountService
              */
            db.beginTransaction();
            try {
                db.execSQL("INSERT INTO secure(name,value) values('" +
                        Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + "','1');");
                db.execSQL("INSERT INTO secure(name,value) values('" +
                        Settings.Secure.MOUNT_UMS_AUTOSTART + "','0');");
                db.execSQL("INSERT INTO secure(name,value) values('" +
                        Settings.Secure.MOUNT_UMS_PROMPT + "','1');");
                db.execSQL("INSERT INTO secure(name,value) values('" +
                        Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + "','1');");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 46;
        }

        if (upgradeVersion == 46) {
            /*
             * The password mode constants have changed; reset back to no
             * password.
             */
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='lockscreen.password_type';");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
           upgradeVersion = 47;
       }


        if (upgradeVersion == 47) {
            /*
             * The password mode constants have changed again; reset back to no
             * password.
             */
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='lockscreen.password_type';");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
           upgradeVersion = 48;
       }

       if (upgradeVersion == 48) {
           /*
            * Default recognition service no longer initialized here,
            * moved to RecognitionManagerService.
            */
           upgradeVersion = 49;
       }

       if (upgradeVersion == 49) {
           /*
            * New settings for new user interface noises.
            */
           db.beginTransaction();
           SQLiteStatement stmt = null;
           try {
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadUISoundEffectsSettings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }

           upgradeVersion = 50;
       }

       if (upgradeVersion == 50) {
           /*
            * Install location no longer initiated here.
            */
           upgradeVersion = 51;
       }

       if (upgradeVersion == 51) {
           /* Move the lockscreen related settings to Secure, including some private ones. */
           String[] settingsToMove = {
                   Secure.LOCK_PATTERN_ENABLED,
                   Secure.LOCK_PATTERN_VISIBLE,
                   Secure.LOCK_SHOW_ERROR_PATH,
                   Secure.LOCK_DOTS_VISIBLE,
                   Secure.LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED,
                   "lockscreen.password_type",
                   "lockscreen.lockoutattemptdeadline",
                   "lockscreen.patterneverchosen",
                   "lock_pattern_autolock",
                   "lockscreen.lockedoutpermanently",
                   "lockscreen.password_salt"
           };
           moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
           upgradeVersion = 52;
       }

        if (upgradeVersion == 52) {
            // new vibration/silent mode settings
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.System.VIBRATE_IN_SILENT,
                        R.bool.def_vibrate_in_silent);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }

            upgradeVersion = 53;
        }

        if (upgradeVersion == 53) {
            /*
             * New settings for set install location UI no longer initiated here.
             */
            upgradeVersion = 54;
        }

        if (upgradeVersion == 54) {
            /*
             * Update the screen timeout value if set to never
             */
            db.beginTransaction();
            try {
                upgradeScreenTimeoutFromNever(db);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }

            upgradeVersion = 55;
        }

        if (upgradeVersion == 55) {
            /* Move the install location settings. */
            String[] settingsToMove = {
                    Global.SET_INSTALL_LOCATION,
                    Global.DEFAULT_INSTALL_LOCATION
            };
            moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadSetting(stmt, Global.SET_INSTALL_LOCATION, 0);
                loadSetting(stmt, Global.DEFAULT_INSTALL_LOCATION,
                        PackageHelper.APP_INSTALL_AUTO);
                db.setTransactionSuccessful();
             } finally {
                 db.endTransaction();
                 if (stmt != null) stmt.close();
             }
            upgradeVersion = 56;
        }

        if (upgradeVersion == 56) {
            /*
             * Add Bluetooth to list of toggleable radios in airplane mode
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS + "'");
                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
                        + " VALUES(?,?);");
                loadStringSetting(stmt, Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,
                        R.string.airplane_mode_toggleable_radios);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 57;
        }

        /************* The following are Honeycomb changes ************/

        if (upgradeVersion == 57) {
            /*
             * New settings to:
             *  1. Enable injection of accessibility scripts in WebViews.
             *  2. Define the key bindings for traversing web content in WebViews.
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SCRIPT_INJECTION,
                        R.bool.def_accessibility_script_injection);
                stmt.close();
                stmt = db.compileStatement("INSERT INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_WEB_CONTENT_KEY_BINDINGS,
                        R.string.def_accessibility_web_content_key_bindings);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 58;
        }

        if (upgradeVersion == 58) {
            /* Add default for new Auto Time Zone */
            int autoTimeValue = getIntValueFromSystem(db, Settings.System.AUTO_TIME, 0);
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO system(name,value)" + " VALUES(?,?);");
                loadSetting(stmt, Settings.System.AUTO_TIME_ZONE,
                        autoTimeValue); // Sync timezone to NITZ if auto_time was enabled
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 59;
        }

        if (upgradeVersion == 59) {
            // Persistence for the rotation lock feature.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.System.USER_ROTATION,
                        R.integer.def_user_rotation); // should be zero degrees
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 60;
        }

        if (upgradeVersion == 60) {
            // Don't do this for upgrades from Gingerbread
            // Were only required for intra-Honeycomb upgrades for testing
            // upgradeScreenTimeout(db);
            upgradeVersion = 61;
        }

        if (upgradeVersion == 61) {
            // Don't do this for upgrades from Gingerbread
            // Were only required for intra-Honeycomb upgrades for testing
            // upgradeScreenTimeout(db);
            upgradeVersion = 62;
        }

        // Change the default for screen auto-brightness mode
        if (upgradeVersion == 62) {
            // Don't do this for upgrades from Gingerbread
            // Were only required for intra-Honeycomb upgrades for testing
            // upgradeAutoBrightness(db);
            upgradeVersion = 63;
        }

        if (upgradeVersion == 63) {
            // This upgrade adds the STREAM_MUSIC type to the list of
             // types affected by ringer modes (silent, vibrate, etc.)
             db.beginTransaction();
             try {
                 db.execSQL("DELETE FROM system WHERE name='"
                         + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
                 int newValue = (1 << AudioManager.STREAM_RING)
                         | (1 << AudioManager.STREAM_NOTIFICATION)
                         | (1 << AudioManager.STREAM_SYSTEM)
                         | (1 << AudioManager.STREAM_SYSTEM_ENFORCED)
                         | (1 << AudioManager.STREAM_MUSIC);
                 db.execSQL("INSERT INTO system ('name', 'value') values ('"
                         + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
                         + String.valueOf(newValue) + "')");
                 db.setTransactionSuccessful();
             } finally {
                 db.endTransaction();
             }
             upgradeVersion = 64;
         }

        if (upgradeVersion == 64) {
            // New setting to configure the long press timeout.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadIntegerSetting(stmt, Settings.Secure.LONG_PRESS_TIMEOUT,
                        R.integer.def_long_press_timeout_millis);
                stmt.close();
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 65;
        }

        /************* The following are Ice Cream Sandwich changes ************/

        if (upgradeVersion == 65) {
            /*
             * Animations are removed from Settings. Turned on by default
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadDefaultAnimationSettings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 66;
        }

        if (upgradeVersion == 66) {
            // This upgrade makes sure that MODE_RINGER_STREAMS_AFFECTED is set
            // according to device voice capability
            db.beginTransaction();
            try {
                int ringerModeAffectedStreams = (1 << AudioManager.STREAM_RING) |
                                                (1 << AudioManager.STREAM_NOTIFICATION) |
                                                (1 << AudioManager.STREAM_SYSTEM) |
                                                (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
                if (!mContext.getResources().getBoolean(
                        com.android.internal.R.bool.config_voice_capable)) {
                    ringerModeAffectedStreams |= (1 << AudioManager.STREAM_MUSIC);
                }
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
                db.execSQL("INSERT INTO system ('name', 'value') values ('"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
                        + String.valueOf(ringerModeAffectedStreams) + "')");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 67;
        }

        if (upgradeVersion == 67) {
            // New setting to enable touch exploration.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.Secure.TOUCH_EXPLORATION_ENABLED,
                        R.bool.def_touch_exploration_enabled);
                stmt.close();
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 68;
        }

        if (upgradeVersion == 68) {
            // Enable all system sounds by default
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.NOTIFICATIONS_USE_RING_VOLUME + "'");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 69;
        }

        if (upgradeVersion == 69) {
            // Add RADIO_NFC to AIRPLANE_MODE_RADIO and AIRPLANE_MODE_TOGGLEABLE_RADIOS
            String airplaneRadios = mContext.getResources().getString(
                    R.string.def_airplane_mode_radios);
            String toggleableRadios = mContext.getResources().getString(
                    R.string.airplane_mode_toggleable_radios);
            db.beginTransaction();
            try {
                db.execSQL("UPDATE system SET value='" + airplaneRadios + "' " +
                        "WHERE name='" + Settings.System.AIRPLANE_MODE_RADIOS + "'");
                db.execSQL("UPDATE system SET value='" + toggleableRadios + "' " +
                        "WHERE name='" + Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS + "'");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 70;
        }

        if (upgradeVersion == 70) {
            // Update all built-in bookmarks.  Some of the package names have changed.
            loadBookmarks(db);
            upgradeVersion = 71;
        }

        if (upgradeVersion == 71) {
             // New setting to specify whether to speak passwords in accessibility mode.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD,
                        R.bool.def_accessibility_speak_password);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 72;
        }

        if (upgradeVersion == 72) {
            // update vibration settings
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.System.VIBRATE_IN_SILENT,
                        R.bool.def_vibrate_in_silent);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 73;
        }

        if (upgradeVersion == 73) {
            upgradeVibrateSettingFromNone(db);
            upgradeVersion = 74;
        }

        if (upgradeVersion == 74) {
            // URL from which WebView loads a JavaScript based screen-reader.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
                        R.string.def_accessibility_screen_reader_url);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 75;
        }
        if (upgradeVersion == 75) {
            db.beginTransaction();
            SQLiteStatement stmt = null;
            Cursor c = null;
            try {
                c = db.<mark>query</mark>(TABLE_SECURE, new String[] {"_id", "value"},
                        "name='lockscreen.disabled'",
                        null, null, null, null);
                // only set default if it has not yet been set
                if (c == null || c.getCount() == 0) {
                    stmt = db.compileStatement("INSERT INTO system(name,value)"
                            + " VALUES(?,?);");
                    loadBooleanSetting(stmt, Settings.System.LOCKSCREEN_DISABLED,
                            R.bool.def_lockscreen_disabled);
                }
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (c != null) c.close();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 76;
        }

        /************* The following are Jelly Bean changes ************/

        if (upgradeVersion == 76) {
            // Removed VIBRATE_IN_SILENT setting
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                                + Settings.System.VIBRATE_IN_SILENT + "'");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }

            upgradeVersion = 77;
        }

        if (upgradeVersion == 77) {
            // Introduce "vibrate when ringing" setting
            loadVibrateWhenRingingSetting(db);

            upgradeVersion = 78;
        }

        if (upgradeVersion == 78) {
            // The JavaScript based screen-reader URL changes in JellyBean.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
                        R.string.def_accessibility_screen_reader_url);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 79;
        }

        if (upgradeVersion == 79) {
            // Before touch exploration was a global setting controlled by the user
            // via the UI. However, if the enabled accessibility services do not
            // handle touch exploration mode, enabling it makes no sense. Therefore,
            // now the services request touch exploration mode and the user is
            // presented with a dialog to allow that and if she does we store that
            // in the database. As a result of this change a user that has enabled
            // accessibility, touch exploration, and some accessibility services
            // may lose touch exploration state, thus rendering the device useless
            // unless sighted help is provided, since the enabled service(s) are
            // not in the list of services to which the user granted a permission
            // to put the device in touch explore mode. Here we are allowing all
            // enabled accessibility services to toggle touch exploration provided
            // accessibility and touch exploration are enabled and no services can
            // toggle touch exploration. Note that the user has already manually
            // enabled the services and touch exploration which means the she has
            // given consent to have these services work in touch exploration mode.
            final boolean accessibilityEnabled = getIntValueFromTable(db, TABLE_SECURE,
                    Settings.Secure.ACCESSIBILITY_ENABLED, 0) == 1;
            final boolean touchExplorationEnabled = getIntValueFromTable(db, TABLE_SECURE,
                    Settings.Secure.TOUCH_EXPLORATION_ENABLED, 0) == 1;
            if (accessibilityEnabled && touchExplorationEnabled) {
                String enabledServices = getStringValueFromTable(db, TABLE_SECURE,
                        Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, "");
                String touchExplorationGrantedServices = getStringValueFromTable(db, TABLE_SECURE,
                        Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES, "");
                if (TextUtils.isEmpty(touchExplorationGrantedServices)
                        && !TextUtils.isEmpty(enabledServices)) {
                    SQLiteStatement stmt = null;
                    try {
                        db.beginTransaction();
                        stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
                                + " VALUES(?,?);");
                        loadSetting(stmt,
                                Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
                                enabledServices);
                        db.setTransactionSuccessful();
                    } finally {
                        db.endTransaction();
                        if (stmt != null) stmt.close();
                    }
                }
            }
            upgradeVersion = 80;
        }

        // vvv Jelly Bean MR1 changes begin here vvv

        if (upgradeVersion == 80) {
            // update screensaver settings
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ENABLED,
                        com.android.internal.R.bool.config_dreamsEnabledByDefault);
                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK,
                        com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);
                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP,
                        com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);
                loadStringSetting(stmt, Settings.Secure.SCREENSAVER_COMPONENTS,
                        com.android.internal.R.string.config_dreamsDefaultComponent);
                loadStringSetting(stmt, Settings.Secure.SCREENSAVER_DEFAULT_COMPONENT,
                        com.android.internal.R.string.config_dreamsDefaultComponent);

                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 81;
        }

        if (upgradeVersion == 81) {
            // Add package verification setting
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.Global.PACKAGE_VERIFIER_ENABLE,
                        R.bool.def_package_verifier_enable);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 82;
        }

        if (upgradeVersion == 82) {
            // Move to per-user settings dbs
            if (mUserHandle == UserHandle.USER_OWNER) {

                db.beginTransaction();
                SQLiteStatement stmt = null;
                try {
                    // Migrate now-global settings. Note that this happens before
                    // new users can be created.
                    createGlobalTable(db);
                    String[] settingsToMove = hashsetToStringArray(SettingsProvider.sSystemGlobalKeys);
                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, false);
                    settingsToMove = hashsetToStringArray(SettingsProvider.sSecureGlobalKeys);
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, false);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                    if (stmt != null) stmt.close();
                }
            }
            upgradeVersion = 83;
        }

        if (upgradeVersion == 83) {
            // 1. Setting whether screen magnification is enabled.
            // 2. Setting for screen magnification scale.
            // 3. Setting for screen magnification auto update.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
                loadBooleanSetting(stmt,
                        Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
                        R.bool.def_accessibility_display_magnification_enabled);
                stmt.close();
                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
                loadFractionSetting(stmt, Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
                        R.fraction.def_accessibility_display_magnification_scale, 1);
                stmt.close();
                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
                loadBooleanSetting(stmt,
                        Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_AUTO_UPDATE,
                        R.bool.def_accessibility_display_magnification_auto_update);

                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 84;
        }

        if (upgradeVersion == 84) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                SQLiteStatement stmt = null;
                try {
                    // Patch up the slightly-wrong key migration from 82 -> 83 for those
                    // devices that missed it, ignoring if the move is redundant
                    String[] settingsToMove = {
                            Settings.Secure.ADB_ENABLED,
                            Settings.Secure.BLUETOOTH_ON,
                            Settings.Secure.DATA_ROAMING,
                            Settings.Secure.DEVICE_PROVISIONED,
                            Settings.Secure.INSTALL_NON_MARKET_APPS,
                            Settings.Secure.USB_MASS_STORAGE_ENABLED
                    };
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                    if (stmt != null) stmt.close();
                }
            }
            upgradeVersion = 85;
        }

        if (upgradeVersion == 85) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    // Fix up the migration, ignoring already-migrated elements, to snap up to
                    // date with new changes to the set of global versus system/secure settings
                    String[] settingsToMove = { Settings.System.STAY_ON_WHILE_PLUGGED_IN };
                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 86;
        }

        if (upgradeVersion == 86) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] settingsToMove = {
                            Settings.Global.PACKAGE_VERIFIER_ENABLE,
                            Settings.Global.PACKAGE_VERIFIER_TIMEOUT,
                            Settings.Global.PACKAGE_VERIFIER_DEFAULT_RESPONSE
                    };
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 87;
        }

        if (upgradeVersion == 87) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] settingsToMove = {
                            Settings.Global.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS,
                            Settings.Global.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS,
                            Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS
                    };
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 88;
        }

        if (upgradeVersion == 88) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] settingsToMove = {
                            Settings.Global.BATTERY_DISCHARGE_DURATION_THRESHOLD,
                            Settings.Global.BATTERY_DISCHARGE_THRESHOLD,
                            Settings.Global.SEND_ACTION_APP_ERROR,
                            Settings.Global.DROPBOX_AGE_SECONDS,
                            Settings.Global.DROPBOX_MAX_FILES,
                            Settings.Global.DROPBOX_QUOTA_KB,
                            Settings.Global.DROPBOX_QUOTA_PERCENT,
                            Settings.Global.DROPBOX_RESERVE_PERCENT,
                            Settings.Global.DROPBOX_TAG_PREFIX,
                            Settings.Global.ERROR_LOGCAT_PREFIX,
                            Settings.Global.SYS_FREE_STORAGE_LOG_INTERVAL,
                            Settings.Global.DISK_FREE_CHANGE_REPORTING_THRESHOLD,
                            Settings.Global.SYS_STORAGE_THRESHOLD_PERCENTAGE,
                            Settings.Global.SYS_STORAGE_THRESHOLD_MAX_BYTES,
                            Settings.Global.SYS_STORAGE_FULL_THRESHOLD_BYTES,
                            Settings.Global.SYNC_MAX_RETRY_DELAY_IN_SECONDS,
                            Settings.Global.CONNECTIVITY_CHANGE_DELAY,
                            Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED,
                            Settings.Global.CAPTIVE_PORTAL_SERVER,
                            Settings.Global.NSD_ON,
                            Settings.Global.SET_INSTALL_LOCATION,
                            Settings.Global.DEFAULT_INSTALL_LOCATION,
                            Settings.Global.INET_CONDITION_DEBOUNCE_UP_DELAY,
                            Settings.Global.INET_CONDITION_DEBOUNCE_DOWN_DELAY,
                            Settings.Global.READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT,
                            Settings.Global.HTTP_PROXY,
                            Settings.Global.GLOBAL_HTTP_PROXY_HOST,
                            Settings.Global.GLOBAL_HTTP_PROXY_PORT,
                            Settings.Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST,
                            Settings.Global.SET_GLOBAL_HTTP_PROXY,
                            Settings.Global.DEFAULT_DNS_SERVER,
                    };
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 89;
        }

        if (upgradeVersion == 89) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] prefixesToMove = {
                            Settings.Global.BLUETOOTH_HEADSET_PRIORITY_PREFIX,
                            Settings.Global.BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX,
                            Settings.Global.BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX,
                    };

                    movePrefixedSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, prefixesToMove);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 90;
        }

        if (upgradeVersion == 90) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] systemToGlobal = {
                            Settings.Global.WINDOW_ANIMATION_SCALE,
                            Settings.Global.TRANSITION_ANIMATION_SCALE,
                            Settings.Global.ANIMATOR_DURATION_SCALE,
                            Settings.Global.FANCY_IME_ANIMATIONS,
                            Settings.Global.COMPATIBILITY_MODE,
                            Settings.Global.EMERGENCY_TONE,
                            Settings.Global.CALL_AUTO_RETRY,
                            Settings.Global.DEBUG_APP,
                            Settings.Global.WAIT_FOR_DEBUGGER,
                            Settings.Global.SHOW_PROCESSES,
                            Settings.Global.ALWAYS_FINISH_ACTIVITIES,
                    };
                    String[] secureToGlobal = {
                            Settings.Global.PREFERRED_NETWORK_MODE,
                            Settings.Global.CDMA_SUBSCRIPTION_MODE,
                    };

                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, systemToGlobal, true);
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, secureToGlobal, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 91;
        }

        if (upgradeVersion == 91) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    // Move ringer mode from system to global settings
                    String[] settingsToMove = { Settings.Global.MODE_RINGER };
                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 92;
        }

        if (upgradeVersion == 92) {
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
                        + " VALUES(?,?);");
                if (mUserHandle == UserHandle.USER_OWNER) {
                    // consider existing primary users to have made it through user setup
                    // if the globally-scoped device-provisioned bit is set
                    // (indicating they already made it through setup as primary)
                    int deviceProvisioned = getIntValueFromTable(db, TABLE_GLOBAL,
                            Settings.Global.DEVICE_PROVISIONED, 0);
                    loadSetting(stmt, Settings.Secure.USER_SETUP_COMPLETE,
                            deviceProvisioned);
                } else {
                    // otherwise use the default
                    loadBooleanSetting(stmt, Settings.Secure.USER_SETUP_COMPLETE,
                            R.bool.def_user_setup_complete);
                }
            } finally {
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 93;
        }

        if (upgradeVersion == 93) {
            // Redo this step, since somehow it didn't work the first time for some users
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    // Migrate now-global settings
                    String[] settingsToMove = hashsetToStringArray(SettingsProvider.sSystemGlobalKeys);
                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);
                    settingsToMove = hashsetToStringArray(SettingsProvider.sSecureGlobalKeys);
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 94;
        }

        if (upgradeVersion == 94) {
            // Add wireless charging started sound setting
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                SQLiteStatement stmt = null;
                try {
                    stmt = db.compileStatement("INSERT OR REPLACE INTO global(name,value)"
                            + " VALUES(?,?);");
                    loadStringSetting(stmt, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND,
                            R.string.def_wireless_charging_started_sound);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                    if (stmt != null) stmt.close();
                }
            }
            upgradeVersion = 95;
        }

        if (upgradeVersion == 95) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] settingsToMove = { Settings.Global.BUGREPORT_IN_POWER_MENU };
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 96;
        }

        if (upgradeVersion == 96) {
            // NOP bump due to a reverted change that some people got on upgrade.
            upgradeVersion = 97;
        }

        if (upgradeVersion == 97) {
            // Add Default Dialer AutoComplete setting
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                SQLiteStatement stmt = null;
                try {
                    stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
                            + " VALUES(?,?);");
                    loadIntegerSetting(stmt, Settings.Secure.DIALPAD_AUTOCOMPLETE,
                            R.integer.def_dialpad_autocomplete);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                    if (stmt != null) stmt.close();
                }
            }
            upgradeVersion = 98;
        }

        // *** Remember to update DATABASE_VERSION above!

        if (upgradeVersion != currentVersion) {
            Log.w(TAG, "Got stuck trying to upgrade from version " + upgradeVersion
                    + ", must wipe the settings provider");
            wipeDB(db, oldVersion, upgradeVersion, currentVersion);
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>ParanoidAndroid_____android_frameworks_base_____DatabaseHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/android_database_sqlite/ParanoidAndroid_____android_frameworks_base_____DatabaseHelper.java

android.database.sqlite.SQLiteDatabase.query
android.database.sqlite.SQLiteDatabase.delete

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) {
        Log.w(TAG, "Upgrading settings database from version " + oldVersion + " to "
                + currentVersion);

        int upgradeVersion = oldVersion;

        // Pattern for upgrade blocks:
        //
        //    if (upgradeVersion == [the DATABASE_VERSION you set] - 1) {
        //        .. your upgrade logic..
        //        upgradeVersion = [the DATABASE_VERSION you set]
        //    }

        if (upgradeVersion == 20) {
            /*
             * Version 21 is part of the volume control refresh. There is no
             * longer a UI-visible for setting notification vibrate on/off (in
             * our design), but the functionality still exists. Force the
             * notification vibrate to on.
             */
            loadVibrateSetting(db, true);

            upgradeVersion = 21;
        }

        if (upgradeVersion < 22) {
            upgradeVersion = 22;
            // Upgrade the lock gesture storage location and format
            upgradeLockPatternLocation(db);
        }

        if (upgradeVersion < 23) {
            db.execSQL("UPDATE favorites SET iconResource=0 WHERE iconType=0");
            upgradeVersion = 23;
        }

        if (upgradeVersion == 23) {
            db.beginTransaction();
            try {
                db.execSQL("ALTER TABLE favorites ADD spanX INTEGER");
                db.execSQL("ALTER TABLE favorites ADD spanY INTEGER");
                // Shortcuts, applications, folders
                db.execSQL("UPDATE favorites SET spanX=1, spanY=1 WHERE itemType<=0");
                // Photo frames, clocks
                db.execSQL(
                    "UPDATE favorites SET spanX=2, spanY=2 WHERE itemType=1000 or itemType=1002");
                // Search boxes
                db.execSQL("UPDATE favorites SET spanX=4, spanY=1 WHERE itemType=1001");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 24;
        }

        if (upgradeVersion == 24) {
            db.beginTransaction();
            try {
                // The value of the constants for preferring wifi or preferring mobile have been
                // swapped, so reload the default.
                db.execSQL("DELETE FROM system WHERE name='network_preference'");
                db.execSQL("INSERT INTO system ('name', 'value') values ('network_preference', '" +
                        ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + "')");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 25;
        }

        if (upgradeVersion == 25) {
            db.beginTransaction();
            try {
                db.execSQL("ALTER TABLE favorites ADD uri TEXT");
                db.execSQL("ALTER TABLE favorites ADD displayMode INTEGER");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 26;
        }

        if (upgradeVersion == 26) {
            // This introduces the new secure settings table.
            db.beginTransaction();
            try {
                createSecureTable(db);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 27;
        }

        if (upgradeVersion == 27) {
            String[] settingsToMove = {
                    Settings.Secure.ADB_ENABLED,
                    Settings.Secure.ANDROID_ID,
                    Settings.Secure.BLUETOOTH_ON,
                    Settings.Secure.DATA_ROAMING,
                    Settings.Secure.DEVICE_PROVISIONED,
                    Settings.Secure.HTTP_PROXY,
                    Settings.Secure.INSTALL_NON_MARKET_APPS,
                    Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
                    Settings.Secure.LOGGING_ID,
                    Settings.Secure.NETWORK_PREFERENCE,
                    Settings.Secure.PARENTAL_CONTROL_ENABLED,
                    Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,
                    Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,
                    Settings.Secure.SETTINGS_CLASSNAME,
                    Settings.Secure.USB_MASS_STORAGE_ENABLED,
                    Settings.Secure.USE_GOOGLE_MAIL,
                    Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
                    Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
                    Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,
                    Settings.Secure.WIFI_ON,
                    Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,
                    Settings.Secure.WIFI_WATCHDOG_AP_COUNT,
                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,
                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,
                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,
                    Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,
                    Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,
                    Settings.Secure.WIFI_WATCHDOG_ON,
                    Settings.Secure.WIFI_WATCHDOG_PING_COUNT,
                    Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,
                    Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS,
                };
            moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
            upgradeVersion = 28;
        }

        if (upgradeVersion == 28 || upgradeVersion == 29) {
            // Note: The upgrade to 28 was flawed since it didn't delete the old
            // setting first before inserting. Combining 28 and 29 with the
            // fixed version.

            // This upgrade adds the STREAM_NOTIFICATION type to the list of
            // types affected by ringer modes (silent, vibrate, etc.)
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
                int newValue = (1 << AudioManager.STREAM_RING)
                        | (1 << AudioManager.STREAM_NOTIFICATION)
                        | (1 << AudioManager.STREAM_SYSTEM);
                db.execSQL("INSERT INTO system ('name', 'value') values ('"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
                        + String.valueOf(newValue) + "')");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }

            upgradeVersion = 30;
        }

        if (upgradeVersion == 30) {
            /*
             * Upgrade 31 clears the title for all quick launch shortcuts so the
             * activities' titles will be resolved at display time. Also, the
             * folder is changed to '@quicklaunch'.
             */
            db.beginTransaction();
            try {
                db.execSQL("UPDATE bookmarks SET folder = '@quicklaunch'");
                db.execSQL("UPDATE bookmarks SET title = ''");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 31;
        }

        if (upgradeVersion == 31) {
            /*
             * Animations are now managed in preferences, and may be
             * enabled or disabled based on product resources.
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadDefaultAnimationSettings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 32;
        }

        if (upgradeVersion == 32) {
            // The Wi-Fi watchdog SSID list is now seeded with the value of
            // the property ro.com.android.wifi-watchlist
            String wifiWatchList = SystemProperties.get("ro.com.android.wifi-watchlist");
            if (!TextUtils.isEmpty(wifiWatchList)) {
                db.beginTransaction();
                try {
                    db.execSQL("INSERT OR IGNORE INTO secure(name,value) values('" +
                            Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + "','" +
                            wifiWatchList + "');");
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 33;
        }

        if (upgradeVersion == 33) {
            // Set the default zoom controls to: tap-twice to bring up +/-
            db.beginTransaction();
            try {
                db.execSQL("INSERT INTO system(name,value) values('zoom','2');");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 34;
        }

        if (upgradeVersion == 34) {
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadSecure35Settings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 35;
        }
            // due to a botched merge from donut to eclair, the initialization of ASSISTED_GPS_ENABLED
            // was accidentally done out of order here.
            // to fix this, ASSISTED_GPS_ENABLED is now initialized while upgrading from 38 to 39,
            // and we intentionally do nothing from 35 to 36 now.
        if (upgradeVersion == 35) {
            upgradeVersion = 36;
        }

        if (upgradeVersion == 36) {
           // This upgrade adds the STREAM_SYSTEM_ENFORCED type to the list of
            // types affected by ringer modes (silent, vibrate, etc.)
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
                int newValue = (1 << AudioManager.STREAM_RING)
                        | (1 << AudioManager.STREAM_NOTIFICATION)
                        | (1 << AudioManager.STREAM_SYSTEM)
                        | (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
                db.execSQL("INSERT INTO system ('name', 'value') values ('"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
                        + String.valueOf(newValue) + "')");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 37;
        }

        if (upgradeVersion == 37) {
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
                        + " VALUES(?,?);");
                loadStringSetting(stmt, Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,
                        R.string.airplane_mode_toggleable_radios);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 38;
        }

        if (upgradeVersion == 38) {
            db.beginTransaction();
            try {
                String value =
                        mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? "1" : "0";
                db.execSQL("INSERT OR IGNORE INTO secure(name,value) values('" +
                        Settings.Global.ASSISTED_GPS_ENABLED + "','" + value + "');");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }

            upgradeVersion = 39;
        }

        if (upgradeVersion == 39) {
            upgradeAutoBrightness(db);
            upgradeVersion = 40;
        }

        if (upgradeVersion == 40) {
            /*
             * All animations are now turned on by default!
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadDefaultAnimationSettings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 41;
        }

        if (upgradeVersion == 41) {
            /*
             * Initialize newly public haptic feedback setting
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.HAPTIC_FEEDBACK_ENABLED + "'");
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadDefaultHapticSettings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 42;
        }

        if (upgradeVersion == 42) {
            /*
             * Initialize new notification pulse setting
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.System.NOTIFICATION_LIGHT_PULSE,
                        R.bool.def_notification_pulse);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 43;
        }

        if (upgradeVersion == 43) {
            /*
             * This upgrade stores bluetooth volume separately from voice volume
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
                        + " VALUES(?,?);");
                loadSetting(stmt, Settings.System.VOLUME_BLUETOOTH_SCO,
                        AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 44;
        }

        if (upgradeVersion == 44) {
            /*
             * Gservices was moved into vendor/google.
             */
            db.execSQL("DROP TABLE IF EXISTS gservices");
            db.execSQL("DROP INDEX IF EXISTS gservicesIndex1");
            upgradeVersion = 45;
        }

        if (upgradeVersion == 45) {
             /*
              * New settings for MountService
              */
            db.beginTransaction();
            try {
                db.execSQL("INSERT INTO secure(name,value) values('" +
                        Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + "','1');");
                db.execSQL("INSERT INTO secure(name,value) values('" +
                        Settings.Secure.MOUNT_UMS_AUTOSTART + "','0');");
                db.execSQL("INSERT INTO secure(name,value) values('" +
                        Settings.Secure.MOUNT_UMS_PROMPT + "','1');");
                db.execSQL("INSERT INTO secure(name,value) values('" +
                        Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + "','1');");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 46;
        }

        if (upgradeVersion == 46) {
            /*
             * The password mode constants have changed; reset back to no
             * password.
             */
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='lockscreen.password_type';");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
           upgradeVersion = 47;
       }


        if (upgradeVersion == 47) {
            /*
             * The password mode constants have changed again; reset back to no
             * password.
             */
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='lockscreen.password_type';");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
           upgradeVersion = 48;
       }

       if (upgradeVersion == 48) {
           /*
            * Default recognition service no longer initialized here,
            * moved to RecognitionManagerService.
            */
           upgradeVersion = 49;
       }

       if (upgradeVersion == 49) {
           /*
            * New settings for new user interface noises.
            */
           db.beginTransaction();
           SQLiteStatement stmt = null;
           try {
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadUISoundEffectsSettings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }

           upgradeVersion = 50;
       }

       if (upgradeVersion == 50) {
           /*
            * Install location no longer initiated here.
            */
           upgradeVersion = 51;
       }

       if (upgradeVersion == 51) {
           /* Move the lockscreen related settings to Secure, including some private ones. */
           String[] settingsToMove = {
                   Secure.LOCK_PATTERN_ENABLED,
                   Secure.LOCK_PATTERN_VISIBLE,
                   Secure.LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED,
                   "lockscreen.password_type",
                   "lockscreen.lockoutattemptdeadline",
                   "lockscreen.patterneverchosen",
                   "lock_pattern_autolock",
                   "lockscreen.lockedoutpermanently",
                   "lockscreen.password_salt"
           };
           moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
           upgradeVersion = 52;
       }

        if (upgradeVersion == 52) {
            // new vibration/silent mode settings
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.System.VIBRATE_IN_SILENT,
                        R.bool.def_vibrate_in_silent);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }

            upgradeVersion = 53;
        }

        if (upgradeVersion == 53) {
            /*
             * New settings for set install location UI no longer initiated here.
             */
            upgradeVersion = 54;
        }

        if (upgradeVersion == 54) {
            /*
             * Update the screen timeout value if set to never
             */
            db.beginTransaction();
            try {
                upgradeScreenTimeoutFromNever(db);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }

            upgradeVersion = 55;
        }

        if (upgradeVersion == 55) {
            /* Move the install location settings. */
            String[] settingsToMove = {
                    Global.SET_INSTALL_LOCATION,
                    Global.DEFAULT_INSTALL_LOCATION
            };
            moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadSetting(stmt, Global.SET_INSTALL_LOCATION, 0);
                loadSetting(stmt, Global.DEFAULT_INSTALL_LOCATION,
                        PackageHelper.APP_INSTALL_AUTO);
                db.setTransactionSuccessful();
             } finally {
                 db.endTransaction();
                 if (stmt != null) stmt.close();
             }
            upgradeVersion = 56;
        }

        if (upgradeVersion == 56) {
            /*
             * Add Bluetooth to list of toggleable radios in airplane mode
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS + "'");
                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
                        + " VALUES(?,?);");
                loadStringSetting(stmt, Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,
                        R.string.airplane_mode_toggleable_radios);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 57;
        }

        /************* The following are Honeycomb changes ************/

        if (upgradeVersion == 57) {
            /*
             * New settings to:
             *  1. Enable injection of accessibility scripts in WebViews.
             *  2. Define the key bindings for traversing web content in WebViews.
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SCRIPT_INJECTION,
                        R.bool.def_accessibility_script_injection);
                stmt.close();
                stmt = db.compileStatement("INSERT INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_WEB_CONTENT_KEY_BINDINGS,
                        R.string.def_accessibility_web_content_key_bindings);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 58;
        }

        if (upgradeVersion == 58) {
            /* Add default for new Auto Time Zone */
            int autoTimeValue = getIntValueFromSystem(db, Settings.System.AUTO_TIME, 0);
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO system(name,value)" + " VALUES(?,?);");
                loadSetting(stmt, Settings.System.AUTO_TIME_ZONE,
                        autoTimeValue); // Sync timezone to NITZ if auto_time was enabled
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 59;
        }

        if (upgradeVersion == 59) {
            // Persistence for the rotation lock feature.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.System.USER_ROTATION,
                        R.integer.def_user_rotation); // should be zero degrees
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 60;
        }

        if (upgradeVersion == 60) {
            // Don't do this for upgrades from Gingerbread
            // Were only required for intra-Honeycomb upgrades for testing
            // upgradeScreenTimeout(db);
            upgradeVersion = 61;
        }

        if (upgradeVersion == 61) {
            // Don't do this for upgrades from Gingerbread
            // Were only required for intra-Honeycomb upgrades for testing
            // upgradeScreenTimeout(db);
            upgradeVersion = 62;
        }

        // Change the default for screen auto-brightness mode
        if (upgradeVersion == 62) {
            // Don't do this for upgrades from Gingerbread
            // Were only required for intra-Honeycomb upgrades for testing
            // upgradeAutoBrightness(db);
            upgradeVersion = 63;
        }

        if (upgradeVersion == 63) {
            // This upgrade adds the STREAM_MUSIC type to the list of
             // types affected by ringer modes (silent, vibrate, etc.)
             db.beginTransaction();
             try {
                 db.execSQL("DELETE FROM system WHERE name='"
                         + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
                 int newValue = (1 << AudioManager.STREAM_RING)
                         | (1 << AudioManager.STREAM_NOTIFICATION)
                         | (1 << AudioManager.STREAM_SYSTEM)
                         | (1 << AudioManager.STREAM_SYSTEM_ENFORCED)
                         | (1 << AudioManager.STREAM_MUSIC);
                 db.execSQL("INSERT INTO system ('name', 'value') values ('"
                         + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
                         + String.valueOf(newValue) + "')");
                 db.setTransactionSuccessful();
             } finally {
                 db.endTransaction();
             }
             upgradeVersion = 64;
         }

        if (upgradeVersion == 64) {
            // New setting to configure the long press timeout.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadIntegerSetting(stmt, Settings.Secure.LONG_PRESS_TIMEOUT,
                        R.integer.def_long_press_timeout_millis);
                stmt.close();
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 65;
        }

        /************* The following are Ice Cream Sandwich changes ************/

        if (upgradeVersion == 65) {
            /*
             * Animations are removed from Settings. Turned on by default
             */
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
                stmt = db.compileStatement("INSERT INTO system(name,value)"
                        + " VALUES(?,?);");
                loadDefaultAnimationSettings(stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 66;
        }

        if (upgradeVersion == 66) {
            // This upgrade makes sure that MODE_RINGER_STREAMS_AFFECTED is set
            // according to device voice capability
            db.beginTransaction();
            try {
                int ringerModeAffectedStreams = (1 << AudioManager.STREAM_RING) |
                                                (1 << AudioManager.STREAM_NOTIFICATION) |
                                                (1 << AudioManager.STREAM_SYSTEM) |
                                                (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
                if (!mContext.getResources().getBoolean(
                        com.android.internal.R.bool.config_voice_capable)) {
                    ringerModeAffectedStreams |= (1 << AudioManager.STREAM_MUSIC);
                }
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
                db.execSQL("INSERT INTO system ('name', 'value') values ('"
                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
                        + String.valueOf(ringerModeAffectedStreams) + "')");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 67;
        }

        if (upgradeVersion == 67) {
            // New setting to enable touch exploration.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.Secure.TOUCH_EXPLORATION_ENABLED,
                        R.bool.def_touch_exploration_enabled);
                stmt.close();
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 68;
        }

        if (upgradeVersion == 68) {
            // Enable all system sounds by default
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                        + Settings.System.NOTIFICATIONS_USE_RING_VOLUME + "'");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 69;
        }

        if (upgradeVersion == 69) {
            // Add RADIO_NFC to AIRPLANE_MODE_RADIO and AIRPLANE_MODE_TOGGLEABLE_RADIOS
            String airplaneRadios = mContext.getResources().getString(
                    R.string.def_airplane_mode_radios);
            String toggleableRadios = mContext.getResources().getString(
                    R.string.airplane_mode_toggleable_radios);
            db.beginTransaction();
            try {
                db.execSQL("UPDATE system SET value='" + airplaneRadios + "' " +
                        "WHERE name='" + Settings.System.AIRPLANE_MODE_RADIOS + "'");
                db.execSQL("UPDATE system SET value='" + toggleableRadios + "' " +
                        "WHERE name='" + Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS + "'");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
            upgradeVersion = 70;
        }

        if (upgradeVersion == 70) {
            // Update all built-in bookmarks.  Some of the package names have changed.
            loadBookmarks(db);
            upgradeVersion = 71;
        }

        if (upgradeVersion == 71) {
             // New setting to specify whether to speak passwords in accessibility mode.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD,
                        R.bool.def_accessibility_speak_password);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 72;
        }

        if (upgradeVersion == 72) {
            // update vibration settings
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.System.VIBRATE_IN_SILENT,
                        R.bool.def_vibrate_in_silent);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 73;
        }

        if (upgradeVersion == 73) {
            upgradeVibrateSettingFromNone(db);
            upgradeVersion = 74;
        }

        if (upgradeVersion == 74) {
            // URL from which WebView loads a JavaScript based screen-reader.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
                        R.string.def_accessibility_screen_reader_url);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 75;
        }
        if (upgradeVersion == 75) {
            db.beginTransaction();
            SQLiteStatement stmt = null;
            Cursor c = null;
            try {
                c = db.<mark>query</mark>(TABLE_SECURE, new String[] {"_id", "value"},
                        "name='lockscreen.disabled'",
                        null, null, null, null);
                // only set default if it has not yet been set
                if (c == null || c.getCount() == 0) {
                    stmt = db.compileStatement("INSERT INTO system(name,value)"
                            + " VALUES(?,?);");
                    loadBooleanSetting(stmt, Settings.System.LOCKSCREEN_DISABLED,
                            R.bool.def_lockscreen_disabled);
                }
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (c != null) c.close();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 76;
        }

        /************* The following are Jelly Bean changes ************/

        if (upgradeVersion == 76) {
            // Removed VIBRATE_IN_SILENT setting
            db.beginTransaction();
            try {
                db.execSQL("DELETE FROM system WHERE name='"
                                + Settings.System.VIBRATE_IN_SILENT + "'");
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }

            upgradeVersion = 77;
        }

        if (upgradeVersion == 77) {
            // Introduce "vibrate when ringing" setting
            loadVibrateWhenRingingSetting(db);

            upgradeVersion = 78;
        }

        if (upgradeVersion == 78) {
            // The JavaScript based screen-reader URL changes in JellyBean.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
                        R.string.def_accessibility_screen_reader_url);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 79;
        }

        if (upgradeVersion == 79) {
            // Before touch exploration was a global setting controlled by the user
            // via the UI. However, if the enabled accessibility services do not
            // handle touch exploration mode, enabling it makes no sense. Therefore,
            // now the services request touch exploration mode and the user is
            // presented with a dialog to allow that and if she does we store that
            // in the database. As a result of this change a user that has enabled
            // accessibility, touch exploration, and some accessibility services
            // may lose touch exploration state, thus rendering the device useless
            // unless sighted help is provided, since the enabled service(s) are
            // not in the list of services to which the user granted a permission
            // to put the device in touch explore mode. Here we are allowing all
            // enabled accessibility services to toggle touch exploration provided
            // accessibility and touch exploration are enabled and no services can
            // toggle touch exploration. Note that the user has already manually
            // enabled the services and touch exploration which means the she has
            // given consent to have these services work in touch exploration mode.
            final boolean accessibilityEnabled = getIntValueFromTable(db, TABLE_SECURE,
                    Settings.Secure.ACCESSIBILITY_ENABLED, 0) == 1;
            final boolean touchExplorationEnabled = getIntValueFromTable(db, TABLE_SECURE,
                    Settings.Secure.TOUCH_EXPLORATION_ENABLED, 0) == 1;
            if (accessibilityEnabled && touchExplorationEnabled) {
                String enabledServices = getStringValueFromTable(db, TABLE_SECURE,
                        Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, "");
                String touchExplorationGrantedServices = getStringValueFromTable(db, TABLE_SECURE,
                        Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES, "");
                if (TextUtils.isEmpty(touchExplorationGrantedServices)
                        && !TextUtils.isEmpty(enabledServices)) {
                    SQLiteStatement stmt = null;
                    try {
                        db.beginTransaction();
                        stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
                                + " VALUES(?,?);");
                        loadSetting(stmt,
                                Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
                                enabledServices);
                        db.setTransactionSuccessful();
                    } finally {
                        db.endTransaction();
                        if (stmt != null) stmt.close();
                    }
                }
            }
            upgradeVersion = 80;
        }

        // vvv Jelly Bean MR1 changes begin here vvv

        if (upgradeVersion == 80) {
            // update screensaver settings
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ENABLED,
                        com.android.internal.R.bool.config_dreamsEnabledByDefault);
                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK,
                        com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);
                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP,
                        com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);
                loadStringSetting(stmt, Settings.Secure.SCREENSAVER_COMPONENTS,
                        com.android.internal.R.string.config_dreamsDefaultComponent);
                loadStringSetting(stmt, Settings.Secure.SCREENSAVER_DEFAULT_COMPONENT,
                        com.android.internal.R.string.config_dreamsDefaultComponent);

                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 81;
        }

        if (upgradeVersion == 81) {
            // Add package verification setting
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
                        + " VALUES(?,?);");
                loadBooleanSetting(stmt, Settings.Global.PACKAGE_VERIFIER_ENABLE,
                        R.bool.def_package_verifier_enable);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 82;
        }

        if (upgradeVersion == 82) {
            // Move to per-user settings dbs
            if (mUserHandle == UserHandle.USER_OWNER) {

                db.beginTransaction();
                SQLiteStatement stmt = null;
                try {
                    // Migrate now-global settings. Note that this happens before
                    // new users can be created.
                    createGlobalTable(db);
                    String[] settingsToMove = hashsetToStringArray(SettingsProvider.sSystemGlobalKeys);
                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, false);
                    settingsToMove = hashsetToStringArray(SettingsProvider.sSecureGlobalKeys);
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, false);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                    if (stmt != null) stmt.close();
                }
            }
            upgradeVersion = 83;
        }

        if (upgradeVersion == 83) {
            // 1. Setting whether screen magnification is enabled.
            // 2. Setting for screen magnification scale.
            // 3. Setting for screen magnification auto update.
            db.beginTransaction();
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
                loadBooleanSetting(stmt,
                        Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
                        R.bool.def_accessibility_display_magnification_enabled);
                stmt.close();
                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
                loadFractionSetting(stmt, Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
                        R.fraction.def_accessibility_display_magnification_scale, 1);
                stmt.close();
                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
                loadBooleanSetting(stmt,
                        Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_AUTO_UPDATE,
                        R.bool.def_accessibility_display_magnification_auto_update);

                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 84;
        }

        if (upgradeVersion == 84) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                SQLiteStatement stmt = null;
                try {
                    // Patch up the slightly-wrong key migration from 82 -> 83 for those
                    // devices that missed it, ignoring if the move is redundant
                    String[] settingsToMove = {
                            Settings.Secure.ADB_ENABLED,
                            Settings.Secure.BLUETOOTH_ON,
                            Settings.Secure.DATA_ROAMING,
                            Settings.Secure.DEVICE_PROVISIONED,
                            Settings.Secure.INSTALL_NON_MARKET_APPS,
                            Settings.Secure.USB_MASS_STORAGE_ENABLED
                    };
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                    if (stmt != null) stmt.close();
                }
            }
            upgradeVersion = 85;
        }

        if (upgradeVersion == 85) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    // Fix up the migration, ignoring already-migrated elements, to snap up to
                    // date with new changes to the set of global versus system/secure settings
                    String[] settingsToMove = { Settings.System.STAY_ON_WHILE_PLUGGED_IN };
                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 86;
        }

        if (upgradeVersion == 86) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] settingsToMove = {
                            Settings.Global.PACKAGE_VERIFIER_ENABLE,
                            Settings.Global.PACKAGE_VERIFIER_TIMEOUT,
                            Settings.Global.PACKAGE_VERIFIER_DEFAULT_RESPONSE
                    };
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 87;
        }

        if (upgradeVersion == 87) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] settingsToMove = {
                            Settings.Global.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS,
                            Settings.Global.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS,
                            Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS
                    };
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 88;
        }

        if (upgradeVersion == 88) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] settingsToMove = {
                            Settings.Global.BATTERY_DISCHARGE_DURATION_THRESHOLD,
                            Settings.Global.BATTERY_DISCHARGE_THRESHOLD,
                            Settings.Global.SEND_ACTION_APP_ERROR,
                            Settings.Global.DROPBOX_AGE_SECONDS,
                            Settings.Global.DROPBOX_MAX_FILES,
                            Settings.Global.DROPBOX_QUOTA_KB,
                            Settings.Global.DROPBOX_QUOTA_PERCENT,
                            Settings.Global.DROPBOX_RESERVE_PERCENT,
                            Settings.Global.DROPBOX_TAG_PREFIX,
                            Settings.Global.ERROR_LOGCAT_PREFIX,
                            Settings.Global.SYS_FREE_STORAGE_LOG_INTERVAL,
                            Settings.Global.DISK_FREE_CHANGE_REPORTING_THRESHOLD,
                            Settings.Global.SYS_STORAGE_THRESHOLD_PERCENTAGE,
                            Settings.Global.SYS_STORAGE_THRESHOLD_MAX_BYTES,
                            Settings.Global.SYS_STORAGE_FULL_THRESHOLD_BYTES,
                            Settings.Global.SYNC_MAX_RETRY_DELAY_IN_SECONDS,
                            Settings.Global.CONNECTIVITY_CHANGE_DELAY,
                            Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED,
                            Settings.Global.CAPTIVE_PORTAL_SERVER,
                            Settings.Global.NSD_ON,
                            Settings.Global.SET_INSTALL_LOCATION,
                            Settings.Global.DEFAULT_INSTALL_LOCATION,
                            Settings.Global.INET_CONDITION_DEBOUNCE_UP_DELAY,
                            Settings.Global.INET_CONDITION_DEBOUNCE_DOWN_DELAY,
                            Settings.Global.READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT,
                            Settings.Global.HTTP_PROXY,
                            Settings.Global.GLOBAL_HTTP_PROXY_HOST,
                            Settings.Global.GLOBAL_HTTP_PROXY_PORT,
                            Settings.Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST,
                            Settings.Global.SET_GLOBAL_HTTP_PROXY,
                            Settings.Global.DEFAULT_DNS_SERVER,
                    };
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 89;
        }

        if (upgradeVersion == 89) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] prefixesToMove = {
                            Settings.Global.BLUETOOTH_HEADSET_PRIORITY_PREFIX,
                            Settings.Global.BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX,
                            Settings.Global.BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX,
                    };

                    movePrefixedSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, prefixesToMove);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 90;
        }

        if (upgradeVersion == 90) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] systemToGlobal = {
                            Settings.Global.WINDOW_ANIMATION_SCALE,
                            Settings.Global.TRANSITION_ANIMATION_SCALE,
                            Settings.Global.ANIMATOR_DURATION_SCALE,
                            Settings.Global.FANCY_IME_ANIMATIONS,
                            Settings.Global.COMPATIBILITY_MODE,
                            Settings.Global.EMERGENCY_TONE,
                            Settings.Global.CALL_AUTO_RETRY,
                            Settings.Global.DEBUG_APP,
                            Settings.Global.WAIT_FOR_DEBUGGER,
                            Settings.Global.SHOW_PROCESSES,
                            Settings.Global.ALWAYS_FINISH_ACTIVITIES,
                    };
                    String[] secureToGlobal = {
                            Settings.Global.PREFERRED_NETWORK_MODE,
                            Settings.Global.PREFERRED_CDMA_SUBSCRIPTION,
                    };

                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, systemToGlobal, true);
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, secureToGlobal, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 91;
        }

        if (upgradeVersion == 91) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    // Move ringer mode from system to global settings
                    String[] settingsToMove = { Settings.Global.MODE_RINGER };
                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 92;
        }

        if (upgradeVersion == 92) {
            SQLiteStatement stmt = null;
            try {
                stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
                        + " VALUES(?,?);");
                if (mUserHandle == UserHandle.USER_OWNER) {
                    // consider existing primary users to have made it through user setup
                    // if the globally-scoped device-provisioned bit is set
                    // (indicating they already made it through setup as primary)
                    int deviceProvisioned = getIntValueFromTable(db, TABLE_GLOBAL,
                            Settings.Global.DEVICE_PROVISIONED, 0);
                    loadSetting(stmt, Settings.Secure.USER_SETUP_COMPLETE,
                            deviceProvisioned);
                } else {
                    // otherwise use the default
                    loadBooleanSetting(stmt, Settings.Secure.USER_SETUP_COMPLETE,
                            R.bool.def_user_setup_complete);
                }
            } finally {
                if (stmt != null) stmt.close();
            }
            upgradeVersion = 93;
        }

        if (upgradeVersion == 93) {
            // Redo this step, since somehow it didn't work the first time for some users
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    // Migrate now-global settings
                    String[] settingsToMove = hashsetToStringArray(SettingsProvider.sSystemGlobalKeys);
                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);
                    settingsToMove = hashsetToStringArray(SettingsProvider.sSecureGlobalKeys);
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);

                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 94;
        }

        if (upgradeVersion == 94) {
            // Add wireless charging started sound setting
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                SQLiteStatement stmt = null;
                try {
                    stmt = db.compileStatement("INSERT OR REPLACE INTO global(name,value)"
                            + " VALUES(?,?);");
                    loadStringSetting(stmt, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND,
                            R.string.def_wireless_charging_started_sound);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                    if (stmt != null) stmt.close();
                }
            }
            upgradeVersion = 95;
        }

        if (upgradeVersion == 95) {
            if (mUserHandle == UserHandle.USER_OWNER) {
                db.beginTransaction();
                try {
                    String[] settingsToMove = { Settings.Global.BUGREPORT_IN_POWER_MENU };
                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
            upgradeVersion = 96;
        }

        if (upgradeVersion == 96) {
            // NOP bump due to a reverted change that some people got on upgrade.
            upgradeVersion = 97;
        }

        // *** Remember to update DATABASE_VERSION above!

        if (upgradeVersion != currentVersion) {
            Log.w(TAG, "Got stuck trying to upgrade from version " + upgradeVersion
                    + ", must wipe the settings provider");
            db.execSQL("DROP TABLE IF EXISTS global");
            db.execSQL("DROP TABLE IF EXISTS globalIndex1");
            db.execSQL("DROP TABLE IF EXISTS system");
            db.execSQL("DROP INDEX IF EXISTS systemIndex1");
            db.execSQL("DROP TABLE IF EXISTS secure");
            db.execSQL("DROP INDEX IF EXISTS secureIndex1");
            db.execSQL("DROP TABLE IF EXISTS gservices");
            db.execSQL("DROP INDEX IF EXISTS gservicesIndex1");
            db.execSQL("DROP TABLE IF EXISTS bluetooth_devices");
            db.execSQL("DROP TABLE IF EXISTS bookmarks");
            db.execSQL("DROP INDEX IF EXISTS bookmarksIndex1");
            db.execSQL("DROP INDEX IF EXISTS bookmarksIndex2");
            db.execSQL("DROP TABLE IF EXISTS favorites");
            onCreate(db);

            // Added for diagnosing settings.db wipes after the fact
            String wipeReason = oldVersion + "/" + upgradeVersion + "/" + currentVersion;
            db.execSQL("INSERT INTO secure(name,value) values('" +
                    "wiped_db_reason" + "','" + wipeReason + "');");
        }
    }

            </pre>
          </div>
        </div>

        
  </div>
  <!-- /.container -->


</body>

</html>

        