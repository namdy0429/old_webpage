
<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title></title>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

</head>

<body>

  <!-- Page Content -->
  <div class="container" style="max-width: 1620px">
    <div class="row">
      <h1 class="col-lg-12 col-md-12 mb-12" style="margin-top: 30px;">com_google_gson</h1>
      <br>
      <h4 class="col-lg-12 col-md-12 mb-12">fromJson</h4>
    </div>
    
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>linkedin_____gobblin_____Descriptor_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/linkedin_____gobblin_____Descriptor.java

com.google.gson.Gson.fromJson

/**
   * Deserialize the string, resulted from {@link #toJson(List)}, to a list of descriptors
   */   */
  public static Descriptor <mark>fromJson</mark>(String json) {
    return <mark>fromJson</mark>(json, Descriptor.class);
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>WhiteHouse_____wh-app-android_____GsonUtils_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/WhiteHouse_____wh-app-android_____GsonUtils.java

com.google.gson.Gson.fromJson

/**
     * Convert content of reader to given type
     *
     * @return instance of type
     */     */
    public static final <V> V <mark>fromJson</mark>(String json, Type type) {
        return GSON.<mark>fromJson</mark>(json, type);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>eclipse_____egit-github_____GsonUtils_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/eclipse_____egit-github_____GsonUtils.java

com.google.gson.Gson.fromJson

/**
	 * Convert content of reader to given type
	 *
	 * @param reader
	 * @param type
	 * @return instance of type
	 */	 */
	public static final <V> V <mark>fromJson</mark>(String json, Type type) {
		return GSON.<mark>fromJson</mark>(json, type);
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>WhiteHouse_____wh-app-android_____GsonUtils_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/WhiteHouse_____wh-app-android_____GsonUtils.java

com.google.gson.Gson.fromJson

/**
     * Convert content of reader to given type
     *
     * @return instance of type
     */     */
    public static final <V> V <mark>fromJson</mark>(String json, Class<V> type) {
        return GSON.<mark>fromJson</mark>(json, type);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>eclipse_____egit-github_____GsonUtils_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/eclipse_____egit-github_____GsonUtils.java

com.google.gson.Gson.fromJson

/**
	 * Convert content of reader to given type
	 *
	 * @param reader
	 * @param type
	 * @return instance of type
	 */	 */
	public static final <V> V <mark>fromJson</mark>(String json, Class<V> type) {
		return GSON.<mark>fromJson</mark>(json, type);
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>WhiteHouse_____wh-app-android_____GsonUtils_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/WhiteHouse_____wh-app-android_____GsonUtils.java

com.google.gson.Gson.fromJson

/**
     * Convert content of reader to given type
     *
     * @return instance of type
     */     */
    public static final <V> V <mark>fromJson</mark>(Reader reader, Class<V> type) {
        return GSON.<mark>fromJson</mark>(reader, type);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>eclipse_____egit-github_____GsonUtils_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/eclipse_____egit-github_____GsonUtils.java

com.google.gson.Gson.fromJson

/**
	 * Convert content of reader to given type
	 *
	 * @param reader
	 * @param type
	 * @return instance of type
	 */	 */
	public static final <V> V <mark>fromJson</mark>(Reader reader, Class<V> type) {
		return GSON.<mark>fromJson</mark>(reader, type);
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>betfair_____API-NG-sample-code_____JsonConverter_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/betfair_____API-NG-sample-code_____JsonConverter.java

com.google.gson.Gson.fromJson

/**
     * This method serializes the specified object into its equivalent Json representation.
     */     */
    public static  <T> T convertFromJson(String toConvert,  Class<T>  clazz){
        return gson.<mark>fromJson</mark>(toConvert, clazz);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>freedomotic_____freedomotic_____Channel_10.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/freedomotic_____freedomotic_____Channel.java

com.google.gson.Gson.fromJson

/**
     * Not implemented.
     */     */
    public Feed getStatusFeed() throws UnirestException, ThingSpeakException {
        String url = APIURL + "/channels/" + this.channelId + "/status.json";
        return gson.<mark>fromJson</mark>(thingRequest(url), Feed.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>actiontech_____dble_____JsonProcessBase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/actiontech_____dble_____JsonProcessBase.java

com.google.gson.Gson.fromJson

/**
     * toBeanformJson
     *
     * @param <T>
     * @param json
     * @param typeSchema
     * @return
     * @Created 2016/9/17
     */     */
    public <T> T toBeanformJson(String json, Type typeSchema) {
        T result = this.gson.<mark>fromJson</mark>(json, typeSchema);

        return result;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____ambari_____ArtifactEntity_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____ambari_____ArtifactEntity.java

com.google.gson.Gson.fromJson

/**
   * Serialize a map of foreign keys to a string.
   *
   * @param foreignKeys  map of foreign keys to values
   *
   * @return string representation of the foreign keys map
   */   */
  public Map<String, Object> getArtifactData() {
    return jsonSerializer.<Map<String, Object>><mark>fromJson</mark>(
        artifactData, Map.class);
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____Commands_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____Commands.java

com.google.gson.Gson.fromJson

/**
     * Returns the json response for the set_light_state command.
     *
     * @param response the json string
     * @return The data object containing the state data from the json string
     */     */
    public SetLedOff setLedOnResponse(String setLedOnResponse) {
        return gsonWithExpose.<mark>fromJson</mark>(setLedOnResponse, SetLedOff.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>cloudsmith_____geppetto_____CatalogJsonSerializer_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/cloudsmith_____geppetto_____CatalogJsonSerializer.java

com.google.gson.Gson.fromJson

/**
	 * Loads a Catalog model from a catalog JSON string.
	 * 
	 */	 */
	public static Catalog load(File jsonFile) throws IOException {
		Reader reader = new BufferedReader(new FileReader(jsonFile));
		try {
			Gson gson = getGSon();
			CatalogImpl md = gson.<mark>fromJson</mark>(reader, CatalogImpl.class);
			return md;
		}
		finally {
			StreamUtil.close(reader);
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>syncthing_____syncthing-android_____RestApi_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/syncthing_____syncthing-android_____RestApi.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * Returns connection info for the local device and all connected devices.
     */     */
    public void getSystemInfo(OnResultListener1<SystemInfo> listener) {
        new GetRequest(mContext, mUrl, GetRequest.URI_SYSTEM, mApiKey, null, result ->
                listener.onResult(<mark>new Gson</mark>().<mark>fromJson</mark>(result, SystemInfo.class)));
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>cloudsmith_____geppetto_____CatalogJsonSerializer_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/cloudsmith_____geppetto_____CatalogJsonSerializer.java

com.google.gson.Gson.fromJson

/**
	 * Loads a Catalog model from a catalog JSON string.
	 * 
	 */	 */
	public static Catalog load(InputStream jsonStream) throws IOException {
		Reader reader = new BufferedReader(new InputStreamReader(jsonStream));
		try {
			Gson gson = getGSon();
			CatalogImpl md = gson.<mark>fromJson</mark>(reader, CatalogImpl.class);
			return md;
		}
		finally {
			StreamUtil.close(reader);
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____Commands_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____Commands.java

com.google.gson.Gson.fromJson

/**
     * Returns the json for the set_brightness command to set the brightness value.
     *
     * @param brightness the brightness value to set
     * @return The json string of the command to send to the device
     */     */
    public SetRelayState setRelayStateResponse(String relayStateResponse) {
        return gsonWithExpose.<mark>fromJson</mark>(relayStateResponse, SetRelayState.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>ribot_____ribot-app-android_____PreferencesHelper_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/ribot_____ribot-app-android_____PreferencesHelper.java

com.google.gson.Gson.fromJson

/**
     * Return the date of the latest successful encounter
     * or null if no encounter has been performed yet on this device.
     */    @Nullable
    public CheckIn getLatestCheckIn() {
        String checkInJson = mPref.getString(PREF_KEY_LATEST_CHECK_IN, null);
        if (checkInJson != null) {
            return mGson.<mark>fromJson</mark>(checkInJson, CheckIn.class);
        }
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>syncthing_____syncthing-android_____RestApi_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/syncthing_____syncthing-android_____RestApi.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * Returns status information about the folder with the given id.
     */     */
    public void getSystemVersion(OnResultListener1<SystemVersion> listener) {
        new GetRequest(mContext, mUrl, GetRequest.URI_VERSION, mApiKey, null, result -> {
            SystemVersion systemVersion = <mark>new Gson</mark>().<mark>fromJson</mark>(result, SystemVersion.class);
            listener.onResult(systemVersion);
        });
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>winder_____Universal-G-Code-Sender_____FirmwareUtils_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/winder_____Universal-G-Code-Sender_____FirmwareUtils.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * Copy any missing files from the the jar's resources/firmware_config/ dir
     * into the settings/firmware_config dir.
     */        }
        public void reload() {
            try {
                loader = <mark>new Gson</mark>().<mark>fromJson</mark>(new FileReader(file), ControllerSettings.class);
            } catch (FileNotFoundException ex) {
                logger.log(Level.SEVERE, null, ex);
            }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openimaj_____openimaj_____ImgurClient_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openimaj_____openimaj_____ImgurClient.java

com.google.gson.Gson.fromJson

/**
	 * Calls http://imgur.com/gallery.json
	 * 
	 * @return the json response
	 */	 */
	public ImageResponse getSingleImage(String hash) throws ClientProtocolException, IOException {
		final HttpGet get = new HttpGet(String.format("%s/image/%s.json", ENDPOINT, hash));
		final HttpResponse response = client.execute(get);
		final ImgurResponse resp = gson.<mark>fromJson</mark>(new InputStreamReader(response.getEntity().getContent()),
				ImgurResponse.class);
		return resp.image;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____Commands_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____Commands.java

com.google.gson.Gson.fromJson

/**
     * Returns the json for the set_light_state command to switch a bulb on or off.
     *
     * @param onOff the switch state to set
     * @param transitionPeriod the transition period for the action to take place
     * @return The json string of the command to send to the device
     */     */
    public SetSwitchState setSwitchStateResponse(String switchStateResponse) {
        return gsonWithExpose.<mark>fromJson</mark>(switchStateResponse, SetSwitchState.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>ContainerSolutions_____minimesos_____MarathonContainer_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/ContainerSolutions_____minimesos_____MarathonContainer.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * Replaces ${MINIMESOS_[ROLE]}, ${MINIMESOS_[ROLE]_IP} and ${MINIMESOS_[ROLE]_PORT} tokens in the given string with actual values.
     * Also supports ${NETWORK_GATEWAY}
     *
     * @param source string to replace values in
     * @return updated string
     */
    private Group constructGroup(String groupJson) {
        Gson gson = <mark>new Gson</mark>();
        return gson.<mark>fromJson</mark>(replaceTokens(groupJson), Group.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____Commands_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____Commands.java

com.google.gson.Gson.fromJson

/**
     * Returns the json for the set_relay_state command to switch on or off.
     *
     * @param onOff the switch state to set
     * @return The json string of the command to send to the device
     */    @SuppressWarnings("null")
    public Realtime getRealtimeResponse(String realtimeResponse) {
        GetRealtime getRealtime = gson.<mark>fromJson</mark>(realtimeResponse, GetRealtime.class);
        return getRealtime == null ? new Realtime() : getRealtime.getRealtime();
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____Commands_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____Commands.java

com.google.gson.Gson.fromJson

/**
     * Returns the json for the set_switch_state command to switch a dimmer on or off.
     *
     * @param onOff the switch state to set
     * @return The json string of the command to send to the device
     */    @SuppressWarnings("null")
    public Sysinfo getSysinfoReponse(String getSysinfoReponse) {
        GetSysinfo getSysinfo = gson.<mark>fromJson</mark>(getSysinfoReponse, GetSysinfo.class);
        return getSysinfo == null ? new Sysinfo() : getSysinfo.getSysinfo();
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____Commands_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____Commands.java

com.google.gson.Gson.fromJson

/**
     * Returns the json for the set_light_State command to set the brightness.
     *
     * @param brightness the brightness value
     * @param transitionPeriod the transition period for the action to take place
     * @return The json string of the command to send to the device
     */     */
    public HasErrorResponse setDimmerBrightnessResponse(String dimmerBrightnessResponse) {
        return gsonWithExpose.<mark>fromJson</mark>(dimmerBrightnessResponse, SetBrightness.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____ambari_____JSONRequest_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____ambari_____JSONRequest.java

com.google.gson.Gson.fromJson

/**
   * @see #post(WebResource, MultivaluedMapImpl)
   */   */
  public RESPONSE get(WebResource resource) throws IOException {
    LOG.info("GET {}", resource);

    InputStream inputStream = readFrom(resource, "GET", null, new HashMap<String, String>());

    recordLastCurlCommand(String.format("curl \"" + resource.toString() + "\""));
    String responseJson = IOUtils.toString(inputStream);
    LOG.debug("RESPONSE {}", responseJson);
    return gson.<mark>fromJson</mark>(responseJson, responseClass);
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>freedomotic_____freedomotic_____Channel_8.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/freedomotic_____freedomotic_____Channel.java

com.google.gson.Gson.fromJson

/**
     * Get channel status updates. Uses the default feed options.
     *
     * @return Status feed.
     * @throws UnirestException The request cannot be made.
     * @throws ThingSpeakException The request is invalid.
     */     */
    public Entry getLastFieldEntry(Integer fieldId) throws UnirestException, ThingSpeakException {
        String url = APIURL + "/channels/" + this.channelId + "/field/" + fieldId + "/last.json";
        return gson.<mark>fromJson</mark>(thingRequest(url), Entry.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>freedomotic_____freedomotic_____Channel_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/freedomotic_____freedomotic_____Channel.java

com.google.gson.Gson.fromJson

/**
     * Get a field feed with default feed options.
     *
     * @param fieldId The field to include in the field (1-8).
     * @return Feed.
     * @throws UnirestException The request cannot be made.
     * @throws ThingSpeakException The request is invalid.
     */     */
    public Entry getLastChannelEntry() throws UnirestException, ThingSpeakException {
        String url = APIURL + "/channels/" + this.channelId + "/feed/last.json";
        return gson.<mark>fromJson</mark>(thingRequest(url), Entry.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matrix-org_____matrix-android-sdk_____JsonUtils_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/matrix-org_____matrix-android-sdk_____JsonUtils.java

com.google.gson.Gson.fromJson

/**
     * Convert a JSON object to an Event.
     * The result is never null.
     *
     * @param jsonObject the json to convert
     * @return an Event
     */    @Nullable
    public static String getMessageMsgType(JsonElement jsonObject) {
        try {
            Message message = gson.<mark>fromJson</mark>(jsonObject, Message.class);
            return message.msgtype;
        } catch (Exception e) {
            Log.e(LOG_TAG, "## getMessageMsgType failed " + e.getMessage(), e);
        }

        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>iFixit_____iFixitAndroid_____JSONHelper_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/iFixit_____iFixitAndroid_____JSONHelper.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson
com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson
com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
    * Parsing list of UserImageInfo.
    */
   private static ArrayList<Document> parseDocuments(JSONArray documents) throws JSONException {
      ArrayList<Document> result = new ArrayList<>();
      for (int i = 0; i < documents.length(); i++) {
         result.add(<mark>new Gson</mark>().<mark>fromJson</mark>(documents.getJSONObject(i).toString(), Document.class));
      }

      return result;
   }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>tumblr_____jumblr_____ResponseWrapper_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/tumblr_____jumblr_____ResponseWrapper.java

com.google.gson.JsonObject.get
com.google.gson.reflect.TypeToken<java.util.List<com.tumblr.jumblr.types.Blog>>.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.List<com.tumblr.jumblr.types.Blog>>.getType
com.google.gson.Gson.fromJson

/**
     **
     **/    // NOTE: needs to be duplicated logic due to Java erasure of generic types
    public List<Post> getTaggedPosts() {
        Gson gson = gsonParser();
        List<Post> l = gson.<mark>fromJson</mark>(response.getAsJsonArray(), new TypeToken<List<Post>>() {}.<mark>getType</mark>());
        for (Post e : l) { e.setClient(client); }
        return l;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dexter_____dexter_____DexterRestClient_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/dexter_____dexter_____DexterRestClient.java

com.google.gson.Gson.fromJson

/**
	 * Given an entity, returns the entities linked by given entity
	 * 
	 * @param id
	 *            the Wiki-id of the entity
	 * @returns the entities linked by the given entity
	 */	 */
	public ArticleDescription getDesc(int id) {

		String json = "";
		try {
			json = browser.fetchAsUTF8String(
					server.toString() + "/get-desc?id=" + id).toString();
		} catch (IOException e) {
			logger.error("cannot call the rest api {}", e.toString());
			return null;
		}
		ArticleDescription ad = gson.<mark>fromJson</mark>(json, ArticleDescription.class);
		return ad;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>freedomotic_____freedomotic_____Channel_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/freedomotic_____freedomotic_____Channel.java

com.google.gson.Gson.fromJson

/**
     * Get the last entry in a field feed with default feed options. 
     *
     * @param fieldId The field to return (0-8).
     * @return Last entry for the specified field.
     * @throws UnirestException The request cannot be made.
     * @throws ThingSpeakException The request is invalid.
     */     */
    public Feed getFieldFeed(Integer fieldId) throws UnirestException, ThingSpeakException {
        String url = APIURL + "/channels/" + this.channelId + "/field/" + fieldId + ".json";
        return gson.<mark>fromJson</mark>(thingRequest(url), Feed.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>freedomotic_____freedomotic_____Channel_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/freedomotic_____freedomotic_____Channel.java

com.google.gson.Gson.fromJson

/**
     * Get last entry in this channel with default feed options. This is a
     * faster alternative to getting a Channel Feed and then calling
     * {@link Feed#getChannelLastEntry()}.
     *
     * @return Entry.
     * @throws UnirestException The request cannot be made.
     * @throws ThingSpeakException The request is invalid.
     */     */
    public Feed getChannelFeed() throws UnirestException, ThingSpeakException {
        String url = APIURL + "/channels/" + this.channelId + "/feed.json";
        return gson.<mark>fromJson</mark>(thingRequest(url), Feed.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>HiddenStage_____divide_____TransientObject_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/HiddenStage_____divide_____TransientObject.java

com.google.gson.Gson.fromJson

/**
     * Retrieve a specific element from this object.
     * @param clazz type of object to be retrieved. If type given does not match a classcast exception will be thrown.
     * @param key key of object to be retrieved.
     * @return element of type specified corrosponding to the given key.
     */
    protected final <O> O meta_get(Class<O> clazz, MetaKey key){
//        canRead(); TODO disabled for now

        if(clazz.equals(String.class))
            return clazz.cast(meta_data.get(key.KEY));
        else
            return gson.<mark>fromJson</mark>(meta_data.get(key.KEY),clazz);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>freedomotic_____freedomotic_____Channel_9.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/freedomotic_____freedomotic_____Channel.java

com.google.gson.Gson.fromJson

/**
     * Get channel status updates.
     *
     * @param options Only {@link FeedParameters#offset(java.lang.Integer)} is
     * supported.
     * @return Status feed.
     * @throws UnirestException The request cannot be made.
     * @throws ThingSpeakException The request is invalid.
     */     */
    public Entry getLastFieldEntry(Integer fieldId, FeedParameters options) throws UnirestException, ThingSpeakException {
        String url = APIURL + "/channels/" + this.channelId + "/field/" + fieldId + "/last.json";
        return gson.<mark>fromJson</mark>(thingRequest(url, options), Entry.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>freedomotic_____freedomotic_____Channel_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/freedomotic_____freedomotic_____Channel.java

com.google.gson.Gson.fromJson

/**
     * Get a field feed with additional feed options.
     *
     * @param fieldId The field to include in the field (1-8).
     * @param options Optional parameters that control the format of the feed.
     * @return Feed.
     * @throws UnirestException The request cannot be made.
     * @throws ThingSpeakException The request is invalid.
     */     */
    public Entry getLastChannelEntry(FeedParameters options) throws UnirestException, ThingSpeakException {
        String url = APIURL + "/channels/" + this.channelId + "/feed/last.json";
        return gson.<mark>fromJson</mark>(thingRequest(url, options), Entry.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>AzureAD_____azure-activedirectory-library-for-android_____DefaultTokenCacheStore_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/AzureAD_____azure-activedirectory-library-for-android_____DefaultTokenCacheStore.java

com.google.gson.Gson.fromJson

/**
     * Unique users with tokens.
     *
     * @return unique users
     */    @Override
    public TokenCacheItem getItem(String key) {
        if (key == null) {
            throw new IllegalArgumentException("The key is null.");
        }

        if (mPrefs.contains(key)) {
            String json = mPrefs.getString(key);
            json = null != json ? json : "";
            String decrypted = decrypt(key, json);
            if (decrypted != null) {
                return mGson.<mark>fromJson</mark>(decrypted, TokenCacheItem.class);
            }
        }

        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>linkedin_____gobblin_____CopyEntity_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/linkedin_____gobblin_____CopyEntity.java

com.google.gson.reflect.TypeToken<java.util.List<org.apache.gobblin.data.management.copy.CopyEntity>>.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.List<org.apache.gobblin.data.management.copy.CopyEntity>>.getType
com.google.gson.Gson.fromJson

/**
   * Converts package name in serialized string to new name.
   * This is temporary change and should get removed after all the states are switched from old to new package name.
   * @param serialized serialized string possibly having old package names
   * @return
   */   */
  public static CopyEntity deserialize(String serialized) {
    return GSON.<mark>fromJson</mark>(getSerializedWithNewPackage(serialized), CopyEntity.class);
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____NeeoBrainApi_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____NeeoBrainApi.java

com.google.gson.Gson.fromJson

/**
     * Register our API with the brain's forward actions.
     *
     * @param url the non-null URL to register to
     * @throws IOException Signals that an I/O exception has occurred.
     */     */
    public String[] getActiveScenarios() throws IOException {
        final String url = urlBuilder.append(NeeoConstants.GET_ACTIVESCENARIOS).toString();

        final HttpRequest rqst = request.get();
        final HttpResponse resp = rqst.sendGetCommand(url);
        if (resp.getHttpCode() != HttpStatus.OK_200) {
            throw resp.createException();
        }

        return gson.<mark>fromJson</mark>(resp.getContent(), String[].class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>MovingBlocks_____Terasology_____Config_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/MovingBlocks_____Terasology_____Config.java

com.google.gson.Gson.fromJson

/**
     * @param generatorUri the generator Uri
     * @param configs      the new config params for the world generator
     */
    public void load() {
        JsonObject jsonConfig = loadDefaultToJson();
        Optional<JsonObject> defaultsConfig = loadFileToJson(getOverrideDefaultConfigFile());
        if (defaultsConfig.isPresent()) {
            merge(jsonConfig, defaultsConfig.get());
        }
        Optional<JsonObject> userConfig = loadFileToJson(getConfigFile());
        if (userConfig.isPresent()) {
            merge(jsonConfig, userConfig.get());
        }

        config = createGson().<mark>fromJson</mark>(jsonConfig, RootConfig.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>syncthing_____syncthing-android_____RestApi_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/syncthing_____syncthing-android_____RestApi.java

com.google.gson.JsonParser.&ltinit&gt
com.google.gson.JsonParser.parse
com.google.gson.JsonArray.size
com.google.gson.JsonArray.get
com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * Normalizes a given device ID.
     */     */
    public void getFolderStatus(final String folderId, final OnResultListener2<String, FolderStatus> listener) {
        new GetRequest(mContext, mUrl, GetRequest.URI_STATUS, mApiKey,
                    ImmutableMap.of("folder", folderId), result -> {
            FolderStatus m = <mark>new Gson</mark>().<mark>fromJson</mark>(result, FolderStatus.class);
            mCachedFolderStatuses.put(folderId, m);
            listener.onResult(folderId, m);
        });
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>pahimar_____Equivalent-Exchange-3_____SerializationHelper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/pahimar_____Equivalent-Exchange-3_____SerializationHelper.java

com.google.gson.Gson.fromJson

/**
     * TODO Finish JavaDoc
     *
     * @param valueMap
     * @param file
     */     */
    public static Set<WrappedStack> readSetFromFile(File file) {

        Set<WrappedStack> wrappedStackSet = new TreeSet<>();

        try {
            wrappedStackSet = GSON.<mark>fromJson</mark>(readJsonFile(file), WRAPPED_STACK_SET_TYPE);
        }
        catch (JsonParseException exception) {
            LogHelper.error("Unable to parse contents from file '{}'", file.getAbsoluteFile());
        }
        catch (FileNotFoundException e) {
            LogHelper.warn("Unable to find file '{}'", file.getAbsoluteFile());
        }

        return wrappedStackSet;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>freedomotic_____freedomotic_____Channel_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/freedomotic_____freedomotic_____Channel.java

com.google.gson.Gson.fromJson

/**
     * Get the last entry in a field feed with additional feed options.     
     *
     * @param fieldId The field to return (0-8).
     * @param options Supported options: offset, status, and location.
     * @return Last entry for the specified field.
     * @throws UnirestException The request cannot be made.
     * @throws ThingSpeakException The request is invalid.
     */     */
    public Feed getFieldFeed(Integer fieldId, FeedParameters options) throws UnirestException, ThingSpeakException {
        String url = APIURL + "/channels/" + this.channelId + "/field/" + fieldId + ".json";
        return gson.<mark>fromJson</mark>(thingRequest(url, options), Feed.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>freedomotic_____freedomotic_____Channel_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/freedomotic_____freedomotic_____Channel.java

com.google.gson.Gson.fromJson

/**
     * Get last entry in this channel with additional feed options. This is a
     * faster alternative to getting a Channel Feed and then calling
     * {@link Feed#getChannelLastEntry()}
     *
     * @param options Supported options: offset, status, and location.
     * @return Entry.
     * @throws UnirestException The request cannot be made.
     * @throws ThingSpeakException The request is invalid.
     */     */
    public Feed getChannelFeed(FeedParameters options) throws UnirestException, ThingSpeakException {
        String url = APIURL + "/channels/" + this.channelId + "/feed.json";
        return gson.<mark>fromJson</mark>(thingRequest(url, options), Feed.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____ambari_____BlueprintImpl_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____ambari_____BlueprintImpl.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
   * Create host group entities and add to the parent blueprint entity.
   */   */
  private Map<String, Set<HashMap<String, String>>> parseSetting(Collection<BlueprintSettingEntity> blueprintSetting) {

    Map<String, Set<HashMap<String, String>>> properties = new HashMap<>();
    Gson gson = <mark>new Gson</mark>();
    for (BlueprintSettingEntity setting : blueprintSetting) {
      String settingName = setting.getSettingName();
      Set<HashMap<String, String>> settingProperties = gson.<Set<HashMap<String, String>>><mark>fromJson</mark>(
              setting.getSettingData(), Set.class);
      properties.put(settingName, settingProperties);
    }
    return properties;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>eclipse_____smarthome_____OpenWeatherMapConnection_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/eclipse_____smarthome_____OpenWeatherMapConnection.java

com.google.gson.Gson.fromJson

/**
     * Downloads the icon for the given icon id (see https://openweathermap.org/weather-conditions).
     *
     * @param iconId the id of the icon
     * @return the weather icon as {@link RawType}
     */     */
    public synchronized @Nullable OpenWeatherMapJsonUVIndexData getUVIndexData(@Nullable PointType location)
            throws JsonSyntaxException, OpenWeatherMapCommunicationException, OpenWeatherMapConfigurationException {
        return gson.<mark>fromJson</mark>(
                getResponseFromCache(
                        buildURL(UVINDEX_URL, getRequestParams(handler.getOpenWeatherMapAPIConfig(), location))),
                OpenWeatherMapJsonUVIndexData.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____ambari_____BlueprintImpl_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____ambari_____BlueprintImpl.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
   * Process cluster scoped configuration attributes contained in blueprint.
   *
   * @return cluster scoped property attributes contained within in blueprint
   */   */
  private Map<String, Map<String, String>> parseConfigurations(Collection<BlueprintConfigEntity> configs) {

    Map<String, Map<String, String>> properties = new HashMap<>();
    Gson gson = <mark>new Gson</mark>();
    for (BlueprintConfiguration config : configs) {
      String type = config.getType();
      Map<String, String> typeProperties = gson.<Map<String, String>><mark>fromJson</mark>(
              config.getConfigData(), Map.class);
      properties.put(type, typeProperties);
    }
    return properties;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dexter_____dexter_____DexterRestClient_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/dexter_____dexter_____DexterRestClient.java

com.google.gson.Gson.fromJson

/**
	 * Given an entity, returns the entities linked by given entity
	 * 
	 * @param id
	 *            the Wiki-id of the entity
	 * @returns the entities linked by the given entity
	 */	 */
	public ArticleDescription getSourceEntities(int entityId) {

		String json = "";
		try {
			StringBuffer sb = new StringBuffer(server.toString()
					+ "/get-source-entities");
			sb.append("?id=" + entityId);
			sb.append("&wn=" + String.valueOf(wikinames));
			json = browser.fetchAsUTF8String(sb.toString()).toString();
		} catch (IOException e) {
			logger.error("cannot call the rest api {}", e.toString());
			return null;
		}
		ArticleDescription ad = gson.<mark>fromJson</mark>(json, ArticleDescription.class);
		return ad;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____NeeoBrainApi_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____NeeoBrainApi.java

com.google.gson.Gson.fromJson

/**
     * Execute the specified recipe in the specified room
     *
     * @param roomKey the non-empty room key
     * @param recipeKey the non-empty recipe key
     * @return the execute result
     * @throws IOException Signals that an I/O exception has occurred.
     */     */
    public NeeoBrain getBrain() throws IOException {
        final String url = urlBuilder.append(NeeoConstants.PROJECTS_HOME).toString();

        final HttpRequest rqst = request.get();
        final HttpResponse resp = rqst.sendGetCommand(url);
        if (resp.getHttpCode() != HttpStatus.OK_200) {
            throw resp.createException();
        }

        return gson.<mark>fromJson</mark>(resp.getContent(), NeeoBrain.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>dexter_____dexter_____DexterRestClient_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/dexter_____dexter_____DexterRestClient.java

com.google.gson.Gson.fromJson

/**
	 * Given the Wiki-id entity label (the title, or a redirect), the wiki-id of
	 * the entity
	 * 
	 * @param title
	 *            the label or a redirect title of the entity.
	 * @returns the wiki-id of the entity
	 */	 */
	public ArticleDescription getTargetEntities(int entityId) {

		String json = "";
		try {
			StringBuffer sb = new StringBuffer(server.toString()
					+ "/get-target-entities");
			sb.append("?id=" + entityId);
			sb.append("&wn=" + String.valueOf(wikinames));
			json = browser.fetchAsUTF8String(sb.toString()).toString();
		} catch (IOException e) {
			logger.error("cannot call the rest api {}", e.toString());
			return null;
		}
		ArticleDescription ad = gson.<mark>fromJson</mark>(json, ArticleDescription.class);
		return ad;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>mitreid-connect_____OpenID-Connect-Java-Spring-Server_____JsonUtils_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/mitreid-connect_____OpenID-Connect-Java-Spring-Server_____JsonUtils.java

com.google.gson.JsonObject.has
com.google.gson.JsonObject.get
com.google.gson.JsonObject.get
com.google.gson.reflect.TypeToken<java.util.List<java.lang.String>>.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.List<java.lang.String>>.getType
com.google.gson.Gson.fromJson
com.google.gson.JsonObject.get

/**
	 * Gets the value of the given member as a list of JWS Algorithms, null if it doesn't exist
	 */	 */
	public static Set<String> getAsStringSet(JsonObject o, String member) throws JsonSyntaxException {
		if (o.<mark>has</mark>(member)) {
			if (o.<mark>get</mark>(member).isJsonArray()) {
				return gson.<mark>fromJson</mark>(o.<mark>get</mark>(member), new TypeToken<Set<String>>(){}.<mark>getType</mark>());
			} else {
				return Sets.newHashSet(o.<mark>get</mark>(member).getAsString());
			}
		} else {
			return null;
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>googlesamples_____io2014-codelabs_____DeviceSubscription_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/googlesamples_____io2014-codelabs_____DeviceSubscription.java

com.google.gson.Gson.fromJson
com.google.gson.Gson.toJson

/**
   * Deletes an entity corresponding to the provided deviceId.
   *
   * @param deviceId the device id for which all subscription information are to be deleted
   */   */
  public Set<String> getSubscriptionIds(String deviceId) {
    if (StringUtility.isNullOrEmpty(deviceId)) {
      return new HashSet<String>();
    }
    Entity deviceSubscription = get(deviceId);

    if (deviceSubscription == null) {
      return new HashSet<String>();
    }

    String subscriptionString = (String) deviceSubscription.getProperty(PROPERTY_SUBSCRIPTION_IDS);
    if (StringUtility.isNullOrEmpty(subscriptionString)) {
      return new HashSet<String>();
    }

    return this.gson.<mark>fromJson</mark>(subscriptionString, setType);
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matrix-org_____matrix-android-sdk_____JsonUtils_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/matrix-org_____matrix-android-sdk_____JsonUtils.java

com.google.gson.Gson.fromJson

/**
     * Convert an Event instance to a Json object.
     *
     * @param event the event instance.
     * @return the json object
     */     */
    public static <T> T toClass(JsonElement jsonObject, Class<T> aClass) {
        T object = null;
        try {
            object = gson.<mark>fromJson</mark>(jsonObject, aClass);
        } catch (Exception e) {
            Log.e(LOG_TAG, "## toClass failed " + e.getMessage(), e);
        }
        if (null == object) {
            try {
                final Constructor<T> constructor = aClass.getConstructor();
                object = constructor.newInstance();
            } catch (Throwable t) {
                Log.e(LOG_TAG, "## toClass failed " + t.getMessage(), t);
            }
        }
        return object;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>android10_____Android-CleanArchitecture_____UserEntityJsonMapper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/android10_____Android-CleanArchitecture_____UserEntityJsonMapper.java

com.google.gson.reflect.TypeToken<java.util.List<com.fernandocejas.android10.sample.data.entity.UserEntity>>.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.List<com.fernandocejas.android10.sample.data.entity.UserEntity>>.getType
com.google.gson.Gson.fromJson

/**
   * Transform from valid json string to List of {@link UserEntity}.
   *
   * @param userListJsonResponse A json representing a collection of users.
   * @return List of {@link UserEntity}.
   * @throws com.google.gson.JsonSyntaxException if the json string is not a valid json structure.
   */   */
  public UserEntity transformUserEntity(String userJsonResponse) throws JsonSyntaxException {
    final Type userEntityType = new TypeToken<UserEntity>() {}.<mark>getType</mark>();
    return this.gson.<mark>fromJson</mark>(userJsonResponse, userEntityType);
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____incubator-brooklyn_____BrooklynApi_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____incubator-brooklyn_____BrooklynApi.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * @deprecated since 0.8.0-incubating. Use {@link #getEntity(Response, GenericType)} instead.
     */
    public static <T> T getEntity(Response response, Class<T> type) {
        if (response instanceof ClientResponse) {
            ClientResponse<?> clientResponse = (ClientResponse<?>) response;
            return clientResponse.getEntity(type);
        } else if (response instanceof BuiltResponse) {
            // Handle BuiltResponsePreservingError turning objects into Strings
            if (response.getEntity() instanceof String && !type.equals(String.class)) {
                return <mark>new Gson</mark>().<mark>fromJson</mark>(response.getEntity().toString(), type);
            }
        }
        // Last-gasp attempt.
        return type.cast(response.getEntity());
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____ambari_____JSONRequest_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____ambari_____JSONRequest.java

com.google.gson.Gson.fromJson

/**
   * @see #delete(WebResource, MultivaluedMapImpl)
   */   */
  public RESPONSE put(WebResource resource, MultivaluedMapImpl data) throws IOException {
    LOG.info("PUT {}", resource);

    StringBuilder curlBuilder = new StringBuilder();

    UriBuilder builder = getUriBuilder(data, curlBuilder);

    Map<String, String> headers = new HashMap<String, String>();
    headers.put("Content-Type", "application/x-www-form-urlencoded");

    recordLastCurlCommand(String.format("curl -X PUT " + curlBuilder.toString() + " \"" + resource.toString() + "\""));

    InputStream inputStream = readFrom(resource, "PUT", builder.build().getRawQuery(), headers);
    String responseJson = IOUtils.toString(inputStream);

    LOG.debug("RESPONSE => {}", responseJson);
    return gson.<mark>fromJson</mark>(responseJson, responseClass);
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>anupcowkur_____Reservoir_____Reservoir_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/anupcowkur_____Reservoir_____Reservoir.java

com.google.gson.Gson.fromJson

/**
     * Get an object from Reservoir with the given key asynchronously.
     *
     * @param <T>      the type of the object to get.
     * @param key      the key string.
     * @param classOfT the class type of the expected return object.
     * @param callback a callback of type {@link com.anupcowkur.reservoir.ReservoirGetCallback}
     *                 which is called upon completion.
     * @throws IllegalStateException thrown if init method hasn't been called.
     */     */
    public static <T> T get(final String key, final Class<T> classOfT) throws IOException {
        failIfNotInitialised();
        String json = cache.getString(key).getString();
        T value = sGson.<mark>fromJson</mark>(json, classOfT);
        if (value == null)
            throw new NullPointerException();
        return value;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____NeeoBrainApi_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____NeeoBrainApi.java

com.google.gson.Gson.fromJson

/**
     * Stops the specified scenario in the specified room
     *
     * @param roomKey the non-empty room key
     * @param scenarioKey the non-empty scenario key
     * @return the execute result
     * @throws IOException Signals that an I/O exception has occurred.
     */     */
    public NeeoRoom getRoom(String roomKey) throws IOException {
        NeeoUtil.requireNotEmpty(roomKey, "roomKey cannot be empty");

        final String url = urlBuilder.append(NeeoConstants.GET_ROOM).sub("roomkey", roomKey).toString();

        final HttpRequest rqst = request.get();
        final HttpResponse resp = rqst.sendGetCommand(url);
        if (resp.getHttpCode() != HttpStatus.OK_200) {
            throw resp.createException();
        }

        return gson.<mark>fromJson</mark>(resp.getContent(), NeeoRoom.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____ambari_____RangerPasswordCheck_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____ambari_____RangerPasswordCheck.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
   * Generates a list of headers, including {@code Basic} authentication
   * @param username  the username
   * @param password  the password
   * @return the map of headers
   */   */
  private int checkLogin(URLStreamProvider streamProvider, String url, String username,
      String password) throws IOException {

    Map<String, List<String>> headers = getHeaders(username, password);

    HttpURLConnection conn = streamProvider.processURL(url, "GET", (InputStream) null, headers);

    int result = conn.getResponseCode();

    // !!! see javadoc
    if (result == 200) {
      Gson gson = <mark>new Gson</mark>();
      try {
        gson.<mark>fromJson</mark>(new InputStreamReader(conn.getInputStream()), Object.class);
      } catch (Exception e) {
        result = 401;
      }
    }

    return result;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>sromku_____android-simple-facebook_____JsonUtils_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/sromku_____android-simple-facebook_____JsonUtils.java

com.google.gson.JsonParser.&ltinit&gt
com.google.gson.JsonParser.parse
com.google.gson.Gson.fromJson

/**
     * Get JSON string and convert to T (Object) you need
     *
     * @return Object filled with JSON string data
     */     */
    public static <T> T <mark>fromJson</mark>(String json, Class<T> cls) {
        Gson gson = buildGson();

        JsonParser parser = <mark>new JsonParser</mark>();
        JsonElement element = parser.<mark>parse</mark>(json);

        // check if the Class type is array but the Json is an object
        if (cls != null && cls.isArray() && element instanceof JsonArray == false) {
            JsonArray jsonArray = new JsonArray();
            jsonArray.add(element);

            Type listType = new TypeToken<T>() {
            }.getType();
            return gson.<mark>fromJson</mark>(jsonArray, listType);
        }

        return gson.<mark>fromJson</mark>(json, cls);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____NeeoBrainApi_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____NeeoBrainApi.java

com.google.gson.Gson.fromJson

/**
     * Gets the active scenarios.
     *
     * @return the non-null, possibly empty list of active scenarios keys
     * @throws IOException Signals that an I/O exception has occurred.
     */     */
    ExecuteResult executeRecipe(String roomKey, String recipeKey) throws IOException {
        NeeoUtil.requireNotEmpty(roomKey, "roomKey cannot be empty");
        NeeoUtil.requireNotEmpty(recipeKey, "recipeKey cannot be empty");

        final String url = urlBuilder.append(NeeoConstants.EXECUTE_RECIPE).sub("roomkey", roomKey)
                .sub("recipekey", recipeKey).toString();

        final HttpRequest rqst = request.get();
        final HttpResponse resp = rqst.sendGetCommand(url);
        if (resp.getHttpCode() != HttpStatus.OK_200) {
            throw resp.createException();
        }

        return gson.<mark>fromJson</mark>(resp.getContent(), ExecuteResult.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>eclipse_____smarthome_____OpenWeatherMapConnection_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/eclipse_____smarthome_____OpenWeatherMapConnection.java

com.google.gson.Gson.fromJson

/**
     * Requests the daily forecast data for the given location (see https://openweathermap.org/forecast16).
     *
     * @param location location represented as {@link PointType}
     * @param count number of days
     * @return the daily forecast data
     * @throws JsonSyntaxException
     * @throws OpenWeatherMapCommunicationException
     * @throws OpenWeatherMapConfigurationException
     */     */
    public synchronized @Nullable OpenWeatherMapJsonWeatherData getWeatherData(@Nullable PointType location)
            throws JsonSyntaxException, OpenWeatherMapCommunicationException, OpenWeatherMapConfigurationException {
        return gson.<mark>fromJson</mark>(
                getResponseFromCache(
                        buildURL(WEATHER_URL, getRequestParams(handler.getOpenWeatherMapAPIConfig(), location))),
                OpenWeatherMapJsonWeatherData.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matrix-org_____matrix-android-sdk_____MXDataHandler_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/matrix-org_____matrix-android-sdk_____MXDataHandler.java

com.google.gson.Gson.toJsonTree
com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String,java.util.List<java.lang.String>>>.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String,java.util.List<java.lang.String>>>.getType
com.google.gson.Gson.fromJson

/**
     * Manage the URL preview flag
     *
     * @param accountDataElement the account data element of correct type
     */     */
    private void managePushRulesUpdate(AccountDataElement accountDataElement) {
        Gson gson = JsonUtils.getGson(false);

        // convert the data to PushRulesResponse
        // because BingRulesManager supports only PushRulesResponse
        JsonElement element = gson.<mark>toJsonTree</mark>(accountDataElement.content);
        getBingRulesManager().buildRules(gson.<mark>fromJson</mark>(element, PushRulesResponse.class));

        // warn the client that the push rules have been updated
        onBingRulesUpdate();
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>IQSS_____dataverse_____DdiExportUtil_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/IQSS_____dataverse_____DdiExportUtil.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * @todo This is just a stub, copied from DDIExportServiceBean. It should
     * produce valid DDI based on
     * http://guides.dataverse.org/en/latest/developers/tools.html#msv but it is
     * incomplete and will be worked on as part of
     * https://github.com/IQSS/dataverse/issues/2579 . We'll want to reference
     * the DVN 3.x code for creating a complete DDI.
     *
     * @todo Rename this from "study" to "dataset".
     */    // "short" ddi, without the "<fileDscr>"  and "<dataDscr>/<var>" sections:
    public static void datasetJson2ddi(JsonObject datasetDtoAsJson, OutputStream outputStream) throws XMLStreamException {
        logger.fine(JsonUtil.prettyPrint(datasetDtoAsJson.toString()));
        Gson gson = <mark>new Gson</mark>();
        DatasetDTO datasetDto = gson.<mark>fromJson</mark>(datasetDtoAsJson.toString(), DatasetDTO.class);
        dtoddi(datasetDto, outputStream);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>zhengxiaopeng_____Rocko-Android-Demos_____UserEntityJsonMapper_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/zhengxiaopeng_____Rocko-Android-Demos_____UserEntityJsonMapper.java

com.google.gson.reflect.TypeToken<java.util.List<com.fernandocejas.android10.sample.data.entity.UserEntity>>.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.List<com.fernandocejas.android10.sample.data.entity.UserEntity>>.getType
com.google.gson.Gson.fromJson

/**
   * Transform from valid json string to List of {@link UserEntity}.
   *
   * @param userListJsonResponse A json representing a collection of users.
   * @return List of {@link UserEntity}.
   * @throws com.google.gson.JsonSyntaxException if the json string is not a valid json structure.
   */   */
  public UserEntity transformUserEntity(String userJsonResponse) throws JsonSyntaxException {
    try {
      Type userEntityType = new TypeToken<UserEntity>() {}.<mark>getType</mark>();
      UserEntity userEntity = this.gson.<mark>fromJson</mark>(userJsonResponse, userEntityType);

      return userEntity;
    } catch (JsonSyntaxException jsonException) {
      throw jsonException;
    }
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>AEFeinstein_____mtg-familiar_____CardAndSetParser_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/AEFeinstein_____mtg-familiar_____CardAndSetParser.java

com.google.gson.stream.JsonReader.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * Parses the legality file and populates the database with the different formats, their respective sets, and their
     * banned and restricted lists
     *
     * @param context   The context to manage preferences with
     * @param logWriter A writer to print debug statements when things go wrong
     * @return An object with all of the legal info, to be added to the database in one fell swoop
     */     */
    public void readCardJsonStream(JsonReader reader, ArrayList<Card> cardsToAdd, ArrayList<Expansion> setsToAdd) {

        Gson gson = CardAndSetParser.getGson();

        Patch patch = gson.<mark>fromJson</mark>(reader, Patch.class);
        if (patch != null) {
            cardsToAdd.addAll(patch.mCards);

            /* Stage the sets and cards for database addition. */
            if (setsToAdd != null) {
                setsToAdd.add(patch.mExpansion);
            }
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>AEFeinstein_____mtg-familiar_____CardAndSetParser_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/AEFeinstein_____mtg-familiar_____CardAndSetParser.java

com.google.gson.stream.JsonReader.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * When the service is done, this method is called to commit the update dates to the shared preferences
     *
     * @param context the Context to manage preferences with
     */     */
    public Manifest readUpdateJsonStream(Context context, PrintWriter logWriter) {
        Manifest manifest;

        try {
            InputStream stream = FamiliarActivity.getHttpInputStream(PATCHES_URL, logWriter, context);
            if (stream == null) {
                throw new IOException("No Stream");
            }
            InputStreamReader isr = new InputStreamReader(stream);

            JsonReader reader = <mark>new JsonReader</mark>(isr);
            Gson gson = CardAndSetParser.getGson();

            manifest = gson.<mark>fromJson</mark>(reader, Manifest.class);
        } catch (IOException e) {
            if (logWriter != null) {
                e.printStackTrace(logWriter);
            }
            manifest = null;
        }
        return manifest;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_7.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.fromJson

/**
     * Activate tenant
     *
     * @param tenantDomain domain name of the tenant
     * @throws CommandException
     */     */
    public void deleteUser(String userName) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doDelete(httpClient, restClient.getBaseURL()
                    + ENDPOINT_ADD_USER + "/" + userName);

            String resultString = CliUtils.getHttpResponseString(response);
            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();
            System.out.println(gson.<mark>fromJson</mark>(resultString, ResponseMessageBean.class).getMessage());
        } catch (Exception e) {
            String message = "Could not delete user: " + userName;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>syncthing_____syncthing-android_____RestApi_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/syncthing_____syncthing-android_____RestApi.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.toJson
com.google.gson.Gson.fromJson

/**
     * Requests and parses information about current system status and resource usage.
     */
    private void onReloadConfigComplete(String result) {
        Boolean configParseSuccess;
        synchronized(mConfigLock) {
            mConfig = <mark>new Gson</mark>().<mark>fromJson</mark>(result, Config.class);
            configParseSuccess = mConfig != null;
        }
        if (!configParseSuccess) {
            throw new RuntimeException("config is null: " + result);
        }
        Log.v(TAG, "onReloadConfigComplete: Successfully parsed configuration.");
        if (BuildConfig.DEBUG) {
            Log.v(TAG, "mConfig.pendingDevices = " + <mark>new Gson</mark>().<mark>toJson</mark>(mConfig.pendingDevices));
            Log.v(TAG, "mConfig.remoteIgnoredDevices = " + <mark>new Gson</mark>().<mark>toJson</mark>(mConfig.remoteIgnoredDevices));
        }

        // Update cached device and folder information stored in the mCompletion model.
        mCompletion.updateFromConfig(getDevices(true), getFolders());
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____NeeoBrainApi_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____NeeoBrainApi.java

com.google.gson.Gson.fromJson

/**
     * Trigger macro on a specified device in the specified room.
     *
     * @param roomKey the non-null room key
     * @param deviceKey the non-null device key
     * @param macroKey the non-null macro key
     * @return the execute result
     * @throws IOException Signals that an I/O exception has occurred.
     */     */
    ExecuteResult stopScenario(String roomKey, String scenarioKey) throws IOException {
        NeeoUtil.requireNotEmpty(roomKey, "roomKey cannot be empty");
        NeeoUtil.requireNotEmpty(scenarioKey, "scenarioKey cannot be empty");

        final String url = urlBuilder.append(NeeoConstants.STOP_SCENARIO).sub("roomkey", roomKey)
                .sub("scenariokey", scenarioKey).toString();

        final HttpRequest rqst = request.get();
        final HttpResponse resp = rqst.sendGetCommand(url);
        if (resp.getHttpCode() != HttpStatus.OK_200) {
            throw resp.createException();
        }

        return gson.<mark>fromJson</mark>(resp.getContent(), ExecuteResult.class);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____ambari_____AbstractKerberosDescriptorFactory_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____ambari_____AbstractKerberosDescriptorFactory.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String,java.lang.Object>>.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String,java.lang.Object>>.getType
com.google.gson.Gson.fromJson

/**
   * Parses a JSON-formatted String into a (generic) Map.
   *
   * @param json a String containing the JSON-formatted text to parse
   * @return a Map of the data
   * @throws AmbariException if an error occurs while parsing the JSON-formatted String
   */   */
  protected Map<String, Object> parseFile(File file) throws IOException {
    if (file == null) {
      return Collections.emptyMap();
    } else if (!file.isFile() || !file.canRead()) {
      throw new IOException(String.format("%s is not a readable file", file.getAbsolutePath()));
    } else {
      try {
        return <mark>new Gson</mark>().<mark>fromJson</mark>(new FileReader(file),
            new TypeToken<Map<String, Object>>() {
            }.<mark>getType</mark>());
      } catch (JsonSyntaxException e) {
        throw new AmbariException(String.format("Failed to parse JSON-formatted file: %s", file.getAbsolutePath()), e);
      }
    }
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>capitalone_____Hydrograph_____ViewExecutionHistoryUtility_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/capitalone_____Hydrograph_____ViewExecutionHistoryUtility.java

com.google.gson.JsonParser.&ltinit&gt
com.google.gson.Gson.&ltinit&gt
com.google.gson.JsonParser.parse
com.google.gson.Gson.fromJson

/**
	 * @param message Display the error message 
	 * 
	 */	 */
	public ExecutionStatus readJsonLogFile(String uniqueJobId, boolean isLocalMode, String filePath, boolean isReplay) throws IOException{
		ExecutionStatus[] executionStatus;
		String jobId = "";
		String path = null;
		String jsonArray = "";
		if(isLocalMode){
			jobId = EXECUTION_TRACKING_LOCAL_MODE + uniqueJobId;
		}else{
			jobId = EXECUTION_TRACKING_REMOTE_MODE + uniqueJobId;
		}
		
		
		if(isReplay){
 			path = filePath + jobId + EXECUTION_TRACKING_LOG_FILE_EXTENTION;
 		}else{
 			path = getLogPath() + jobId + EXECUTION_TRACKING_LOG_FILE_EXTENTION;
 		}
		
		JsonParser jsonParser = <mark>new JsonParser</mark>();
		
		Gson gson = <mark>new Gson</mark>();
		try(Reader fileReader = new FileReader(new File(path));){
			jsonArray = jsonParser.<mark>parse</mark>(fileReader).toString();
		}catch (Exception exception) {
			logger.error("Failed to read file: ", exception);
		}
		
		executionStatus = gson.<mark>fromJson</mark>(jsonArray, ExecutionStatus[].class);
		return executionStatus[executionStatus.length-1];
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>googlesamples_____io2014-codelabs_____SubscriptionRemovalServlet_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/googlesamples_____io2014-codelabs_____SubscriptionRemovalServlet.java

com.google.gson.Gson.fromJson

/**
   * Remove device subscription entities based on input parameters
   * @param req Http request contains parameters 'cursor' and 'timeStamp'. 'Cursor'
   *            provides hint to last query result position.  'TimeStamp' filters out
   *            entities created after delete method was initiated.
   */
  private void removePsiSubscription(HttpServletRequest req) {
    String subIdsParameter = req.getParameter("subIds");
    if (StringUtility.isNullOrEmpty(subIdsParameter)) {
      log.warning("Missing 'subIds' argument on task queue request. This indicates a bug");
      return;
    }

    String[] subIds;
    try {
      subIds = gson.<mark>fromJson</mark>(subIdsParameter, String[].class);
    } catch (JsonSyntaxException e) {
      log.warning("Invalid format of 'subIds' argument on task queue request. " +
          "This indicates a bug");
      return;
    }

    for (String subId : subIds) {
      try {
        prosSearch.unsubscribe(QueryOperations.PROS_SEARCH_DEFAULT_TOPIC, subId);
      } catch (IllegalArgumentException e) {
        log.info("Unsubscribe " + subId + " from PSI encounters error, " + e.getMessage());
      }
    }
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.fromJson

/**
     * Deactivate tenant
     *
     * @param tenantDomain domain name of the tenant
     * @throws CommandException
     */     */
    public void deleteTenant(String tenantDomain) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doDelete(httpClient, restClient.getBaseURL()
                    + ENDPOINT_ADD_TENANT + "/" + tenantDomain);

            String responseCode = "" + response.getStatusLine().getStatusCode();

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            if (responseCode.equals(CliConstants.RESPONSE_OK)) {
                System.out.println("You have successfully deleted the tenant: " + tenantDomain);
            } else {
                String resultString = CliUtils.getHttpResponseString(response);
                ExceptionMapper exception = gson.<mark>fromJson</mark>(resultString, ExceptionMapper.class);
                System.out.println(exception);
            }

        } catch (Exception e) {
            String message = "Could not delete tenant: " + tenantDomain;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_8.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.fromJson

/**
     * List tenants
     *
     * @throws CommandException
     */     */
    public void deactivateTenant(String tenantDomain) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doPut(httpClient, restClient.getBaseURL()
                    + ENDPOINT_DEACTIVATE_TENANT.replace("{tenantDomain}", tenantDomain), "");

            String responseCode = "" + response.getStatusLine().getStatusCode();

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            if (responseCode.equals(CliConstants.RESPONSE_OK)) {
                System.out.println("You have successfully deactivated the tenant: " + tenantDomain);
                return;
            } else {
                String resultString = CliUtils.getHttpResponseString(response);
                String errorMsg = gson.<mark>fromJson</mark>(resultString, ResponseMessageBean.class).getMessage();
                System.out.println(errorMsg);
            }

        } catch (Exception e) {
            String message = "Could not de-activate tenant: " + tenantDomain;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_9.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.fromJson

/**
     * List Kubernetes Hosts
     *
     * @param clusterId cluster id
     * @throws CommandException
     */     */
    public void activateTenant(String tenantDomain) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doPut(httpClient, restClient.getBaseURL()
                    + ENDPOINT_ACTIVATE_TENANT.replace("{tenantDomain}", tenantDomain), "");

            String responseCode = "" + response.getStatusLine().getStatusCode();

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            if (responseCode.equals(CliConstants.RESPONSE_OK)) {
                System.out.println("You have successfully activated the tenant: " + tenantDomain);
            } else {
                String resultString = CliUtils.getHttpResponseString(response);
                String errorMsg = gson.<mark>fromJson</mark>(resultString, ResponseMessageBean.class).getMessage();
                System.out.println(errorMsg);
            }

        } catch (Exception e) {
            String message = "Could not activate tenant: " + tenantDomain;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>matrix-org_____matrix-android-sdk_____JsonUtils_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/matrix-org_____matrix-android-sdk_____JsonUtils.java

com.google.gson.Gson.fromJson

/**
     * Convert a stringified JSON into a class instance.
     * The returned value cannot be null.
     *
     * @param jsonObjectAsString the json object as string to convert
     * @param aClass             the class
     * @return the converted object
     */    @NonNull
    public static Message toMessage(JsonElement jsonObject) {
        try {
            Message message = gson.<mark>fromJson</mark>(jsonObject, Message.class);

            // Try to return the right subclass
            if (Message.MSGTYPE_IMAGE.equals(message.msgtype)) {
                return toImageMessage(jsonObject);
            }

            if (Message.MSGTYPE_VIDEO.equals(message.msgtype)) {
                return toVideoMessage(jsonObject);
            }

            if (Message.MSGTYPE_LOCATION.equals(message.msgtype)) {
                return toLocationMessage(jsonObject);
            }

            // Try to return the right subclass
            if (Message.MSGTYPE_FILE.equals(message.msgtype)) {
                return toFileMessage(jsonObject);
            }

            if (Message.MSGTYPE_AUDIO.equals(message.msgtype)) {
                return toAudioMessage(jsonObject);
            }

            // Fall back to the generic Message type
            return message;
        } catch (Exception e) {
            Log.e(LOG_TAG, "## toMessage failed " + e.getMessage(), e);
        }

        return new Message();
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____DeconzBridgeHandler_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____DeconzBridgeHandler.java

com.google.gson.Gson.fromJson

/**
     * Perform a request to the REST API for retrieving the full bridge state with all sensors and switches
     * and configuration.
     */     */
    private void parseAPIKeyResponse(AsyncHttpClient.Result r) {
        if (r.getResponseCode() == 403) {
            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,
                    "Allow authentification for 3rd party apps. Trying again in " + String.valueOf(POLL_FREQUENCY_SEC)
                            + " seconds");
            stopTimer();
            scheduledFuture = scheduler.schedule(() -> requestApiKey(), POLL_FREQUENCY_SEC, TimeUnit.SECONDS);
        } else if (r.getResponseCode() == 200) {
            ApiKeyMessage[] response = gson.<mark>fromJson</mark>(r.getBody(), ApiKeyMessage[].class);
            if (response.length == 0) {
                throw new IllegalStateException("Authorisation request response is empty");
            }
            config.apikey = response[0].success.username;
            Configuration configuration = editConfiguration();
            configuration.put(CONFIG_APIKEY, config.apikey);
            updateConfiguration(configuration);
            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, "Waiting for configuration");
            requestFullState();
        } else {
            throw new IllegalStateException("Unknown status code for authorisation request");
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>sachin-handiekar_____jInstagram_____InstagramBase_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/sachin-handiekar_____jInstagram_____InstagramBase.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * Creates an object from the JSON response and the class which the object
     * would be mapped to.
     *
     * @param clazz
     *            a class instance
     * @param response
     *            a JSON feed
     * @return a object of type <T>
     * @throws InstagramException
     *             if any error occurs.
     */
	private Exception testResponseBody(Response response) {
		Exception capturedException = null;
		int code = response.getCode();

		try {
			// get response entity, attempt parse as JSON.
			String jsonString = response.getBody();
			<mark>new Gson</mark>().<mark>fromJson</mark>(jsonString, JsonObject.class);
		} catch (IllegalStateException e) {
			// this indicates a socket error (e.g. connection reset) when attempting
			// to read HTTP response entity, capture the latest exception to be thrown
			// at the end
			capturedException = e;
			if (e.getCause() instanceof SocketException) {
				logger.warn(
						format("Socket error with HTTP response (code %d).", code),
						e.getCause());
			} else {
				logger.warn(
						format("IllegalState exception with HTTP response (code %d).", code),
						e.getCause());
			}
		} catch (JsonSyntaxException e) {
			// HTTP response body contained malformed JSON
			logger.warn(
					format("HTTP response body contained malformed JSON (code %d).", code),
					response.getCode());
			capturedException = e;
		}

		return capturedException;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_11.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.fromJson

/**
     * Undeploy application
     *
     * @param applicationId application id
     * @throws CommandException
     */     */
    public void synchronizeArtifacts(String cartridgeAlias) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL() + ENDPOINT_SYNCHRONIZE_ARTIFACTS.replace("{subscriptionAlias}", cartridgeAlias), cartridgeAlias);

            String responseCode = "" + response.getStatusLine().getStatusCode();

            if (responseCode.equals(CliConstants.RESPONSE_OK)) {
                System.out.println(String.format("Synchronizing artifacts for cartridge subscription alias: %s", cartridgeAlias));
            } else {
                GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
                Gson gson = gsonBuilder.<mark>create</mark>();
                String resultString = CliUtils.getHttpResponseString(response);
                ExceptionMapper exception = gson.<mark>fromJson</mark>(resultString, ExceptionMapper.class);
                System.out.println(exception);
            }
        } catch (Exception e) {
            String message = "Could not synchronize artifacts for cartridge subscription alias: " + cartridgeAlias;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>mitreid-connect_____OpenID-Connect-Java-Spring-Server_____BlacklistAPI_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/mitreid-connect_____OpenID-Connect-Java-Spring-Server_____BlacklistAPI.java

com.google.gson.JsonParser.parse
com.google.gson.Gson.fromJson

/**
	 * Delete a blacklisted site
	 *
	 */	@RequestMapping(method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
	public String addNewBlacklistedSite(@RequestBody String jsonString, ModelMap m, Principal p) {

		JsonObject json;

		BlacklistedSite blacklist = null;

		try {

			json = parser.<mark>parse</mark>(jsonString).getAsJsonObject();
			blacklist = gson.<mark>fromJson</mark>(json, BlacklistedSite.class);
			BlacklistedSite newBlacklist = blacklistService.saveNew(blacklist);
			m.put(JsonEntityView.ENTITY, newBlacklist);

		}
		catch (JsonSyntaxException e) {
			logger.error("addNewBlacklistedSite failed due to JsonSyntaxException: ", e);
			m.put(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
			m.put(JsonErrorView.ERROR_MESSAGE, "Could not save new blacklisted site. The server encountered a JSON syntax exception. Contact a system administrator for assistance.");
			return JsonErrorView.VIEWNAME;
		} catch (IllegalStateException e) {
			logger.error("addNewBlacklistedSite failed due to IllegalStateException", e);
			m.put(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
			m.put(JsonErrorView.ERROR_MESSAGE, "Could not save new blacklisted site. The server encountered an IllegalStateException. Refresh and try again - if the problem persists, contact a system administrator for assistance.");
			return JsonErrorView.VIEWNAME;
		}

		return JsonEntityView.VIEWNAME;

	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_10.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.fromJson

/**
     * Add cartridge group
     *
     * @param entityBody cartridge group definition
     * @throws CommandException
     */     */
    public void addKubernetesHost(String entityBody, String clusterId) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL()
                    + ENDPOINT_DEPLOY_KUBERNETES_HOST.replace("{kubernetesClusterId}", clusterId), entityBody);

            String responseCode = "" + response.getStatusLine().getStatusCode();

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            if (responseCode.equals(CliConstants.RESPONSE_OK) || responseCode.equals(CliConstants.RESPONSE_CREATED)) {
                System.out.println("You have successfully deployed host to Kubernetes cluster: " + clusterId);
            } else {
                String resultString = CliUtils.getHttpResponseString(response);
                ExceptionMapper exception = gson.<mark>fromJson</mark>(resultString, ExceptionMapper.class);
                System.out.println(exception);
            }

        } catch (Exception e) {
            String message = "Could not add host to Kubernetes cluster: " + clusterId;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_5.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.fromJson

/**
     * Delete user
     *
     * @param userName username
     * @throws CommandException
     */     */
    public void addUser(String userName, String credential, String role, String firstName, String lastName, String email, String profileName)
            throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            UserInfoBean userInfoBean = new UserInfoBean();
            userInfoBean.setUserName(userName);
            userInfoBean.setCredential(credential);
            userInfoBean.setRole(role);
            userInfoBean.setFirstName(firstName);
            userInfoBean.setLastName(lastName);
            userInfoBean.setEmail(email);
            userInfoBean.setProfileName(profileName);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            String jsonString = gson.toJson(userInfoBean, UserInfoBean.class);

            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL()
                    + ENDPOINT_ADD_USER, jsonString);

            String result = getHttpResponseString(response);
            System.out.println(gson.<mark>fromJson</mark>(result, ResponseMessageBean.class).getMessage());

        } catch (Exception e) {
            String message = "Could not add user: " + userName;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>ccrama_____Slide_____Toolbox_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/ccrama_____Slide_____Toolbox.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * Upload a subreddit's usernotes to the wiki
     *
     * @param subreddit Sub to upload usernotes for
     * @param editReason Reason for the wiki edit
     */     */
    public static void downloadUsernotes(String subreddit) {
        WikiManager manager = new WikiManager(Authentication.reddit);
        Gson gson = new GsonBuilder().registerTypeAdapter(new TypeToken<Map<String, List<Usernote>>>() {}.getType(),
                new Usernotes.BlobDeserializer()).create();
        try {
            String data = manager.get(subreddit, "usernotes").getContent();
            Usernotes result = gson.<mark>fromJson</mark>(data, Usernotes.class);
            cache.edit().putLong(subreddit + "_usernotes_timestamp", System.currentTimeMillis()).apply();
            if (result != null && result.getSchema() == 6) {
                result.setSubreddit(subreddit);
                notes.put(subreddit, result);
                cache.edit().putBoolean(subreddit + "_usernotes_exists", true)
                        .putString(subreddit + "_usernotes_data", data).apply();
            } else {
                cache.edit().putBoolean(subreddit + "_usernotes_exists", false).apply();
            }
        } catch (NetworkException | JsonParseException e) {
            if (e instanceof JsonParseException) {
                notes.remove(subreddit);
            }
            cache.edit().putLong(subreddit + "_usernotes_timestamp", System.currentTimeMillis())
                    .putBoolean(subreddit + "_usernotes_exists", false).apply();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>mitreid-connect_____OpenID-Connect-Java-Spring-Server_____WhitelistAPI_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/mitreid-connect_____OpenID-Connect-Java-Spring-Server_____WhitelistAPI.java

com.google.gson.JsonParser.parse
com.google.gson.Gson.fromJson

/**
	 * Delete a whitelisted site
	 *
	 */	@RequestMapping(method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
	public String addNewWhitelistedSite(@RequestBody String jsonString, ModelMap m, Principal p) {

		JsonObject json;

		WhitelistedSite whitelist = null;
		try {
			json = parser.<mark>parse</mark>(jsonString).getAsJsonObject();
			whitelist = gson.<mark>fromJson</mark>(json, WhitelistedSite.class);

		} catch (JsonParseException e) {
			logger.error("addNewWhitelistedSite failed due to JsonParseException", e);
			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
			m.addAttribute(JsonErrorView.ERROR_MESSAGE, "Could not save new whitelisted site. The server encountered a JSON syntax exception. Contact a system administrator for assistance.");
			return JsonErrorView.VIEWNAME;
		} catch (IllegalStateException e) {
			logger.error("addNewWhitelistedSite failed due to IllegalStateException", e);
			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
			m.addAttribute(JsonErrorView.ERROR_MESSAGE, "Could not save new whitelisted site. The server encountered an IllegalStateException. Refresh and try again - if the problem persists, contact a system administrator for assistance.");
			return JsonErrorView.VIEWNAME;
		}

		// save the id of the person who created this
		whitelist.setCreatorUserId(p.getName());

		WhitelistedSite newWhitelist = whitelistService.saveNew(whitelist);

		m.put(JsonEntityView.ENTITY, newWhitelist);

		return JsonEntityView.VIEWNAME;

	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>syncthing_____syncthing-android_____RestApi_6.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/syncthing_____syncthing-android_____RestApi.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
         * Called for each event.
         */     */
    public void getConnections(final OnResultListener1<Connections> listener) {
        new GetRequest(mContext, mUrl, GetRequest.URI_CONNECTIONS, mApiKey, null, result -> {
            Long now = System.currentTimeMillis();
            Long msElapsed = now - mPreviousConnectionTime;
            if (msElapsed < Constants.GUI_UPDATE_INTERVAL) {
                listener.onResult(deepCopy(mPreviousConnections.get(), Connections.class));
                return;
            }

            mPreviousConnectionTime = now;
            Connections connections = <mark>new Gson</mark>().<mark>fromJson</mark>(result, Connections.class);
            for (Map.Entry<String, Connections.Connection> e : connections.connections.entrySet()) {
                e.getValue().completion = mCompletion.getDeviceCompletion(e.getKey());

                Connections.Connection prev =
                        (mPreviousConnections.isPresent() && mPreviousConnections.get().connections.containsKey(e.getKey()))
                                ? mPreviousConnections.get().connections.get(e.getKey())
                                : new Connections.Connection();
                e.getValue().setTransferRate(prev, msElapsed);
            }
            Connections.Connection prev =
                    mPreviousConnections.transform(c -> c.total).or(new Connections.Connection());
            connections.total.setTransferRate(prev, msElapsed);
            mPreviousConnections = Optional.of(connections);
            listener.onResult(deepCopy(connections, Connections.class));
        });
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____RESTApi_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____RESTApi.java

com.google.gson.Gson.fromJson
com.google.gson.JsonParseException.&ltinit&gt
com.google.gson.stream.JsonWriter.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.List<?>>.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.List<?>>.getType
com.google.gson.Gson.toJson

/**
     * Update changing parameters of the data store like the time.
     */     */
    public int handleConfig(HttpMethod method, String body, Writer out, Path remainingPath, String authorizedUser)
            throws IOException, JsonParseException {
        if (remainingPath.getNameCount() == 0) {
            switch (method) {
                case GET:
                    out.write(gson.<mark>toJson</mark>(ds.config));
                    return 200;
                case PUT:
                    final HueChangeRequest changes;
                    changes = gson.<mark>fromJson</mark>(body, HueChangeRequest.class);
                    if (changes.devicename != null) {
                        ds.config.devicename = changes.devicename;
                    }
                    if (changes.dhcp != null) {
                        ds.config.dhcp = changes.dhcp;
                    }
                    if (changes.linkbutton != null) {
                        ds.config.linkbutton = changes.linkbutton;
                        configManagement.checkPairingTimeout();
                    }
                    configManagement.writeToFile();
                    return 200;
                default:
                    return 405;
            }
        } else if (remainingPath.getNameCount() >= 1 && "whitelist".equals(remainingPath.getName(0).toString())) {
            return handleConfigWhitelist(method, out, remaining(remainingPath), authorizedUser);
        } else {
            return 404;
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>ram-on_____SkyTube_____BookmarksDb_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/ram-on_____SkyTube_____BookmarksDb.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.reflect.TypeToken<free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo>.&ltinit&gt
com.google.gson.reflect.TypeToken<free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo>.getType
com.google.gson.Gson.fromJson

/**
	 * Add a Listener that will be notified when a Video is added or removed from Bookmarked Videos. This will
	 * allow the Video Grid to be redrawn in order to remove the video from display.
	 *
	 * @param listener The Listener (which implements BookmarksDbListener) to add.
	 */	 */
	public boolean remove(YouTubeVideo video) {
		int rowsDeleted = getWritableDatabase().delete(BookmarksTable.TABLE_NAME,
						BookmarksTable.COL_YOUTUBE_VIDEO_ID + " = ?",
						new String[]{video.getId()});
		boolean successful = false;

		if(rowsDeleted >= 0) {
			// Since we've removed a video, we will need to update the order column for all the videos.
			int order = 1;
			Cursor	cursor = getReadableDatabase().query(
							BookmarksTable.TABLE_NAME,
							new String[]{BookmarksTable.COL_YOUTUBE_VIDEO, BookmarksTable.COL_ORDER},
							null,
							null, null, null, BookmarksTable.COL_ORDER + " ASC");
			if(cursor.moveToNext()) {
				do {
					byte[] blob = cursor.getBlob(cursor.getColumnIndex(BookmarksTable.COL_YOUTUBE_VIDEO));
					YouTubeVideo uvideo = <mark>new Gson</mark>().<mark>fromJson</mark>(new String(blob), new TypeToken<YouTubeVideo>(){}.<mark>getType</mark>());
					ContentValues contentValues = new ContentValues();
					contentValues.put(BookmarksTable.COL_ORDER, order++);

					getWritableDatabase().update(BookmarksTable.TABLE_NAME, contentValues, BookmarksTable.COL_YOUTUBE_VIDEO_ID + " = ?",
									new String[]{uvideo.getId()});
				} while(cursor.moveToNext());
			}

			cursor.close();

			onUpdated();
			successful = true;
		}

		return successful;
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>linkedin_____gobblin_____JdbcExtractor_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/linkedin_____gobblin_____JdbcExtractor.java

com.google.gson.Gson.toJson
com.google.gson.Gson.fromJson

/**
   * Schema of a custom column - required if column not found in metadata
   *
   * @return column schema
   */  @Override
  public JsonArray getSchema(CommandOutput<?, ?> response) throws SchemaException, IOException {
    this.log.debug("Extract schema from resultset");
    ResultSet resultset = null;
    Iterator<ResultSet> itr = (Iterator<ResultSet>) response.getResults().values().iterator();
    if (itr.hasNext()) {
      resultset = itr.next();
    } else {
      throw new SchemaException("Failed to get schema from database - Resultset has no records");
    }

    JsonArray fieldJsonArray = new JsonArray();
    try {
      while (resultset.next()) {
        Schema schema = new Schema();
        String columnName = resultset.getString(1);
        schema.setColumnName(columnName);

        String dataType = resultset.getString(2);
        String elementDataType = "string";
        List<String> mapSymbols = null;
        JsonObject newDataType = this.convertDataType(columnName, dataType, elementDataType, mapSymbols);

        schema.setDataType(newDataType);
        schema.setLength(resultset.getLong(3));
        schema.setPrecision(resultset.getInt(4));
        schema.setScale(resultset.getInt(5));
        schema.setNullable(resultset.getBoolean(6));
        schema.setFormat(resultset.getString(7));
        schema.setComment(resultset.getString(8));
        schema.setDefaultValue(null);
        schema.setUnique(false);

        String jsonStr = gson.<mark>toJson</mark>(schema);
        JsonObject obj = gson.<mark>fromJson</mark>(jsonStr, JsonObject.class).getAsJsonObject();
        fieldJsonArray.add(obj);
      }
    } catch (Exception e) {
      throw new SchemaException("Failed to get schema from database; error - " + e.getMessage(), e);
    }

    return fieldJsonArray;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>naver_____pinpoint_____GsonIT_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/naver_____pinpoint_____GsonIT.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson
com.google.gson.Gson.fromJson
com.google.gson.Gson.fromJson
com.google.gson.Gson.fromJson
com.google.gson.Gson.getDeclaredMethod
com.google.gson.Gson.getDeclaredMethod
com.google.gson.Gson.getDeclaredMethod
com.google.gson.Gson.getDeclaredMethod
com.google.gson.Gson.toJson
com.google.gson.Gson.toJson
com.google.gson.Gson.toJson
com.google.gson.Gson.toJson
com.google.gson.Gson.getDeclaredMethod
com.google.gson.Gson.getDeclaredMethod
com.google.gson.Gson.getDeclaredMethod
com.google.gson.Gson.getDeclaredMethod

    @Test
    public void test() throws Exception {
        final Gson gson = <mark>new Gson</mark>();

        /**
         * @see Gson#<mark>fromJson</mark>(String, Class)
         * @see Gson#<mark>fromJson</mark>(String, InterceptPoint)
         */
        gson.<mark>fromJson</mark>(json, String.class);
        gson.<mark>fromJson</mark>(json, (Type) String.class);

        Method fromJson1 = Gson.class.<mark>getDeclaredMethod</mark>("fromJson", String.class, Class.class);
        Method fromJson2 = Gson.class.<mark>getDeclaredMethod</mark>("fromJson", String.class, Type.class);

        /**
         * @see Gson#<mark>toJson</mark>(Object)
         * @see Gson#<mark>toJson</mark>(Object, InterceptPoint)
         */
        gson.<mark>toJson</mark>(java);
        gson.<mark>toJson</mark>(java, String.class);

        Method toJson1 = Gson.class.<mark>getDeclaredMethod</mark>("toJson", Object.class);
        Method toJson2 = Gson.class.<mark>getDeclaredMethod</mark>("toJson", Object.class, Type.class);

        PluginTestVerifier verifier = PluginTestVerifierHolder.getInstance();
        verifier.printCache();

        verifier.verifyTrace(event(serviceType, fromJson1, expectedAnnotation),
                event(serviceType, fromJson2, expectedAnnotation));

        verifier.verifyTrace(event(serviceType, toJson1, expectedAnnotation),
                event(serviceType, toJson2, expectedAnnotation));

        // No more traces
        verifier.verifyTraceCount(0);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.toJson
com.google.gson.Gson.fromJson

/**
     * Add user
     *
     * @param userName    username
     * @param credential  password
     * @param role        user role
     * @param firstName   first name
     * @param lastName    last name
     * @param email       email
     * @param profileName profile name
     * @throws CommandException
     */     */
    public void addTenant(String admin, String firstName, String lastName, String password, String domain, String email)
            throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            TenantInfoBean tenantInfo = new TenantInfoBean();
            tenantInfo.setAdmin(admin);
            tenantInfo.setFirstName(firstName);
            tenantInfo.setLastName(lastName);
            tenantInfo.setAdminPassword(password);
            tenantInfo.setTenantDomain(domain);
            tenantInfo.setEmail(email);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            String jsonString = gson.<mark>toJson</mark>(tenantInfo, TenantInfoBean.class);
            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL()
                    + ENDPOINT_ADD_TENANT, jsonString);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode == 201) {
                System.out.println("Tenant added successfully: " + domain);
            } else {
                String resultString = CliUtils.getHttpResponseString(response);
                String errorMsg = gson.<mark>fromJson</mark>(resultString, ResponseMessageBean.class).getMessage();
                System.out.println(errorMsg);
            }
        } catch (Exception e) {
            String message = "Could not add tenant: " + domain;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>googlesamples_____io2014-codelabs_____DeviceSubscription_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/googlesamples_____io2014-codelabs_____DeviceSubscription.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
   * Delete Prospective Search Api subscriptions in batches.
   *
   * @param subIds A list of Prospective Search Api subscription ids to be deleted.
   */   */
  public Entity create(SubscriptionUtility.MobileType deviceType, String deviceId,
      String subscriptionId) {
    if (StringUtility.isNullOrEmpty(deviceId) || StringUtility.isNullOrEmpty(subscriptionId)) {
      return null;
    }

    Key key;
    String newDeviceId = SubscriptionUtility.extractRegId(deviceId);
    Entity deviceSubscription = get(newDeviceId);
    // Subscriptions is a "set" instead of a "list" to ensure uniqueness of each subscriptionId
    // for a device
    Set<String> subscriptions = new HashSet<String>();

    if (deviceSubscription == null) {
      // Create a brand new one
      key = getKey(newDeviceId);
      deviceSubscription = new Entity(key);
      deviceSubscription.setProperty(PROPERTY_ID, newDeviceId);
      deviceSubscription.setProperty(PROPERTY_DEVICE_TYPE, deviceType.toString());
    } else {
      key = deviceSubscription.getKey();

      // Update the existing subscription list
      String ids = (String) deviceSubscription.getProperty(PROPERTY_SUBSCRIPTION_IDS);
      if (!StringUtility.isNullOrEmpty(ids)) {
        subscriptions = this.gson.<mark>fromJson</mark>(ids, setType);
      }
    }

    // Update entity subscription property and save only when subscriptionId has successfully added
    // to the subscriptions "set".  If a subscriptionId is a duplicate of an existing subscription
    // in the set, we don't save this duplicated value into the entity.
    if (subscriptions.add(subscriptionId)) {
      deviceSubscription.setProperty(PROPERTY_SUBSCRIPTION_IDS, this.gson.toJson(subscriptions));
      Calendar time = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
      deviceSubscription.setProperty(PROPERTY_TIMESTAMP, time.getTime());

      this.datastoreService.put(deviceSubscription);
      this.memcacheService.put(key, deviceSubscription);
    }

    return deviceSubscription;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>mitreid-connect_____OpenID-Connect-Java-Spring-Server_____PolicyAPI_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/mitreid-connect_____OpenID-Connect-Java-Spring-Server_____PolicyAPI.java

com.google.gson.Gson.fromJson

/**
	 * Delete a specific policy
	 * @param rsid
	 * @param pid
	 * @param m
	 * @param auth
	 * @return
	 */	@RequestMapping(value = "/{rsid}" + POLICYURL, method = RequestMethod.POST, produces = MimeTypeUtils.APPLICATION_JSON_VALUE)
	public String createNewPolicyForResourceSet(@PathVariable (value = "rsid") Long rsid, @RequestBody String jsonString, Model m, Authentication auth) {
		ResourceSet rs = resourceSetService.getById(rsid);

		if (rs == null) {
			m.addAttribute(HttpCodeView.CODE, HttpStatus.NOT_FOUND);
			return HttpCodeView.VIEWNAME;
		}

		if (!rs.getOwner().equals(auth.getName())) {
			logger.warn("Unauthorized resource set request from bad user; expected " + rs.getOwner() + " got " + auth.getName());

			// authenticated user didn't match the owner of the resource set
			m.addAttribute(HttpCodeView.CODE, HttpStatus.FORBIDDEN);
			return HttpCodeView.VIEWNAME;
		}

		Policy p = gson.<mark>fromJson</mark>(jsonString, Policy.class);

		if (p.getId() != null) {
			logger.warn("Tried to add a policy with a non-null ID: " + p.getId());
			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
			return HttpCodeView.VIEWNAME;
		}

		for (Claim claim : p.getClaimsRequired()) {
			if (claim.getId() != null) {
				logger.warn("Tried to add a policy with a non-null claim ID: " + claim.getId());
				m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
				return HttpCodeView.VIEWNAME;
			}
		}

		rs.getPolicies().add(p);
		ResourceSet saved = resourceSetService.update(rs, rs);

		// find the new policy object
		Collection<Policy> newPolicies = Sets.difference(new HashSet<>(saved.getPolicies()), new HashSet<>(rs.getPolicies()));

		if (newPolicies.size() == 1) {
			Policy newPolicy = newPolicies.iterator().next();
			m.addAttribute(JsonEntityView.ENTITY, newPolicy);
			return JsonEntityView.VIEWNAME;
		} else {
			logger.warn("Unexpected result trying to add a new policy object: " + newPolicies);
			m.addAttribute(HttpCodeView.CODE, HttpStatus.INTERNAL_SERVER_ERROR);
			return HttpCodeView.VIEWNAME;
		}

	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_4.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.toJson
com.google.gson.Gson.fromJson

/**
     * Update user
     *
     * @param userName    username
     * @param credential  password
     * @param role        user role
     * @param firstName   first name
     * @param lastName    last name
     * @param email       email
     * @param profileName profile name
     * @throws CommandException
     */     */
    public void updateTenant(int id, String admin, String firstName, String lastName, String password, String domain, String email)
            throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            TenantInfoBean tenantInfo = new TenantInfoBean();
            tenantInfo.setAdmin(admin);
            tenantInfo.setFirstName(firstName);
            tenantInfo.setLastName(lastName);
            tenantInfo.setAdminPassword(password);
            tenantInfo.setTenantDomain(domain);
            tenantInfo.setEmail(email);
            tenantInfo.setTenantId(id);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            String jsonString = gson.<mark>toJson</mark>(tenantInfo, TenantInfoBean.class);

            HttpResponse response = restClient.doPut(httpClient, restClient.getBaseURL()
                    + ENDPOINT_UPDATE_TENANT, jsonString);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode < 200 || responseCode >= 300) {
                String resultString = CliUtils.getHttpResponseString(response);
                String errorMsg = gson.<mark>fromJson</mark>(resultString, ResponseMessageBean.class).getMessage();
                System.out.println(errorMsg);

            } else {
                System.out.println("Tenant updated successfully: " + domain);
            }
        } catch (Exception e) {
            String message = "Could not update tenant: " + domain;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>AEFeinstein_____mtg-familiar_____TcgpApi_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/AEFeinstein_____mtg-familiar_____TcgpApi.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * Return a paged list of all CategoryGroups for Magic expansions
     *
     * @param offset The offset for this query. The 0th index in this array will be used and updated
     * @return The CategoryGroups retrieved from the API
     * @throws IOException If something goes wrong with the network
     */     */
    public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
        // Make sure we have an access token first
        if (null != mAccessToken) {

            // Concatenate all the product IDs into one string
            StringBuilder stringIds = new StringBuilder();
            for (long id : productIds) {
                if (stringIds.length() > 0) {
                    stringIds.append(',');
                }
                stringIds.append(Long.toString(id));
            }

            // Create the connection with default options and headers
            HttpURLConnection conn = (HttpURLConnection) new URL(
                    "https://api.tcgplayer.com/" + TCGP_VERSION + "/pricing/product/" +
                            stringIds.toString()).openConnection();
            setDefaultOptions(conn, HttpMethod.GET);
            addHeaders(conn);

            // Get the response stream. This opens the connection
            InputStream inStream;
            try {
                inStream = conn.getInputStream();
            } catch (FileNotFoundException e) {
                inStream = conn.getErrorStream();
                if (null == inStream) {
                    conn.disconnect();
                    // Return an empty, not null, object
                    return new ProductMarketPrice();
                }
            }

            // Parse the json out of the response and save it
            ProductMarketPrice price = <mark>new Gson</mark>()
                    .<mark>fromJson</mark>(new InputStreamReader(inStream), ProductMarketPrice.class);

            // Clean up
            inStream.close();
            conn.disconnect();
            return price;
        }
        // No access token
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____ambari_____BlueprintResourceProvider_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____ambari_____BlueprintResourceProvider.java

com.google.gson.Gson.fromJson

/**
   * Populate blueprint configurations.
   *
   * @param propertyMaps  collection of configuration property maps
   * @param blueprint     blueprint entity to set configurations on
   */   */
  List<Map<String, Map<String, Object>>> populateConfigurationList(
      Collection<? extends BlueprintConfiguration> configurations) throws NoSuchResourceException {

    List<Map<String, Map<String, Object>>> listConfigurations = new ArrayList<>();
    for (BlueprintConfiguration config : configurations) {
      Map<String, Map<String, Object>> mapConfigurations = new HashMap<>();
      Map<String, Object> configTypeDefinition = new HashMap<>();
      String type = config.getType();

      if(config instanceof BlueprintConfigEntity) {
        Map<String, String> properties = jsonSerializer.<Map<String, String>><mark>fromJson</mark>(
            config.getConfigData(), Map.class);

        StackEntity stack = ((BlueprintConfigEntity)config).getBlueprintEntity().getStack();
        StackInfo metaInfoStack;

        try {
          metaInfoStack = ambariMetaInfo.getStack(stack.getStackName(), stack.getStackVersion());
        } catch (AmbariException e) {
          throw new NoSuchResourceException(e.getMessage());
        }

        Map<org.apache.ambari.server.state.PropertyInfo.PropertyType, Set<String>> propertiesTypes =
            metaInfoStack.getConfigPropertiesTypes(type);

        SecretReference.replacePasswordsWithReferences(propertiesTypes, properties, type, -1l);

        configTypeDefinition.put(PROPERTIES_PROPERTY_ID, properties);
      } else {
        Map<String, Object> properties = jsonSerializer.<Map<String, Object>><mark>fromJson</mark>(
            config.getConfigData(), Map.class);
        configTypeDefinition.put(PROPERTIES_PROPERTY_ID, properties);
      }

      Map<String, Map<String, String>> attributes = jsonSerializer.<Map<String, Map<String, String>>><mark>fromJson</mark>(
          config.getConfigAttributes(), Map.class);
      if (attributes != null && !attributes.isEmpty()) {
        configTypeDefinition.put(PROPERTIES_ATTRIBUTES_PROPERTY_ID, attributes);
      }
      mapConfigurations.put(type, configTypeDefinition);
      listConfigurations.add(mapConfigurations);
    }

    return listConfigurations;
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>OpenGamma_____OG-Platform_____ColumnConfigResource_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/OpenGamma_____OG-Platform_____ColumnConfigResource.java

com.google.gson.Gson.fromJson

/**
   * Gets the default configuration as a map, corresponds to {@link FunctionModelConfig}.
   * This is built from system default configuration combined with the default implementations that can be inferred
   * where there is only one known implementation of an interface. The format is
   *
   * <pre>
   *   {
   *     impls: {interface1: impl1, interface2: impl2, ... },
   *     args: {
   *         impl1: {
   *         propertyName1: arg1,
   *         propertyName2: arg2,
   *         ...
   *       },
   *       impl2: {
   *         propertyName3: arg3,
   *         ...
   *       },
   *       ...
   *     }
   *   }
   * </pre>
   *
   * @return the default configuration as a map
   */   */
  public Map<String, Object> getConfigPageModel(UniqueId columnId, String configJsonStr) {
    ArgumentChecker.notEmpty(configJsonStr, "configJsonStr");
    ArgumentChecker.notNull(columnId, "columnId");

    ViewColumn column = loadColumn(columnId);
    Class<?> inputType;
    FunctionModelConfig config;
    OutputName outputName;
    FunctionModel model;

    Map<String, Object> configJson;
    try {
      configJson = _gson.<mark>fromJson</mark>(configJsonStr, Map.class);
    } catch (JsonSyntaxException e) {
      throw new IllegalArgumentException(e);
    }
    String inputTypeName = (String) configJson.get("inputType");

    if (!StringUtils.isEmpty(inputTypeName)) {
      inputType = loadInputType(inputTypeName);
      String outputNameStr = (String) configJson.get("outputName");
      FunctionMetadata outputFunction;

      if (StringUtils.isEmpty(outputNameStr)) {
        // use the existing output name, possibly null
        outputName = column.getOutputName(inputType);
      } else {
        // use the output name from the client
        outputName = OutputName.of(outputNameStr);
      }
      if (outputName != null) {
        outputFunction = _availableOutputs.getOutputFunction(outputName, inputType);
        config = _jsonBuilder.getConfigFromJson(configJson);
        model = FunctionModel.forFunction(outputFunction, config, _availableComponents, NodeDecorator.IDENTITY, _argumentConverter);
      } else {
        config = FunctionModelConfig.EMPTY;
        model = null;
      }
    } else {
      inputType = null;
      outputName = null;
      config = null;
      model = null;
    }
    return _jsonBuilder.getConfigPageModel(column.getName(), config, inputType, outputName, model);
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>openhab_____openhab2-addons_____LxWebSocket_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/openhab_____openhab2-addons_____LxWebSocket.java

com.google.gson.Gson.fromJson
com.google.gson.JsonParseException.getMessage

/**
     * Sends a command to the Miniserver and encrypts it if command can be encrypted and encryption is available.
     * Request can be synchronous or asynchronous. There is always a response expected to the command, and it is a
     * standard command response as defined in {@link LxResponse}. Such commands are the majority of commands
     * used for performing actions on the controls and for executing authentication procedure.
     * A synchronous command must not be sent from the websocket thread (from websocket callback methods) or it will
     * cause a deadlock.
     * An asynchronous command request returns immediately, but the returned value will not contain valid data in
     * the subResponse structure until a response is received. Asynchronous request can be sent from the websocket
     * thread. There can be only one command sent which awaits response per websocket connection,
     * whether this is synchronous or asynchronous command (this seems how Loxone Miniserver behaves, as it does not
     * have any unique identifier to match commands to responses).
     * For synchronous commands this is ensured naturally, for asynchronous the caller must manage it.
     * If this method is called before a response to the previous command is received, it will return error and not
     * send the command.
     *
     * @param command command to send to the Miniserver
     * @param sync true is synchronous request, false if ansynchronous
     * @param encrypt true if command can be encrypted (does not mean it will)
     * @return response received (for sync command) or to be received (for async), null if error occurred
     */    @OnWebSocketMessage
    public void onMessage(String msg) {
        webSocketLock.lock();
        try {
            if (logger.isTraceEnabled()) {
                String trace = msg;
                if (trace.length() > 100) {
                    trace = msg.substring(0, 100);
                }
                logger.trace("[{}] received message: {}", debugId, trace);
            }
            if (!awaitingConfiguration) {
                processResponse(msg);
                return;
            }
            awaitingConfiguration = false;
            stopResponseTimeout();
            thingHandler.clearConfiguration();

            LxConfig config = gson.<mark>fromJson</mark>(msg, LxConfig.class);
            config.finalize(thingHandler);

            thingHandler.setMiniserverConfig(config);

            if (sendCmdWithResp(CMD_ENABLE_UPDATES, false, false) == null) {
                disconnect(LxErrorCode.COMMUNICATION_ERROR, "Failed to enable state updates.");
            }
        } finally {
            webSocketLock.unlock();
        }
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>AEFeinstein_____mtg-familiar_____TcgpApi_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/AEFeinstein_____mtg-familiar_____TcgpApi.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
     * Given an array of productIds, request and return all of the product's non-price details
     *
     * @param productIds The productId of the card to query
     * @return All the non-price details
     * @throws IOException If something goes wrong with the network
     */     */
    public ProductInformation getProductInformation(String name, String expansion)
            throws IOException {
        // Make sure we have an access token first
        if (null != mAccessToken) {

            // Create the connection with default options and headers
            HttpURLConnection conn = (HttpURLConnection) new URL("https://api.tcgplayer.com/" +
                    TCGP_VERSION + "/catalog/categories/" + CATEGORY_ID_MAGIC + "/search")
                    .openConnection();
            setDefaultOptions(conn, HttpMethod.POST);
            addHeaders(conn);

            // Create the params, only adding the set if it isn't null
            GetProductInformationOptions.NameValuesPair queryParams[];
            if (null != expansion) {
                queryParams = new GetProductInformationOptions.NameValuesPair[]{
                        new GetProductInformationOptions.NameValuesPair("ProductName", new String[]{name}),
                        new GetProductInformationOptions.NameValuesPair("SetName", new String[]{expansion})};
            } else {
                queryParams = new GetProductInformationOptions.NameValuesPair[]{
                        new GetProductInformationOptions.NameValuesPair("ProductName", new String[]{name})};
            }

            // Add the information to search by
            GetProductInformationOptions options = new GetProductInformationOptions(queryParams);
            conn.getOutputStream().write(<mark>new Gson</mark>().toJson(options, GetProductInformationOptions.class)
                    .getBytes(Charset.forName("UTF-8")));

            // Get the response stream. This opens the connection
            InputStream inStream;
            try {
                inStream = conn.getInputStream();
            } catch (FileNotFoundException e) {
                inStream = conn.getErrorStream();
                if (null == inStream) {
                    conn.disconnect();
                    // Return an empty, not null, object
                    return new ProductInformation();
                }
            }

            // Parse the json out of the response and save it
            ProductInformation information = (<mark>new Gson</mark>()).<mark>fromJson</mark>(new InputStreamReader(inStream),
                    ProductInformation.class);

            // Clean up
            inStream.close();
            conn.disconnect();
            return information;
        }
        // No access token
        return null;
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>naver_____pinpoint_____GsonIT_3.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/naver_____pinpoint_____GsonIT.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.stream.JsonReader.&ltinit&gt
com.google.gson.Gson.fromJson
com.google.gson.Gson.getDeclaredMethod
com.google.gson.stream.JsonWriter.&ltinit&gt
com.google.gson.Gson.toJson
com.google.gson.stream.JsonWriter.&ltinit&gt
com.google.gson.Gson.toJson
com.google.gson.Gson.getDeclaredMethod
com.google.gson.Gson.getDeclaredMethod

    @Test
    public void testFromV1_2() throws Exception {
        if (!v1_2) {
            return;
        }
        
        final Gson gson = <mark>new Gson</mark>();
        final JsonElement jsonElement = getParseElements();
        
        /**
         * @see Gson#<mark>fromJson</mark>(Reader, Class)
         * @see Gson#<mark>fromJson</mark>(Reader, InterceptPoint)
         * @see Gson#<mark>fromJson</mark>(JsonElement, Class)
         * @see Gson#<mark>fromJson</mark>(JsonElement, InterceptPoint)
         */
        gson.<mark>fromJson</mark>(new StringReader(json), (Class<?>) String.class);
        gson.<mark>fromJson</mark>(new StringReader(json), (Type) String.class);
        gson.<mark>fromJson</mark>(jsonElement, String.class);
        gson.<mark>fromJson</mark>(jsonElement, (Type) String.class);

        Method fromJson3 = Gson.class.<mark>getDeclaredMethod</mark>("fromJson", Reader.class, Class.class);
        Method fromJson4 = Gson.class.<mark>getDeclaredMethod</mark>("fromJson", Reader.class, Type.class);
        Method fromJson6 = Gson.class.<mark>getDeclaredMethod</mark>("fromJson", JsonElement.class, Class.class);
        Method fromJson7 = Gson.class.<mark>getDeclaredMethod</mark>("fromJson", JsonElement.class, Type.class);

        /**
         * @see Gson#<mark>toJson</mark>(Object, Appendable)
         * @see Gson#<mark>toJson</mark>(Object, InterceptPoint, Appendable)
         * @see Gson#<mark>toJson</mark>(JsonElement)
         * @see Gson#<mark>toJson</mark>(JsonElement, Appendable)
         */
        gson.<mark>toJson</mark>(java, new StringWriter());
        gson.<mark>toJson</mark>(java, String.class, new StringWriter());
        gson.<mark>toJson</mark>(jsonElement);
        gson.<mark>toJson</mark>(jsonElement, new StringWriter());

        Method toJson3 = Gson.class.<mark>getDeclaredMethod</mark>("toJson", Object.class, Appendable.class);
        Method toJson4 = Gson.class.<mark>getDeclaredMethod</mark>("toJson", Object.class, Type.class, Appendable.class);
        Method toJson6 = Gson.class.<mark>getDeclaredMethod</mark>("toJson", JsonElement.class);
        Method toJson7 = Gson.class.<mark>getDeclaredMethod</mark>("toJson", JsonElement.class, Appendable.class);

        PluginTestVerifier verifier = PluginTestVerifierHolder.getInstance();
        verifier.printCache();

        verifier.verifyTrace(event(serviceType, fromJson3),
                event(serviceType, fromJson4),
                event(serviceType, fromJson6),
                event(serviceType, fromJson7));
        
        verifier.verifyTrace(event(serviceType, toJson3),
                event(serviceType, toJson4),
                event(serviceType, toJson6, expectedAnnotation),
                event(serviceType, toJson7));

        // No more traces
        verifier.verifyTraceCount(0);
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>opendatakit_____collect_____ServerPreferencesFragment_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/opendatakit_____collect_____ServerPreferencesFragment.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.List<java.lang.String>>.&ltinit&gt
com.google.gson.reflect.TypeToken<java.util.List<java.lang.String>>.getType
com.google.gson.Gson.fromJson

/**
     * Remotely log the URL scheme, whether the URL is on one of 3 common hosts, and a URL hash.
     * This will help inform decisions on whether or not to allow insecure server configurations
     * (HTTP) and on which hosts to strengthen support for.
     *
     * @param url the URL that the server setting has just been set to
     */
    public void addAggregatePreferences() {
        if (!new AggregatePreferencesAdder(this).add()) {
            return;
        }

        serverUrlPreference = (EditTextPreference) findPreference(
                GeneralKeys.KEY_SERVER_URL);
        usernamePreference = (EditTextPreference) findPreference(GeneralKeys.KEY_USERNAME);
        passwordPreference = (EditTextPreference) findPreference(GeneralKeys.KEY_PASSWORD);

        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getActivity());
        String urlListString = prefs.getString(KNOWN_URL_LIST, "");
        if (urlListString.isEmpty()) {
            urlList = new ArrayList<>();
        } else {
            urlList =
                    <mark>new Gson</mark>().<mark>fromJson</mark>(urlListString, new TypeToken<List<String>>() {
                    }.<mark>getType</mark>());
        }
        if (urlList.isEmpty()) {
            addUrlToPreferencesList(getString(R.string.default_server_url), prefs);
        }

        urlDropdownSetup();

        // TODO: use just 'serverUrlPreference.getEditText().setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.ic_arrow_drop_down, 0);' once minSdkVersion is >= 21
        serverUrlPreference.getEditText().setCompoundDrawablesWithIntrinsicBounds(null, null,
                AppCompatResources.getDrawable(getActivity(), R.drawable.ic_arrow_drop_down), null);
        serverUrlPreference.getEditText().setOnTouchListener(this);
        serverUrlPreference.setOnPreferenceChangeListener(createChangeListener());
        serverUrlPreference.setSummary(serverUrlPreference.getText());
        serverUrlPreference.getEditText().setFilters(
                new InputFilter[]{new ControlCharacterFilter(), new WhitespaceFilter()});

        usernamePreference.setOnPreferenceChangeListener(createChangeListener());
        usernamePreference.setSummary(usernamePreference.getText());
        usernamePreference.getEditText().setFilters(
                new InputFilter[]{new ControlCharacterFilter()});

        passwordPreference.setOnPreferenceChangeListener(createChangeListener());
        maskPasswordSummary(passwordPreference.getText());
        passwordPreference.getEditText().setFilters(
                new InputFilter[]{new ControlCharacterFilter()});

        //setupTransportPreferences();
        getPreferenceScreen().removePreference(findPreference(KEY_TRANSPORT_PREFERENCE));
        getPreferenceScreen().removePreference(findPreference(KEY_SMS_PREFERENCE));
    }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>linkedin_____gobblin_____JdbcExtractor_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/linkedin_____gobblin_____JdbcExtractor.java

com.google.gson.Gson.fromJson

/**
   * Update water mark column property if there is an alias defined in query
   *
   * @param srcColumnName source column name
   * @param tgtColumnName target column name
   */  @Override
  public void extractMetadata(String schema, String entity, WorkUnit workUnit) throws SchemaException, IOException {
    this.log.info("Extract metadata using JDBC");
    String inputQuery = workUnitState.getProp(ConfigurationKeys.SOURCE_QUERYBASED_QUERY);
    if (workUnitState.getPropAsBoolean(ConfigurationKeys.SOURCE_QUERYBASED_IS_METADATA_COLUMN_CHECK_ENABLED,
        Boolean.valueOf(ConfigurationKeys.DEFAULT_SOURCE_QUERYBASED_IS_METADATA_COLUMN_CHECK_ENABLED)) &&
        hasJoinOperation(inputQuery)) {
      throw new RuntimeException("Query across multiple tables not supported");
    }

    String watermarkColumn = workUnitState.getProp(ConfigurationKeys.EXTRACT_DELTA_FIELDS_KEY);
    this.enableDelimitedIdentifier = workUnitState.getPropAsBoolean(
        ConfigurationKeys.ENABLE_DELIMITED_IDENTIFIER, ConfigurationKeys.DEFAULT_ENABLE_DELIMITED_IDENTIFIER);
    JsonObject defaultWatermark = this.getDefaultWatermark();
    String derivedWatermarkColumnName = defaultWatermark.get("columnName").getAsString();
    this.setSampleRecordCount(this.exractSampleRecordCountFromQuery(inputQuery));
    inputQuery = this.removeSampleClauseFromQuery(inputQuery);
    JsonArray targetSchema = new JsonArray();
    List<String> headerColumns = new ArrayList<>();

    try {
      List<Command> cmds = this.getSchemaMetadata(schema, entity);

      CommandOutput<?, ?> response = this.executePreparedSql(cmds);

      JsonArray array = this.getSchema(response);

      this.buildMetadataColumnMap(array);
      this.parseInputQuery(inputQuery);
      List<String> sourceColumns = this.getMetadataColumnList();

      for (ColumnAttributes colMap : this.columnAliasMap) {
        String alias = colMap.getAliasName();
        String columnName = colMap.getColumnName();
        String sourceColumnName = colMap.getSourceColumnName();
        if (this.isMetadataColumn(columnName, sourceColumns)) {
          String targetColumnName = this.getTargetColumnName(columnName, alias);
          Schema obj = this.getUpdatedSchemaObject(columnName, alias, targetColumnName);
          String jsonStr = gson.toJson(obj);
          JsonObject jsonObject = gson.<mark>fromJson</mark>(jsonStr, JsonObject.class).getAsJsonObject();
          targetSchema.add(jsonObject);
          headerColumns.add(targetColumnName);
          sourceColumnName = getLeftDelimitedIdentifier() + sourceColumnName + getRightDelimitedIdentifier();
          this.columnList.add(sourceColumnName);
        }
      }

      if (this.hasMultipleWatermarkColumns(watermarkColumn)) {
        derivedWatermarkColumnName = getLeftDelimitedIdentifier() + derivedWatermarkColumnName + getRightDelimitedIdentifier();
        this.columnList.add(derivedWatermarkColumnName);
        headerColumns.add(derivedWatermarkColumnName);
        targetSchema.add(defaultWatermark);
        this.workUnitState.setProp(ConfigurationKeys.EXTRACT_DELTA_FIELDS_KEY, derivedWatermarkColumnName);
      }

      String outputColProjection = Joiner.on(",").useForNull("null").join(this.columnList);
      outputColProjection = outputColProjection.replace(derivedWatermarkColumnName,
          Utils.getCoalesceColumnNames(watermarkColumn) + " AS " + derivedWatermarkColumnName);
      this.setOutputColumnProjection(outputColProjection);
      String extractQuery = this.getExtractQuery(schema, entity, inputQuery);

      this.setHeaderRecord(headerColumns);
      this.setOutputSchema(targetSchema);
      this.setExtractSql(extractQuery);
      // this.workUnit.getProp(ConfigurationKeys.EXTRACT_TABLE_NAME_KEY,
      // this.escapeCharsInColumnName(this.workUnit.getProp(ConfigurationKeys.SOURCE_ENTITY),
      // ConfigurationKeys.ESCAPE_CHARS_IN_COLUMN_NAME, "_"));
      this.log.info("Schema:" + targetSchema);
      this.log.info("Extract query: " + this.getExtractSql());
    } catch (RuntimeException | IOException | SchemaException e) {
      throw new SchemaException("Failed to get metadata using JDBC; error - " + e.getMessage(), e);
    }
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>HuaweiBigData_____carbondata_____SegmentStatusManager_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/HuaweiBigData_____carbondata_____SegmentStatusManager.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
   * This method will create new segment id
   *
   * @param loadMetadataDetails
   * @return
   */   */
  public ValidAndInvalidSegmentsInfo getValidAndInvalidSegments() throws IOException {

    // @TODO: move reading LoadStatus file to separate class
    List<String> listOfValidSegments = new ArrayList<>(10);
    List<String> listOfValidUpdatedSegments = new ArrayList<>(10);
    List<String> listOfInvalidSegments = new ArrayList<>(10);
    List<String> listOfStreamSegments = new ArrayList<>(10);
    CarbonTablePath carbonTablePath = CarbonStorePath
            .getCarbonTablePath(absoluteTableIdentifier.getStorePath(),
                    absoluteTableIdentifier.getCarbonTableIdentifier());
    String dataPath = carbonTablePath.getTableStatusFilePath();
    DataInputStream dataInputStream = null;
    Gson gsonObjectToRead = <mark>new Gson</mark>();
    AtomicFileOperations fileOperation =
            new AtomicFileOperationsImpl(dataPath, FileFactory.getFileType(dataPath));
    LoadMetadataDetails[] loadFolderDetailsArray;
    try {
      if (FileFactory.isFileExist(dataPath, FileFactory.getFileType(dataPath))) {
        dataInputStream = fileOperation.openForRead();
        BufferedReader buffReader =
                new BufferedReader(new InputStreamReader(dataInputStream, "UTF-8"));
        loadFolderDetailsArray = gsonObjectToRead.<mark>fromJson</mark>(buffReader, LoadMetadataDetails[].class);
        //just directly iterate Array
        for (LoadMetadataDetails loadMetadataDetails : loadFolderDetailsArray) {
          if (CarbonCommonConstants.STORE_LOADSTATUS_SUCCESS
                  .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())
                  || CarbonCommonConstants.MARKED_FOR_UPDATE
                  .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())
                  || CarbonCommonConstants.STORE_LOADSTATUS_PARTIAL_SUCCESS
                  .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())
                  || CarbonCommonConstants.STORE_LOADSTATUS_STREAMING
                  .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())
                  || CarbonCommonConstants.STORE_LOADSTATUS_STREAMING_FINISH
                  .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())) {
            // check for merged loads.
            if (null != loadMetadataDetails.getMergedLoadName()) {
              if (!listOfValidSegments.contains(loadMetadataDetails.getMergedLoadName())) {
                listOfValidSegments.add(loadMetadataDetails.getMergedLoadName());
              }
              // if merged load is updated then put it in updated list
              if (CarbonCommonConstants.MARKED_FOR_UPDATE
                      .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())) {
                listOfValidUpdatedSegments.add(loadMetadataDetails.getMergedLoadName());
              }
              continue;
            }

            if (CarbonCommonConstants.MARKED_FOR_UPDATE
                    .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())) {

              listOfValidUpdatedSegments.add(loadMetadataDetails.getLoadName());
            }
            if (CarbonCommonConstants.STORE_LOADSTATUS_STREAMING
                .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())
                || CarbonCommonConstants.STORE_LOADSTATUS_STREAMING_FINISH
                .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())) {
              listOfStreamSegments.add(loadMetadataDetails.getLoadName());
              continue;
            }
            listOfValidSegments.add(loadMetadataDetails.getLoadName());
          } else if ((CarbonCommonConstants.STORE_LOADSTATUS_FAILURE
                  .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())
                  || CarbonCommonConstants.COMPACTED
                  .equalsIgnoreCase(loadMetadataDetails.getLoadStatus())
                  || CarbonCommonConstants.MARKED_FOR_DELETE
                  .equalsIgnoreCase(loadMetadataDetails.getLoadStatus()))) {
            listOfInvalidSegments.add(loadMetadataDetails.getLoadName());
          }
        }
      }
    } catch (IOException e) {
      LOG.error(e);
      throw e;
    } finally {
      try {
        if (null != dataInputStream) {
          dataInputStream.close();
        }
      } catch (Exception e) {
        LOG.error(e);
        throw e;
      }
    }
    return new ValidAndInvalidSegmentsInfo(listOfValidSegments, listOfValidUpdatedSegments,
            listOfInvalidSegments, listOfStreamSegments);
  }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>mitreid-connect_____OpenID-Connect-Java-Spring-Server_____ClientAPI_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/mitreid-connect_____OpenID-Connect-Java-Spring-Server_____ClientAPI.java

com.google.gson.JsonParser.parse
com.google.gson.Gson.fromJson
com.google.gson.JsonObject.has
com.google.gson.JsonObject.get

/**
	 * Delete a client
	 * @param id
	 * @param modelAndView
	 * @return
	 */	@RequestMapping(method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
	public String apiAddClient(@RequestBody String jsonString, Model m, Authentication auth) {

		JsonObject json = null;
		ClientDetailsEntity client = null;

		try {
			json = parser.<mark>parse</mark>(jsonString).getAsJsonObject();
			client = gson.<mark>fromJson</mark>(json, ClientDetailsEntity.class);
			client = validateSoftwareStatement(client);
		} catch (JsonSyntaxException e) {
			logger.error("apiAddClient failed due to JsonSyntaxException", e);
			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
			m.addAttribute(JsonErrorView.ERROR_MESSAGE, "Could not save new client. The server encountered a JSON syntax exception. Contact a system administrator for assistance.");
			return JsonErrorView.VIEWNAME;
		} catch (IllegalStateException e) {
			logger.error("apiAddClient failed due to IllegalStateException", e);
			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
			m.addAttribute(JsonErrorView.ERROR_MESSAGE, "Could not save new client. The server encountered an IllegalStateException. Refresh and try again - if the problem persists, contact a system administrator for assistance.");
			return JsonErrorView.VIEWNAME;
		} catch (ValidationException e) {
			logger.error("apiUpdateClient failed due to ValidationException", e);
			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
			m.addAttribute(JsonErrorView.ERROR_MESSAGE, "Could not update client. The server encountered a ValidationException.");
			return JsonErrorView.VIEWNAME;
		}

		// if they leave the client identifier empty, force it to be generated
		if (Strings.isNullOrEmpty(client.getClientId())) {
			client = clientService.generateClientId(client);
		}

		if (client.getTokenEndpointAuthMethod() == null ||
				client.getTokenEndpointAuthMethod().equals(AuthMethod.NONE)) {
			// we shouldn't have a secret for this client

			client.setClientSecret(null);

		} else if (client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_BASIC)
				|| client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_POST)
				|| client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_JWT)) {

			// if they've asked for us to generate a client secret (or they left it blank but require one), do so here
			if (json.<mark>has</mark>("generateClientSecret") && json.<mark>get</mark>("generateClientSecret").getAsBoolean()
					|| Strings.isNullOrEmpty(client.getClientSecret())) {
				client = clientService.generateClientSecret(client);
			}

		} else if (client.getTokenEndpointAuthMethod().equals(AuthMethod.PRIVATE_KEY)) {

			if (Strings.isNullOrEmpty(client.getJwksUri()) && client.getJwks() == null) {
				logger.error("tried to create client with private key auth but no private key");
				m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
				m.addAttribute(JsonErrorView.ERROR_MESSAGE, "Can not create a client with private key authentication without registering a key via the JWK Set URI or JWK Set Value.");
				return JsonErrorView.VIEWNAME;
			}

			// otherwise we shouldn't have a secret for this client
			client.setClientSecret(null);

		} else {

			logger.error("unknown auth method");
			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
			m.addAttribute(JsonErrorView.ERROR_MESSAGE, "Unknown auth method requested");
			return JsonErrorView.VIEWNAME;


		}

		client.setDynamicallyRegistered(false);

		try {
			ClientDetailsEntity newClient = clientService.saveNewClient(client);
			m.addAttribute(JsonEntityView.ENTITY, newClient);

			if (AuthenticationUtilities.isAdmin(auth)) {
				return ClientEntityViewForAdmins.VIEWNAME;
			} else {
				return ClientEntityViewForUsers.VIEWNAME;
			}
		} catch (IllegalArgumentException e) {
			logger.error("Unable to save client: {}", e.getMessage());
			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);
			m.addAttribute(JsonErrorView.ERROR_MESSAGE, "Unable to save client: " + e.getMessage());
			return JsonErrorView.VIEWNAME;
		} catch (PersistenceException e) {
			Throwable cause = e.getCause();
			if (cause instanceof DatabaseException) {
				Throwable databaseExceptionCause = cause.getCause();
				if(databaseExceptionCause instanceof SQLIntegrityConstraintViolationException) {
					logger.error("apiAddClient failed; duplicate client id entry found: {}", client.getClientId());
					m.addAttribute(HttpCodeView.CODE, HttpStatus.CONFLICT);
					m.addAttribute(JsonErrorView.ERROR_MESSAGE, "Unable to save client. Duplicate client id entry found: " + client.getClientId());
					return JsonErrorView.VIEWNAME;
				}
			}
			throw e;
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>rithms_____riot-api-java_____Request_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/rithms_____riot-api-java_____Request.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
	 * Retrieves the result of the request.
	 * 
	 * @param overrideStateRequirement
	 *            If set to {@code true}, this method will not check the status of the request, and thus not throw an
	 *            {@code IllegalStateException}
	 * @return The object returned by the api call, or {@code null} if the method explicitly has no return value.
	 * @throws IllegalStateException
	 *             If this request did not complete yet or did not succeed
	 * @throws RiotApiException
	 *             If parsing the Riot Api's response fails
	 */	 */
	protected synchronized void execute() throws RiotApiException, RateLimitException {
		setState(RequestState.Waiting);
		try {
			object.checkRequirements();

			// Notify RateLimitHandler
			if (config.getRateLimitHandler() != null) {
				config.getRateLimitHandler().onRequestAboutToFire(this);
			}

			URL url = new URL(object.getUrl());
			connection = (HttpURLConnection) url.openConnection();
			setTimeout();
			connection.setDoInput(true);
			connection.setInstanceFollowRedirects(false);
			connection.setRequestMethod(getHttpMethod().name());
			for (HttpHeadParameter p : object.getHttpHeadParameters()) {
				connection.setRequestProperty(p.getKey(), p.getValue());
			}
			String body = object.getBody();
			if (body != null) {
				connection.setRequestProperty("Content-Type", "application/json");
				connection.setDoOutput(true);
				DataOutputStream dos = new DataOutputStream(connection.getOutputStream());
				dos.writeBytes(body);
				dos.flush();
				dos.close();
			}
			int responseCode = connection.getResponseCode();

			// Get body
			InputStream is = null;
			if (responseCode < 400) {
				is = connection.getInputStream();
			} else {
				is = connection.getErrorStream();
			}
			StringBuilder responseBodyBuilder = new StringBuilder();
			if (responseCode != CODE_SUCCESS_NO_CONTENT && is != null) {
				BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));
				String line;
				while ((line = br.readLine()) != null) {
					responseBodyBuilder.append(line).append(System.lineSeparator());
				}
				br.close();
			}

			// Handle error (except rate limit)
			if (responseCode >= 300 && responseCode != CODE_ERROR_RATE_LIMITED) {
				RiotApiError errorDto = null;
				try {
					errorDto = <mark>new Gson</mark>().<mark>fromJson</mark>(responseBodyBuilder.toString(), RiotApiError.class);
				} catch (JsonSyntaxException e) {
					RiotApi.log.warning("[" + object + "] Request > JsonSyntaxException: " + e.getMessage());
				}
				throw new RiotApiException(responseCode, errorDto);
			}
			setResponse(new RequestResponse(connection.getResponseCode(), responseBodyBuilder.toString(), connection.getHeaderFields()));

			// Notify RateLimitHandler
			if (config.getRateLimitHandler() != null) {
				config.getRateLimitHandler().onRequestDone(this);
			}

			// Handle rate limit error
			if (responseCode == CODE_ERROR_RATE_LIMITED) {
				String retryAfterString = connection.getHeaderField("Retry-After");
				String rateLimitType = connection.getHeaderField("X-Rate-Limit-Type");
				if (retryAfterString != null) {
					int retryAfter = Integer.parseInt(retryAfterString);
					throw new RateLimitException(retryAfter, rateLimitType);
				} else {
					throw new RateLimitException(0, rateLimitType);
				}
			}

			setState(RequestState.Succeeded);
		} catch (RespectedRateLimitException e) {
			setException(e);
			setState(RequestState.Failed);
			RiotApi.log.fine("[" + object + "] Request > RespectedRateLimitException: " + e.getMessage());
			throw e;
		} catch (RateLimitException e) {
			setException(e);
			setState(RequestState.Failed);
			RiotApi.log.fine("[" + object + "] Request > RateLimitException: " + e.getMessage());
			throw e;
		} catch (RiotApiException e) {
			setException(e);
			setState(RequestState.Failed);
			RiotApi.log.fine("[" + object + "] Request > RiotApiException: " + e.getMessage());
			throw e;
		} catch (SocketTimeoutException e) {
			RiotApiException exception = new RiotApiException(RiotApiException.TIMEOUT_EXCEPTION);
			setException(exception);
			setState(RequestState.Timeout);
			RiotApi.log.fine("[" + object + "] Request > Timeout");
			throw exception;
		} catch (IOException e) {
			RiotApiException exception = new RiotApiException(RiotApiException.IOEXCEPTION);
			setException(exception);
			setState(RequestState.Failed);
			RiotApi.log.log(Level.SEVERE, "[" + object + "] Request > IOException", e);
			throw exception;
		} catch (NullPointerException e) {
			RiotApiException exception = new RiotApiException(RiotApiException.NULLPOINTEREXCEPTION);
			setException(exception);
			setState(RequestState.Failed);
			RiotApi.log.log(Level.SEVERE, "[" + object + "] Request > NullPointerException", e);
			throw exception;
		} finally {
			if (connection != null) {
				connection.disconnect();
			}
		}
	}

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>AEFeinstein_____mtg-familiar_____MarketPriceFetcher_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/AEFeinstein_____mtg-familiar_____MarketPriceFetcher.java

com.google.gson.Gson.&ltinit&gt
com.google.gson.Gson.fromJson

/**
             * Write a MarketPriceInfo to the cache with the given key
             *
             * @param cacheKey The cache key, a MtgCard object
             * @param marketPriceInfo A MarketPriceInfo to write
             * @return a Single with true if the write succeeded, or false if it didn't
             */            @Override
            public Single<MarketPriceInfo> fetch(@Nonnull MtgCard params) {
                Exception lastThrownException = new Exception(mActivity.getString(R.string.price_error_unknown));
                if (FamiliarActivity.getNetworkState(mActivity, false) == -1) { /* our context contains the activity that spawned the request */
                    return Single.error(new Exception(mActivity.getString(R.string.no_network)));
                }

                /* Initialize the API */
                TcgpApi api = new TcgpApi();
                String tokenStr = PreferenceAdapter.getTcgpApiToken(mActivity);
                Date expirationDate = PreferenceAdapter.getTcgpApiTokenExpirationDate(mActivity);
                try {
                    /* If we don't have a token or it expired */
                    if (tokenStr.isEmpty() || expirationDate.before(new Date())) {
                        /* Request a token. This will initialize the TcgpApi object */
                        AccessToken token;
                        try {
                            TcgpKeys keys = <mark>new Gson</mark>().<mark>fromJson</mark>(new InputStreamReader(mActivity.getAssets().open("tcgp_keys.json")), TcgpKeys.class);
                            token = api.getAccessToken(keys.PUBLIC_KEY, keys.PRIVATE_KEY, keys.ACCESS_TOKEN);
                            /* Save the token and expiration date */
                            PreferenceAdapter.setTcgpApiToken(mActivity, token.access_token);
                            PreferenceAdapter.setTcgpApiTokenExpirationDate(mActivity, token.expires);
                        } catch (FileNotFoundException e) {
                            return Single.error(new Exception(mActivity.getString(R.string.price_error_api_key)));
                        }
                    } else {
                        /* Make sure the token hasn't expired */
                        api.setToken(tokenStr);
                    }
                } catch (IOException e) {
                    return Single.error(new Exception(mActivity.getString(R.string.price_error_network)));
                }

                CardDbAdapter.MultiCardType multiCardType;
                String tcgSetName;

                /* then the same for multicard ordering */
                FamiliarDbHandle cardInfoHandle = new FamiliarDbHandle();
                try {
                    SQLiteDatabase database = DatabaseManager.openDatabase(mActivity, false, cardInfoHandle);

                    if (CardDbAdapter.isOnlineOnly(params.getExpansion(), database)) {
                        return Single.error(new Exception(mActivity.getString(R.string.price_error_online_only)));
                    }

                    // If the number doesn't exist, multiCardType will be MultiCardType.NOPE
                    multiCardType = CardDbAdapter.isMultiCard(params.getNumber(), params.getExpansion());

                    /* Get the TCGplayer.com set name, why can't everything be consistent? */
                    tcgSetName = CardDbAdapter.getTcgName(params.getExpansion(), database);

                } catch (SQLiteException | FamiliarDbException e) {
                    return Single.error(new Exception(mActivity.getString(R.string.price_error_database)));
                } finally {
                    DatabaseManager.closeDatabase(mActivity, cardInfoHandle);
                }

                /* If this isn't a multi-card, don't iterate so much */
                int numMultiCardOptions = 1;
                if (multiCardType != CardDbAdapter.MultiCardType.NOPE) {
                    numMultiCardOptions = 4;
                }

                /* Iterate through all possible queries for this card
                 * First (innermost loop) try the different combination of multi-card names
                 * Then (middle loop) try with and without accent marks
                 * Last (outer loop) try without a set name. This works for Schemes & Planes with weird TCGPlayer sets
                 */
                for (int setOption = 0; setOption < 2; setOption++) {
                    for (int accentOption = 0; accentOption < 2; accentOption++) {
                        for (int multiOption = 0; multiOption < numMultiCardOptions; multiOption++) {
                            String tcgCardName;
                            FamiliarDbHandle setOptHandle = new FamiliarDbHandle();
                            try {
                                SQLiteDatabase database = DatabaseManager.openDatabase(mActivity, false, setOptHandle);

                                /* Set up retries for multicard ordering */
                                if (multiCardType != CardDbAdapter.MultiCardType.NOPE) {
                                    /* Next time try the other order */
                                    switch (multiOption) {
                                        case 0:
                                            /* Try just the a side */
                                            tcgCardName = CardDbAdapter.getNameFromSetAndNumber(params.getExpansion(), params.getNumber().replace("b", "a"), database);
                                            break;
                                        case 1:
                                            /* Try just the b side */
                                            tcgCardName = CardDbAdapter.getNameFromSetAndNumber(params.getExpansion(), params.getNumber().replace("a", "b"), database);
                                            break;
                                        case 2:
                                            /* Try the combined name in one direction */
                                            tcgCardName = CardDbAdapter.getSplitName(params.getMultiverseId(), true, database);
                                            break;
                                        case 3:
                                            /* Try the combined name in the other direction */
                                            tcgCardName = CardDbAdapter.getSplitName(params.getMultiverseId(), false, database);
                                            break;
                                        default:
                                            /* Something went wrong */
                                            tcgCardName = params.getName();
                                            break;
                                    }
                                } else {
                                    /* This isn't a multicard */
                                    tcgCardName = params.getName();
                                }

                                /* Retry with accent marks removed */
                                if (accentOption == 1) {
                                    tcgCardName = CardDbAdapter.removeAccentMarks(Objects.requireNonNull(tcgCardName));
                                }

                                /* Try it with no set name */
                                if (setOption == 1) {
                                    tcgSetName = null;
                                }

                            } catch (SQLiteException | FamiliarDbException e) {
                                tcgCardName = null;
                                lastThrownException = new Exception(mActivity.getString(R.string.price_error_database));
                            } finally {
                                DatabaseManager.closeDatabase(mActivity, setOptHandle);
                            }

                            if (null != tcgCardName) {
                                try {
                                    /* Query the API, one step at a time */
                                    ProductInformation information = api.getProductInformation(tcgCardName, tcgSetName);
                                    if (information.results.length > 0) {
                                        ProductDetails details = api.getProductDetails(information.results);
                                        if (details.results.length > 0) {
                                            // Assume the first result is the best result
                                            long bestResult[] = {details.results[0].productId};
                                            String bestUrl = "";
                                            boolean okResultFound = false;
                                            // Look through all results for a perfect match
                                            for (ProductDetails.Details searchResult : details.results) {
                                                String expansion = getExpansionFromGroupId(api, context, searchResult.groupId);
                                                if (searchResult.name.toLowerCase().equals(tcgCardName.toLowerCase())) {
                                                    if (null != expansion && null != tcgSetName) {
                                                        if (expansion.toLowerCase().equals(tcgSetName.toLowerCase())) {
                                                            // Found a perfect match, including expansion!
                                                            bestResult[0] = searchResult.productId;
                                                            bestUrl = searchResult.url;
                                                            break;
                                                        }
                                                    } else {
                                                        // Found a perfect match, no expansion to match!
                                                        bestResult[0] = searchResult.productId;
                                                        bestUrl = searchResult.url;
                                                        break;
                                                    }
                                                } else if (!okResultFound && searchResult.name.toLowerCase().startsWith(tcgCardName.toLowerCase())) {
                                                    if (null != expansion && null != tcgSetName) {
                                                        if (expansion.toLowerCase().equals(tcgSetName.toLowerCase())) {
                                                            // Found a good match, including expansion!
                                                            // Set it but keep searching for a perfect match
                                                            bestResult[0] = searchResult.productId;
                                                            bestUrl = searchResult.url;
                                                            okResultFound = true;
                                                        }
                                                    } else {
                                                        // Found a good match, no expansion to match!
                                                        // Set it but keep searching for a perfect match
                                                        bestResult[0] = searchResult.productId;
                                                        bestUrl = searchResult.url;
                                                        okResultFound = true;
                                                    }
                                                }
                                            }
                                            ProductMarketPrice price = api.getProductMarketPrice(bestResult);
                                            if (price.results.length > 0) {
                                                /* Return a new MarketPriceInfo */
                                                return Single.just(new MarketPriceInfo(price.results, bestUrl));
                                            } else if (price.errors.length > 0) {
                                                /* Return the error returned by TCGPlayer */
                                                return Single.error(new Throwable(price.errors[0]));
                                            }
                                        } else if (details.errors.length > 0) {
                                            /* Return the error returned by TCGPlayer */
                                            return Single.error(new Throwable(details.errors[0]));
                                        }
                                    } else if (information.errors.length > 0) {
                                        /* Return the error returned by TCGPlayer */
                                        return Single.error(new Throwable(information.errors[0]));
                                    }
                                } catch (IOException e) {
                                    lastThrownException = new Exception(mActivity.getString(R.string.price_error_network));
                                }
                            }
                        }
                    }
                }
                return Single.error(lastThrownException);
            }

            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_12.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.fromJson

/**
     * Remove application
     *
     * @param applicationId application id
     * @throws CommandException This method helps to remove applications
     */     */
    public void deployApplication(String applicationId, String applicationPolicyId) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            String url = (ENDPOINT_DEPLOY_APPLICATION.replace("{applicationId}", applicationId)).replace("{applicationPolicyId}", applicationPolicyId);
            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL()
                    + url, "");

            String result = getHttpResponseString(response);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();
            System.out.println(gson.<mark>fromJson</mark>(result, ResponseMessageBean.class).getMessage());

        } catch (Exception e) {
            String message = "Could not deploy application: " + applicationId;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }

        //restClient.deployEntity((ENDPOINT_DEPLOY_APPLICATION.replace("{applicationId}", applicationId)).replace("{applicationPolicyId",applicationPolicyId),"application");
    }

    /**
     * Undeploy application
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void undeployApplication(String applicationId) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL()
                    + ENDPOINT_UNDEPLOY_APPLICATION.replace("{id}", applicationId), "");
            String result = getHttpResponseString(response);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();
            System.out.println(gson.<mark>fromJson</mark>(result, ResponseMessageBean.class).getMessage());
        } catch (Exception e) {
            String message = "Could not undeploy application: " + applicationId;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * Remove application
     *
     * @param applicationId application id
     * @throws CommandException This method helps to remove applications
     */
    public void deleteApplication(String applicationId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_REMOVE_APPLICATION.replace("{appId}", applicationId), applicationId,
                "application");
    }

    /**
     * Update application
     *
     * @param entityBody application definition
     * @throws CommandException
     */
    public void updateApplication(String entityBody) throws CommandException {
        restClient.updateEntity(ENDPOINT_UPDATE_APPLICATION, entityBody, "application");
    }

    /**
     * Delete autoscaling policy
     *
     * @param autoscalingPolicyId autoscaling policy id
     * @throws CommandException
     */
    public void deleteAutoSclaingPolicy(String autoscalingPolicyId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_REMOVE_AUTOSCALINGPOLICY.replace("{policyId}", autoscalingPolicyId), autoscalingPolicyId,
                "Auto-scaling policy");
    }

    /**
     * Describe application
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void describeApplication(String applicationId) throws CommandException {
        try {
            ApplicationBean application = (ApplicationBean) restClient
                    .getEntity(ENDPOINT_GET_APPLICATION, ApplicationBean.class, "{appId}", applicationId,
                            "application");

            if (application == null) {
                System.out.println("Application not found: " + applicationId);
                return;
            }

            System.out.println("Application: " + applicationId);
            System.out.println(getGson().toJson(application));
        } catch (Exception e) {
            String message = "Could not describe application: " + applicationId;
            printError(message, e);
        }
    }

    /**
     * Describe application runtime
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void describeApplicationRuntime(String applicationId) throws CommandException {
        try {
	        ApplicationInfoBean application = (ApplicationInfoBean) restClient
                    .getEntity(ENDPOINT_GET_APPLICATION_RUNTIME, ApplicationBean.class, "{applicationId}", applicationId,
                            "application");

            if (application == null) {
                System.out.println("Application Runtime not found: " + applicationId);
                return;
            }

            System.out.println("Application: " + applicationId);
            System.out.println(getGson().toJson(application));
        } catch (Exception e) {
            String message = "Could not describe application runtime: " + applicationId;
            printError(message, e);
        }
    }

    /**
     * Add application signup
     *
     * @param applicationId application id
     * @param entityBody    application signup definition
     * @throws CommandException
     */
    public void addApplicationSignup(String entityBody, String applicationId) throws CommandException {
        restClient.deployEntity(ENDPOINT_APPLICATION_SIGNUP.replace("{applicationId}", applicationId), entityBody, "application signup");
    }

    /**
     * Describe application signup
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void describeApplicationSignup(String applicationId) throws CommandException {
        try {
            ApplicationSignUpBean bean = (ApplicationSignUpBean) restClient.listEntity(ENDPOINT_APPLICATION_SIGNUP.replace("{applicationId}", applicationId),
                    ApplicationSignUpBean.class, "applicationSignup");

            if (bean == null) {
                System.out.println("Application sign up not found for application: " + applicationId);
                return;
            }

            System.out.println("Application signup for application : " + applicationId);
            System.out.println(getGson().toJson(bean));
        } catch (Exception e) {
            String message = "Could not describe application signup for application: " + applicationId;
            printError(message, e);
        }
    }

    /**
     * Delete application signup
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void deleteApplicationSignup(String applicationId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_APPLICATION_SIGNUP.replace("{applicationId}", applicationId), applicationId,
                "application signup");
    }

    /**
     * Handle exception
     *
     * @throws CommandException
     */
    private void handleException(String key, Exception e, Object... args) throws CommandException {
        if (log.isDebugEnabled()) {
            log.debug("Displaying message for {}. Exception thrown is {}", key, e.getClass());
        }

        String message = CliUtils.getMessage(key, args);
        log.error(message);
        System.out.println(message);
        throw new CommandException(message, e);
    }

    /**
     * Print error on console and log
     *
     * @param message message
     * @param e       exception
     */
    private void printError(String message, Throwable e) {
        // CLI console only get system output
        System.out.println(message);
        // Log error
        log.error(message, e);
    }

    /**
     * Add network partitions
     *
     * @param networkPartitionDefinition network partition definition
     * @throws CommandException
     */
    public void addNetworkPartition(String networkPartitionDefinition) throws CommandException {
        restClient.deployEntity(ENDPOINT_DEPLOY_NETWORK_PARTITION, networkPartitionDefinition, "network partition");
    }

    /**
     * Remove network partition
     *
     * @param networkPartitionId application id
     * @throws CommandException
     */
    public void removeNetworkPartition(String networkPartitionId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_REMOVE_NETWORK_PARTITION.replace("{id}", networkPartitionId), networkPartitionId,
                "network-partition");
    }

    /**
     * List network partitions
     *
     * @throws CommandException
     */
    public void listNetworkPartitions() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<NetworkPartitionBean>>() {
            }.getType();
            List<NetworkPartitionBean> networkPartitionsList = (List<NetworkPartitionBean>) restClient.listEntity(ENDPOINT_LIST_NETWORK_PARTITIONS,
                    listType, "network-partitions");

            if ((networkPartitionsList == null) || (networkPartitionsList.size() == 0)) {
                System.out.println("No network partitions found");
                return;
            }

            RowMapper<NetworkPartitionBean> networkPartitionMapper = new RowMapper<NetworkPartitionBean>() {
                public String[] getData(NetworkPartitionBean partition) {
                    String[] data = new String[2];
                    data[0] = partition.getId();
                    data[1] = String.valueOf(partition.getPartitions().size());
                    return data;
                }
            };

            NetworkPartitionBean[] partitions = new NetworkPartitionBean[networkPartitionsList.size()];
            partitions = networkPartitionsList.toArray(partitions);

            System.out.println("Network partitions found:");
            CliUtils.printTable(partitions, networkPartitionMapper, "Network Partition ID", "Number of Partitions");
        } catch (Exception e) {
            String message = "Error in listing network partitions";
            printError(message, e);
        }
    }

    /**
     * Update network partitions
     *
     * @param networkPartitionDefinition network partition definition
     * @throws CommandException
     */
    public void updateNetworkPartition(String networkPartitionDefinition) throws CommandException {
        restClient.updateEntity(ENDPOINT_DEPLOY_NETWORK_PARTITION, networkPartitionDefinition, "network-partition");
    }

    /**
     * Describe a network partition
     *
     * @param partitionId partition id
     * @throws CommandException
     */
    public void describeNetworkPartition(final String partitionId) throws CommandException {
        try {
            NetworkPartitionBean partition = (NetworkPartitionBean) restClient
                    .getEntity(ENDPOINT_GET_NETWORK_PARTITION, NetworkPartitionBean.class, "{networkPartitionId}", partitionId,
                            "network partition");

            if (partition == null) {
                System.out.println("Network partition not found: " + partitionId);
                return;
            }

            System.out.println("Partition: " + partitionId);
            System.out.println(getGson().toJson(partition));
        } catch (Exception e) {
            String message = "Could not describe partition: " + partitionId;
            printError(message, e);
        }
    }

    /**
     * Deploy deployment policy
     *
     * @param deploymentPolicy deployment policy definition
     * @throws CommandException
     */
    public void addDeploymentPolicy(String deploymentPolicy) throws CommandException {
        restClient.deployEntity(ENDPOINT_DEPLOY_DEPLOYMENT_POLICY, deploymentPolicy, "deployment policy");
    }

    /**
     * Deploy application policy
     *
     * @param applicationPolicy application policy definition
     * @throws CommandException
     */
    public void addApplicationPolicy(String applicationPolicy) throws CommandException {
        restClient.deployEntity(ENDPOINT_DEPLOY_APPLICATION_POLICY, applicationPolicy, "application policy");
    }

    /**
     * Update deployment policy
     *
     * @param deploymentPolicy deployment policy definition
     * @throws CommandException
     */
    public void updateDeploymentPolicy(String deploymentPolicy) throws CommandException {
        restClient.updateEntity(ENDPOINT_UPDATE_DEPLOYMENT_POLICY, deploymentPolicy, "deployment policy");
    }

    /**
     * Delete deployment policy
     *
     * @param deploymentPolicyId deployment policy definition
     * @throws CommandException
     */
    public void deleteDeploymentPolicy(String deploymentPolicyId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_REMOVE_DEPLOYMENT_POLICY.replace("{policyId}", deploymentPolicyId), deploymentPolicyId,
                "deployment policy");
    }

    /**
     * List deployment policies
     *
     * @throws CommandException
     */
    public void listDeploymentPolicies() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<DeploymentPolicyBean>>() {
            }.getType();
            List<DeploymentPolicyBean> list = (List<DeploymentPolicyBean>) restClient.listEntity(ENDPOINT_LIST_DEPLOYMENT_POLICIES,
                    listType, "deployment policies");

            if ((list == null) || (list.size() == 0)) {
                System.out.println("No deployment policies found");
                return;
            }

            RowMapper<DeploymentPolicyBean> rowMapper = new RowMapper<DeploymentPolicyBean>() {

                public String[] getData(DeploymentPolicyBean policy) {
                    String[] data = new String[2];
                    data[0] = policy.getId();
                    data[1] = String.valueOf(policy.getNetworkPartitions().size());
                    return data;
                }
            };

            DeploymentPolicyBean[] array = new DeploymentPolicyBean[list.size()];
            array = list.toArray(array);

            System.out.println("Deployment policies found:");
            CliUtils.printTable(array, rowMapper, "ID", "Accessibility");
        } catch (Exception e) {
            String message = "Could not list deployment policies";
            printError(message, e);
        }
    }

    /**
     * List application policies
     *
     * @throws CommandException
     */
    public void listApplicationPolicies() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<ApplicationPolicyBean>>() {
            }.getType();
            List<ApplicationPolicyBean> list = (List<ApplicationPolicyBean>) restClient.listEntity(ENDPOINT_LIST_APPLICATION_POLICIES,
                    listType, "application policies");

            if ((list == null) || (list.size() == 0)) {
                System.out.println("No application policies found");
                return;
            }

            RowMapper<ApplicationPolicyBean> rowMapper = new RowMapper<ApplicationPolicyBean>() {

                public String[] getData(ApplicationPolicyBean policy) {
                    String[] data = new String[3];
                    data[0] = policy.getId();
                    data[1] = String.valueOf(policy.getNetworkPartitions().length);
                    data[2] = policy.getAlgorithm();
                    return data;
                }
            };

            ApplicationPolicyBean[] array = new ApplicationPolicyBean[list.size()];
            array = list.toArray(array);

            System.out.println("Application policies found:");
            CliUtils.printTable(array, rowMapper, "ID", "No of network partitions", "algorithm");
        } catch (Exception e) {
            String message = "Could not list application policies";
            printError(message, e);
        }
    }

    /**
     * Delete application policy
     * param applicationPolicyId application policy id
     *
     * @throws CommandException
     */
    public void deleteApplicationPolicy(String applicationPolicyId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_REMOVE_APPLICATION_POLICY.replace("{policyId}", applicationPolicyId), applicationPolicyId,
                "application policy");
    }

    /**
     * Update application policy
     *
     * @param applicationPolicy application policy definition
     * @throws CommandException
     */
    public void updateApplicationPolicy(String applicationPolicy) throws CommandException {
        restClient.updateEntity(ENDPOINT_UPDATE_APPLICATION_POLICY, applicationPolicy, "application policy");
    }


}
            </pre>
          </div>
        </div>

        
        <hr class="col-lg-12 col-md-12 mb-12">
        <div class="row">
          <div class="col-lg-12 col-md-12 mb-12">
            <h6>apache_____stratos_____RestCommandLineService_2.java</h6>
            <pre class="prettyprint">
/ssd1/dayen/analogy/data/qual_study/com_google_gson/apache_____stratos_____RestCommandLineService.java

com.google.gson.GsonBuilder.&ltinit&gt
com.google.gson.GsonBuilder.create
com.google.gson.Gson.toJson
com.google.gson.Gson.fromJson

/**
     * Describe a tenant
     *
     * @param domainName domain name
     * @throws org.apache.stratos.cli.exception.CommandException
     */
    private ClusterBean getClusterObjectFromString(String resultString) {
        String tmp;
        if (resultString.startsWith("{\"cluster\"")) {
            tmp = resultString.substring("{\"cluster\"".length() + 1, resultString.length() - 1);
            resultString = tmp;
        }
        GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
        Gson gson = gsonBuilder.<mark>create</mark>();
        return gson.<mark>fromJson</mark>(resultString, ClusterBean.class);
    }

    /**
     * Add new tenant
     *
     * @param admin     username
     * @param firstName first name
     * @param lastName  last name
     * @param password  password
     * @param domain    domain name
     * @param email     email
     * @throws CommandException
     */
    public void addTenant(String admin, String firstName, String lastName, String password, String domain, String email)
            throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            TenantInfoBean tenantInfo = new TenantInfoBean();
            tenantInfo.setAdmin(admin);
            tenantInfo.setFirstName(firstName);
            tenantInfo.setLastName(lastName);
            tenantInfo.setAdminPassword(password);
            tenantInfo.setTenantDomain(domain);
            tenantInfo.setEmail(email);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            String jsonString = gson.<mark>toJson</mark>(tenantInfo, TenantInfoBean.class);
            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL()
                    + ENDPOINT_ADD_TENANT, jsonString);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode == 201) {
                System.out.println("Tenant added successfully: " + domain);
            } else {
                String resultString = CliUtils.getHttpResponseString(response);
                String errorMsg = gson.<mark>fromJson</mark>(resultString, ResponseMessageBean.class).getMessage();
                System.out.println(errorMsg);
            }
        } catch (Exception e) {
            String message = "Could not add tenant: " + domain;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * Describe a tenant
     *
     * @param domainName domain name
     * @throws org.apache.stratos.cli.exception.CommandException
     */
    public void describeTenant(final String domainName) throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<TenantInfoBean>>() {
            }.getType();
            List<TenantInfoBean> tenantList = (List<TenantInfoBean>) restClient.listEntity(ENDPOINT_LIST_TENANTS,
                    listType, "tenant");

            TenantInfoBean tenant = null;
            for (TenantInfoBean item : tenantList) {
                if (item.getTenantDomain().equals(domainName)) {
                    tenant = item;
                    break;
                }
            }

            if (tenant == null) {
                System.out.println("Tenant not found");
                return;
            }

            System.out.println("-------------------------------------");
            System.out.println("Tenant Information:");
            System.out.println("-------------------------------------");
            System.out.println("Tenant domain: " + tenant.getTenantDomain());
            System.out.println("ID: " + tenant.getTenantId());
            System.out.println("Email: " + tenant.getEmail());
            System.out.println("Active: " + tenant.isActive());
            System.out.println("Created date: " + new Date(tenant.getCreatedDate()));

        } catch (Exception e) {
            String message = "Error in describing tenant: " + domainName;
            printError(message, e);
        }
    }

    /**
     * List tenants by a partial domain search
     *
     * @param partialDomain Part of the domain name
     * @throws org.apache.stratos.cli.exception.CommandException
     */
    public void listTenantsByPartialDomain(String partialDomain) throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<TenantInfoBean>>() {
            }.getType();
            List<TenantInfoBean> tenantList = (List<TenantInfoBean>) restClient.listEntity(ENDPOINT_LIST_TENANTS_BY_PARTIAL_DOMAIN.replace("{tenantDomain}", partialDomain),
                    listType, "tenants");

            if ((tenantList == null) || (tenantList.size() == 0)) {
                System.out.println("No tenants found");
                return;
            }

            RowMapper<TenantInfoBean> tenantMapper = new RowMapper<TenantInfoBean>() {
                public String[] getData(TenantInfoBean tenant) {
                    String[] data = new String[5];
                    data[0] = tenant.getTenantDomain();
                    data[1] = String.valueOf(tenant.getTenantId());
                    data[2] = String.valueOf(tenant.isActive());
                    data[3] = tenant.getEmail();
                    data[4] = new Date(tenant.getCreatedDate()).toString();
                    return data;
                }
            };

            TenantInfoBean[] tenants = new TenantInfoBean[tenantList.size()];
            tenants = tenantList.toArray(tenants);

            System.out.println("Tenants found:");
            CliUtils.printTable(tenants, tenantMapper, "tenantDomain", "tenantID", "active", "email", "createdDate");
        } catch (Exception e) {
            String message = "Error in listing tenants";
            printError(message, e);
        }
    }

    /**
     * Update an existing tenant
     *
     * @param id        tenant id
     * @param admin     username
     * @param firstName first name
     * @param lastName  last name
     * @param password  password
     * @param domain    domain name
     * @param email     email
     * @throws CommandException
     */
    public void updateTenant(int id, String admin, String firstName, String lastName, String password, String domain, String email)
            throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            TenantInfoBean tenantInfo = new TenantInfoBean();
            tenantInfo.setAdmin(admin);
            tenantInfo.setFirstName(firstName);
            tenantInfo.setLastName(lastName);
            tenantInfo.setAdminPassword(password);
            tenantInfo.setTenantDomain(domain);
            tenantInfo.setEmail(email);
            tenantInfo.setTenantId(id);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            String jsonString = gson.<mark>toJson</mark>(tenantInfo, TenantInfoBean.class);

            HttpResponse response = restClient.doPut(httpClient, restClient.getBaseURL()
                    + ENDPOINT_UPDATE_TENANT, jsonString);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode < 200 || responseCode >= 300) {
                String resultString = CliUtils.getHttpResponseString(response);
                String errorMsg = gson.<mark>fromJson</mark>(resultString, ResponseMessageBean.class).getMessage();
                System.out.println(errorMsg);

            } else {
                System.out.println("Tenant updated successfully: " + domain);
            }
        } catch (Exception e) {
            String message = "Could not update tenant: " + domain;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * Add user
     *
     * @param userName    username
     * @param credential  password
     * @param role        user role
     * @param firstName   first name
     * @param lastName    last name
     * @param email       email
     * @param profileName profile name
     * @throws CommandException
     */
    public void addUser(String userName, String credential, String role, String firstName, String lastName, String email, String profileName)
            throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            UserInfoBean userInfoBean = new UserInfoBean();
            userInfoBean.setUserName(userName);
            userInfoBean.setCredential(credential);
            userInfoBean.setRole(role);
            userInfoBean.setFirstName(firstName);
            userInfoBean.setLastName(lastName);
            userInfoBean.setEmail(email);
            userInfoBean.setProfileName(profileName);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            String jsonString = gson.<mark>toJson</mark>(userInfoBean, UserInfoBean.class);

            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL()
                    + ENDPOINT_ADD_USER, jsonString);

            String result = getHttpResponseString(response);
            System.out.println(gson.<mark>fromJson</mark>(result, ResponseMessageBean.class).getMessage());

        } catch (Exception e) {
            String message = "Could not add user: " + userName;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * Update user
     *
     * @param userName    username
     * @param credential  password
     * @param role        user role
     * @param firstName   first name
     * @param lastName    last name
     * @param email       email
     * @param profileName profile name
     * @throws CommandException
     */
    public void updateUser(String userName, String credential, String role, String firstName, String lastName, String email, String profileName)
            throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            UserInfoBean userInfoBean = new UserInfoBean();
            userInfoBean.setUserName(userName);
            userInfoBean.setCredential(credential);
            userInfoBean.setRole(role);
            userInfoBean.setFirstName(firstName);
            userInfoBean.setLastName(lastName);
            userInfoBean.setEmail(email);
            userInfoBean.setProfileName(profileName);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            String jsonString = gson.<mark>toJson</mark>(userInfoBean, UserInfoBean.class);

            HttpResponse response = restClient.doPut(httpClient, restClient.getBaseURL()
                    + ENDPOINT_UPDATE_USER, jsonString);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode < 200 || responseCode >= 300) {
                CliUtils.printError(response);
            } else {
                System.out.println("User updated successfully: " + userName);
            }
        } catch (Exception e) {
            String message = "Could not update user: " + userName;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * Delete tenant
     *
     * @param tenantDomain domain name of the tenant
     * @throws CommandException
     */
    public void deleteTenant(String tenantDomain) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doDelete(httpClient, restClient.getBaseURL()
                    + ENDPOINT_ADD_TENANT + "/" + tenantDomain);

            String responseCode = "" + response.getStatusLine().getStatusCode();

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            if (responseCode.equals(CliConstants.RESPONSE_OK)) {
                System.out.println("You have successfully deleted the tenant: " + tenantDomain);
            } else {
                String resultString = CliUtils.getHttpResponseString(response);
                ExceptionMapper exception = gson.<mark>fromJson</mark>(resultString, ExceptionMapper.class);
                System.out.println(exception);
            }

        } catch (Exception e) {
            String message = "Could not delete tenant: " + tenantDomain;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * Delete user
     *
     * @param userName username
     * @throws CommandException
     */
    public void deleteUser(String userName) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doDelete(httpClient, restClient.getBaseURL()
                    + ENDPOINT_ADD_USER + "/" + userName);

            String resultString = CliUtils.getHttpResponseString(response);
            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();
            System.out.println(gson.<mark>fromJson</mark>(resultString, ResponseMessageBean.class).getMessage());
        } catch (Exception e) {
            String message = "Could not delete user: " + userName;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * Deactivate tenant
     *
     * @param tenantDomain domain name of the tenant
     * @throws CommandException
     */
    public void deactivateTenant(String tenantDomain) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doPut(httpClient, restClient.getBaseURL()
                    + ENDPOINT_DEACTIVATE_TENANT.replace("{tenantDomain}", tenantDomain), "");

            String responseCode = "" + response.getStatusLine().getStatusCode();

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            if (responseCode.equals(CliConstants.RESPONSE_OK)) {
                System.out.println("You have successfully deactivated the tenant: " + tenantDomain);
                return;
            } else {
                String resultString = CliUtils.getHttpResponseString(response);
                String errorMsg = gson.<mark>fromJson</mark>(resultString, ResponseMessageBean.class).getMessage();
                System.out.println(errorMsg);
            }

        } catch (Exception e) {
            String message = "Could not de-activate tenant: " + tenantDomain;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * Activate tenant
     *
     * @param tenantDomain domain name of the tenant
     * @throws CommandException
     */
    public void activateTenant(String tenantDomain) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doPut(httpClient, restClient.getBaseURL()
                    + ENDPOINT_ACTIVATE_TENANT.replace("{tenantDomain}", tenantDomain), "");

            String responseCode = "" + response.getStatusLine().getStatusCode();

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            if (responseCode.equals(CliConstants.RESPONSE_OK)) {
                System.out.println("You have successfully activated the tenant: " + tenantDomain);
            } else {
                String resultString = CliUtils.getHttpResponseString(response);
                String errorMsg = gson.<mark>fromJson</mark>(resultString, ResponseMessageBean.class).getMessage();
                System.out.println(errorMsg);
            }

        } catch (Exception e) {
            String message = "Could not activate tenant: " + tenantDomain;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * List tenants
     *
     * @throws CommandException
     */
    public void listTenants() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<TenantInfoBean>>() {
            }.getType();
            List<TenantInfoBean> tenantInfoList = (List<TenantInfoBean>) restClient.listEntity(ENDPOINT_LIST_TENANTS,
                    listType, "tenants");

            if ((tenantInfoList == null) || (tenantInfoList.size() == 0)) {
                System.out.println("No tenants found");
                return;
            }

            RowMapper<TenantInfoBean> rowMapper = new RowMapper<TenantInfoBean>() {
                public String[] getData(TenantInfoBean tenantInfo) {
                    String[] data = new String[5];
                    data[0] = tenantInfo.getTenantDomain();
                    data[1] = "" + tenantInfo.getTenantId();
                    data[2] = tenantInfo.getEmail();
                    data[3] = tenantInfo.isActive() ? "Active" : "De-active";
                    data[4] = new Date(tenantInfo.getCreatedDate()).toString();
                    return data;
                }
            };

            TenantInfoBean[] tenantArray = new TenantInfoBean[tenantInfoList.size()];
            tenantArray = tenantInfoList.toArray(tenantArray);

            System.out.println("Tenants:");
            CliUtils.printTable(tenantArray, rowMapper, "Domain", "Tenant ID", "Email", "State", "Created Date");
        } catch (Exception e) {
            String message = "Could not list tenants";
            printError(message, e);
        }
    }

    /**
     * List all users
     *
     * @throws CommandException
     */
    public void listAllUsers() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<UserInfoBean>>() {
            }.getType();
            List<UserInfoBean> userInfoList = (List<UserInfoBean>) restClient.listEntity(ENDPOINT_LIST_USERS,
                    listType, "users");

            if ((userInfoList == null) || (userInfoList.size() == 0)) {
                System.out.println("No users found");
                return;
            }

            RowMapper<UserInfoBean> rowMapper = new RowMapper<UserInfoBean>() {
                public String[] getData(UserInfoBean userInfo) {
                    String[] data = new String[2];
                    data[0] = userInfo.getUserName();
                    data[1] = userInfo.getRole();
                    return data;
                }
            };

            UserInfoBean[] usersArray = new UserInfoBean[userInfoList.size()];
            usersArray = userInfoList.toArray(usersArray);

            System.out.println("Users:");
            CliUtils.printTable(usersArray, rowMapper, "Username", "Role");
        } catch (Exception e) {
            String message = "Could not list users";
            printError(message, e);
        }
    }

    /**
     * Add cartridge
     *
     * @param cartridgeDefinition cartridge definition
     * @throws CommandException
     */
    public void addCartridge(String cartridgeDefinition) throws CommandException {
        restClient.deployEntity(ENDPOINT_DEPLOY_CARTRIDGE, cartridgeDefinition, "cartridge");
    }

    /**
     * Update cartridge
     *
     * @param cartridgeDefinition cartridge definition
     * @throws CommandException
     */
    public void updateCartridge(String cartridgeDefinition) throws CommandException {
        restClient.updateEntity(ENDPOINT_DEPLOY_CARTRIDGE, cartridgeDefinition, "cartridge");
    }

    /**
     * Undeploy cartridge
     *
     * @param cartridgeId cartridge Id
     * @throws CommandException
     */
    public void undeployCartrigdeDefinition(String cartridgeId) throws CommandException {
        restClient.undeployEntity(ENDPOINT_UNDEPLOY_CARTRIDGE, "cartridge", cartridgeId);
    }

    /**
     * Deploy autoscaling policy
     *
     * @param autoScalingPolicy autoscaling policy definition
     * @throws CommandException
     */
    public void addAutoscalingPolicy(String autoScalingPolicy) throws CommandException {
        restClient.deployEntity(ENDPOINT_DEPLOY_AUTOSCALING_POLICY, autoScalingPolicy, "autoscaling policy");
    }

    /**
     * Update autoscaling policy
     *
     * @param autoScalingPolicy autoscaling policy definition
     * @throws CommandException
     */
    public void updateAutoscalingPolicy(String autoScalingPolicy) throws CommandException {
        restClient.updateEntity(ENDPOINT_UPDATE_AUTOSCALING_POLICY, autoScalingPolicy, "autoscaling policy");
    }

    /**
     * List applications
     *
     * @throws CommandException
     */
    public void listApplications() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<ApplicationBean>>() {
            }.getType();
            List<ApplicationBean> list = (List<ApplicationBean>) restClient.listEntity(ENDPOINT_LIST_APPLICATION,
                    listType, "applications");

            if ((list == null) || (list.size() == 0)) {
                System.out.println("No applications found");
                return;
            }

            RowMapper<ApplicationBean> rowMapper = new RowMapper<ApplicationBean>() {
                public String[] getData(ApplicationBean applicationDefinition) {
                    String[] data = new String[3];
                    data[0] = applicationDefinition.getApplicationId();
                    data[1] = applicationDefinition.getAlias();
                    data[2] = applicationDefinition.getStatus();
                    return data;
                }
            };

            ApplicationBean[] array = new ApplicationBean[list.size()];
            array = list.toArray(array);

            System.out.println("Applications found:");
            CliUtils.printTable(array, rowMapper, "Application ID", "Alias", "Status");
        } catch (Exception e) {
            String message = "Could not list applications";
            printError(message, e);
        }
    }

    /**
     * List autoscaling policies
     *
     * @throws CommandException
     */
    public void listAutoscalingPolicies() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<AutoscalePolicyBean>>() {
            }.getType();
            List<AutoscalePolicyBean> list = (List<AutoscalePolicyBean>) restClient.listEntity(ENDPOINT_LIST_AUTOSCALING_POLICIES,
                    listType, "autoscaling policies");

            if ((list == null) || (list.size() == 0)) {
                System.out.println("No autoscaling policies found");
                return;
            }

            RowMapper<AutoscalePolicyBean> rowMapper = new RowMapper<AutoscalePolicyBean>() {

                public String[] getData(AutoscalePolicyBean policy) {
                    String[] data = new String[4];
                    data[0] = policy.getId();
                    data[1] = String.valueOf(policy.getLoadThresholds().getRequestsInFlight().getThreshold());
                    data[2] = String.valueOf(policy.getLoadThresholds().getMemoryConsumption().getThreshold());
                    data[3] = String.valueOf(policy.getLoadThresholds().getLoadAverage().getThreshold());
                    return data;
                }
            };

            AutoscalePolicyBean[] array = new AutoscalePolicyBean[list.size()];
            array = list.toArray(array);

            System.out.println("Autoscaling policies found:");
            CliUtils.printTable(array, rowMapper, "ID", "Requests In Flight Threshold", "Memory Consumption Threshold",
                    "Load Average Threshold");
        } catch (Exception e) {
            String message = "Could not list autoscaling policies";
            printError(message, e);
        }
    }

    /**
     * Describe deployment policy
     *
     * @param deploymentPolicyId deployment policy id
     * @throws CommandException
     */
    public void describeDeploymentPolicy(String deploymentPolicyId) throws CommandException {
        try {
            DeploymentPolicyBean policy = (DeploymentPolicyBean) restClient.getEntity(ENDPOINT_GET_DEPLOYMENT_POLICY,
                    DeploymentPolicyBean.class, "{deploymentPolicyId}", deploymentPolicyId, "deployment policy");

            if (policy == null) {
                System.out.println("Deployment policy not found: " + deploymentPolicyId);
                return;
            }

            System.out.println("Deployment policy: " + deploymentPolicyId);
            System.out.println(getGson().<mark>toJson</mark>(policy));
        } catch (Exception e) {
            String message = "Error in describing deployment policy: " + deploymentPolicyId;
            printError(message, e);
        }
    }

    /**
     * Describe application policy
     *
     * @param applicationPolicyId application policy id
     * @throws CommandException
     */
    public void describeApplicationPolicy(String applicationPolicyId) throws CommandException {
        try {
            ApplicationPolicyBean policy = (ApplicationPolicyBean) restClient.getEntity(ENDPOINT_GET_APPLICATION_POLICY,
                    ApplicationPolicyBean.class, "{applicationPolicyId}", applicationPolicyId, "application policy");

            if (policy == null) {
                System.out.println("Application policy not found: " + applicationPolicyId);
                return;
            }

            System.out.println("Application policy: " + applicationPolicyId);
            System.out.println(getGson().<mark>toJson</mark>(policy));
        } catch (Exception e) {
            String message = "Error in describing application policy: " + applicationPolicyId;
            printError(message, e);
        }
    }

    /**
     * Describe autoscaling policy
     *
     * @param autoscalingPolicyId application policy id
     * @throws CommandException
     */
    public void describeAutoScalingPolicy(String autoscalingPolicyId) throws CommandException {
        try {
            AutoscalePolicyBean policy = (AutoscalePolicyBean) restClient.getEntity(ENDPOINT_GET_AUTOSCALING_POLICY,
                    AutoscalePolicyBean.class, "{id}", autoscalingPolicyId, "autoscaling policy");

            if (policy == null) {
                System.out.println("Autoscaling policy not found: " + autoscalingPolicyId);
                return;
            }

            System.out.println("Autoscaling policy: " + autoscalingPolicyId);
            System.out.println(getGson().<mark>toJson</mark>(policy));
        } catch (Exception e) {
            String message = "Could not describe autoscaling policy: " + autoscalingPolicyId;
            printError(message, e);
        }
    }

    /**
     * Add Kubernetes Cluster
     *
     * @param entityBody Kubernetes Cluster definition
     * @throws CommandException
     */
    public void addKubernetesCluster(String entityBody) throws CommandException {
        restClient.deployEntity(ENDPOINT_DEPLOY_KUBERNETES_CLUSTER, entityBody, "kubernetes cluster");
    }

    /**
     * List Kubernetes Clusters
     *
     * @throws CommandException
     */
    public void listKubernetesClusters() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<KubernetesClusterBean>>() {
            }.getType();
            List<KubernetesClusterBean> list = (List<KubernetesClusterBean>) restClient.
                    listEntity(ENDPOINT_LIST_KUBERNETES_CLUSTERS, listType, "kubernetes cluster");
            if ((list != null) && (list.size() > 0)) {
                RowMapper<KubernetesClusterBean> partitionMapper = new RowMapper<KubernetesClusterBean>() {
                    public String[] getData(KubernetesClusterBean kubernetesCluster) {
                        String[] data = new String[2];
                        data[0] = kubernetesCluster.getClusterId();
                        data[1] = kubernetesCluster.getDescription();
                        return data;
                    }
                };

                KubernetesClusterBean[] array = new KubernetesClusterBean[list.size()];
                array = list.toArray(array);
                System.out.println("Kubernetes clusters found:");
                CliUtils.printTable(array, partitionMapper, "Group ID", "Description");
            } else {
                System.out.println("No Kubernetes clusters found");
            }
        } catch (Exception e) {
            String message = "Could not list Kubernetes clusters";
            printError(message, e);
        }
    }

    /**
     * Undeploy Kubernetes Cluster
     *
     * @param clusterId cluster id
     * @throws CommandException
     */
    public void undeployKubernetesCluster(String clusterId) throws CommandException {
        restClient.undeployEntity(ENDPOINT_UNDEPLOY_KUBERNETES_CLUSTER, "kubernetes cluster", clusterId);
    }

    /**
     * Add Kubernetes Host
     *
     * @param entityBody kubernetes host definition
     * @param clusterId  cluster id
     * @throws CommandException
     */
    public void addKubernetesHost(String entityBody, String clusterId) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL()
                    + ENDPOINT_DEPLOY_KUBERNETES_HOST.replace("{kubernetesClusterId}", clusterId), entityBody);

            String responseCode = "" + response.getStatusLine().getStatusCode();

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();

            if (responseCode.equals(CliConstants.RESPONSE_OK) || responseCode.equals(CliConstants.RESPONSE_CREATED)) {
                System.out.println("You have successfully deployed host to Kubernetes cluster: " + clusterId);
            } else {
                String resultString = CliUtils.getHttpResponseString(response);
                ExceptionMapper exception = gson.<mark>fromJson</mark>(resultString, ExceptionMapper.class);
                System.out.println(exception);
            }

        } catch (Exception e) {
            String message = "Could not add host to Kubernetes cluster: " + clusterId;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * List Kubernetes Hosts
     *
     * @param clusterId cluster id
     * @throws CommandException
     */
    public void listKubernetesHosts(String clusterId) throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<KubernetesHostBean>>() {
            }.getType();
            List<KubernetesHostBean> list = (List<KubernetesHostBean>) restClient.listEntity(ENDPOINT_LIST_KUBERNETES_HOSTS.replace("{kubernetesClusterId}", clusterId),
                    listType, "kubernetes host");
            if ((list != null) && (list.size() > 0)) {
                RowMapper<KubernetesHostBean> partitionMapper = new RowMapper<KubernetesHostBean>() {
                    public String[] getData(KubernetesHostBean kubernetesHost) {
                        String[] data = new String[4];
                        data[0] = kubernetesHost.getHostId();
                        data[1] = kubernetesHost.getHostname();
                        data[2] = emptyStringIfNullOrEmpty(kubernetesHost.getPrivateIPAddress());
                        data[3] = emptyStringIfNullOrEmpty(kubernetesHost.getPublicIPAddress());
                        return data;
                    }
                };

                KubernetesHostBean[] array = new KubernetesHostBean[list.size()];
                array = list.toArray(array);
                System.out.println("Kubernetes hosts found:");
                CliUtils.printTable(array, partitionMapper, "Host ID", "Hostname", "Private IP Address",
                        "Public IP Address");
            } else {
                System.out.println("No kubernetes hosts found");
            }
        } catch (Exception e) {
            String message = "Could not list kubernetes hosts";
            printError(message, e);
        }
    }

    private String emptyStringIfNullOrEmpty(String value) {
        return StringUtils.isBlank(value) ? "" : value;
    }

    /**
     * Get the master of a Kubernetes Cluster
     *
     * @param clusterId cluster id
     * @throws CommandException
     */
    public void getKubernetesMaster(String clusterId) throws CommandException {
        try {
            Type listType = new TypeToken<KubernetesMasterBean>() {
            }.getType();
            KubernetesMasterBean master = (KubernetesMasterBean) restClient
                    .getEntity(ENDPOINT_GET_KUBERNETES_MASTER, KubernetesMasterBean.class, "{kubernetesClusterId}", clusterId,
                            "network partition");

            if (master == null) {
                System.out.println("Kubernetes master not found in: " + clusterId);
                return;
            }

            System.out.println("Cluster: " + clusterId);
            System.out.println(getGson().<mark>toJson</mark>(master));
        } catch (Exception e) {
            String message = "Could not get the master of " + clusterId;
            printError(message, e);
        }
    }

    /**
     * Describe a Kubernetes cluster
     *
     * @param clusterId cluster id
     * @throws CommandException
     */
    public void describeKubernetesCluster(String clusterId) throws CommandException {
        try {
            Type listType = new TypeToken<KubernetesClusterBean>() {
            }.getType();
            KubernetesClusterBean cluster = (KubernetesClusterBean) restClient
                    .getEntity(ENDPOINT_GET_KUBERNETES_HOST_CLUSTER, KubernetesClusterBean.class, "{kubernetesClusterId}", clusterId,
                            "kubernetes cluster");

            if (cluster == null) {
                System.out.println("Kubernetes cluster not found: " + clusterId);
                return;
            }

            System.out.println("Kubernetes cluster: " + clusterId);
            System.out.println(getGson().<mark>toJson</mark>(cluster));
        } catch (Exception e) {
            String message = "Could not describe Kubernetes cluster: " + clusterId;
            printError(message, e);
        }
    }

    /**
     * Add Domain mappings
     *
     * @param applicationId       application id
     * @param resourceFileContent domain mapping definition
     * @throws CommandException
     */
    public void addDomainMappings(String applicationId, String resourceFileContent) throws CommandException {
        String endpoint = ENDPOINT_DOMAIN_MAPPINGS.replace("{applicationId}", applicationId);
        restClient.deployEntity(endpoint, resourceFileContent, "domain mappings");
    }

    /**
     * List domain mappings
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void listDomainMappings(String applicationId) throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<DomainMappingBean>>() {
            }.getType();
            List<DomainMappingBean> list = (List<DomainMappingBean>) restClient.listEntity(
                    ENDPOINT_DOMAIN_MAPPINGS.replace("{applicationId}", applicationId),
                    listType, "domain mappings");
            if (list == null) {
                System.out.println("No domain mappings found in application: " + applicationId);
                return;
            }

            RowMapper<DomainMappingBean> rowMapper = new RowMapper<DomainMappingBean>() {
                public String[] getData(DomainMappingBean domainMappingBean) {
                    String[] data = new String[2];
                    data[0] = domainMappingBean.getDomainName();
                    data[1] = domainMappingBean.getContextPath();
                    return data;
                }
            };

            DomainMappingBean[] array = new DomainMappingBean[list.size()];
            array = list.toArray(array);
            System.out.println("Domain mappings found in application: " + applicationId);
            CliUtils.printTable(array, rowMapper, "Domain Name", "Context Path");
        } catch (Exception e) {
            String message = "Could not list domain mappings in application: " + applicationId;
            printError(message, e);
        }
    }

    /**
     * Remove Domain Mappings
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void removeDomainMappings(String applicationId, String domainName) throws CommandException {
        String endpoint = (ENDPOINT_REMOVE_DOMAIN_MAPPINGS.replace("{applicationId}",
                applicationId)).replace("{domainName}", domainName);
        restClient.undeployEntity(endpoint, "domain mappings", applicationId);
    }

    /**
     * Undeploy Kubernetes Host
     *
     * @param clusterId cluster id
     * @param hostId    host id
     * @throws CommandException
     */
    public void undeployKubernetesHost(String clusterId, String hostId) throws CommandException {
        restClient.undeployEntity(ENDPOINT_UNDEPLOY_KUBERNETES_HOST.replace("{kubernetesClusterId}", clusterId), "kubernetes host", hostId);
    }

    /**
     * Update Kubernetes Master
     *
     * @param entityBody Kubernetes master definition
     * @param clusterId  cluster id
     * @throws CommandException
     */
    public void updateKubernetesMaster(String entityBody, String clusterId) throws CommandException {
        restClient.updateEntity(ENDPOINT_UPDATE_KUBERNETES_MASTER.replace("{kubernetesClusterId}", clusterId), entityBody, "kubernetes master");
    }

    /**
     * Update Kubernetes Host
     *
     * @param entityBody Kubernetes host definition
     * @throws CommandException
     */
    public void updateKubernetesHost(String entityBody) throws CommandException {
        restClient.updateEntity(ENDPOINT_UPDATE_KUBERNETES_HOST, entityBody, "kubernetes host");
    }

    /**
     * Synchronize artifacts
     *
     * @param cartridgeAlias alias of the cartridge
     * @throws CommandException
     */
    public void synchronizeArtifacts(String cartridgeAlias) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL() + ENDPOINT_SYNCHRONIZE_ARTIFACTS.replace("{subscriptionAlias}", cartridgeAlias), cartridgeAlias);

            String responseCode = "" + response.getStatusLine().getStatusCode();

            if (responseCode.equals(CliConstants.RESPONSE_OK)) {
                System.out.println(String.format("Synchronizing artifacts for cartridge subscription alias: %s", cartridgeAlias));
            } else {
                GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
                Gson gson = gsonBuilder.<mark>create</mark>();
                String resultString = CliUtils.getHttpResponseString(response);
                ExceptionMapper exception = gson.<mark>fromJson</mark>(resultString, ExceptionMapper.class);
                System.out.println(exception);
            }
        } catch (Exception e) {
            String message = "Could not synchronize artifacts for cartridge subscription alias: " + cartridgeAlias;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * Add cartridge group
     *
     * @param entityBody cartridge group definition
     * @throws CommandException
     */
    public void addCartridgeGroup(String entityBody) throws CommandException {
        restClient.deployEntity(ENDPOINT_DEPLOY_SERVICE_GROUP, entityBody, "cartridge group");
    }

    /**
     * Undeploy Cartridge group
     *
     * @param groupDefinitionName cartridge group name
     * @throws CommandException
     */
    public void undeployServiceGroup(String groupDefinitionName) throws CommandException {
        restClient.undeployEntity(ENDPOINT_UNDEPLOY_SERVICE_GROUP, "cartridge group", groupDefinitionName);
    }

    /**
     * Describe service group
     *
     * @param groupDefinitionName cartridge group name
     * @throws CommandException
     */
    public void describeServiceGroup(String groupDefinitionName) throws CommandException {
        try {
            CartridgeGroupBean bean = (CartridgeGroupBean) restClient.listEntity(ENDPOINT_LIST_SERVICE_GROUP.replace("{groupDefinitionName}", groupDefinitionName),
                    CartridgeGroupBean.class, "serviceGroup");

            if (bean == null) {
                System.out.println("Cartridge group not found: " + groupDefinitionName);
                return;
            }

            System.out.println("Service Group : " + groupDefinitionName);
            System.out.println(getGson().<mark>toJson</mark>(bean));
        } catch (Exception e) {
            String message = "Could not describe cartridge group: " + groupDefinitionName;
            printError(message, e);
        }
    }

    /**
     * Add application
     *
     * @param entityBody application definition
     * @throws CommandException
     */
    public void addApplication(String entityBody) throws CommandException {
        restClient.deployEntity(ENDPOINT_ADD_APPLICATION, entityBody, "application");
    }

    /**
     * Deploy application
     *
     * @param applicationId       application id
     * @param applicationPolicyId application policy id
     * @throws CommandException
     */
    public void deployApplication(String applicationId, String applicationPolicyId) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            String url = (ENDPOINT_DEPLOY_APPLICATION.replace("{applicationId}", applicationId)).replace("{applicationPolicyId}", applicationPolicyId);
            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL()
                    + url, "");

            String result = getHttpResponseString(response);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();
            System.out.println(gson.<mark>fromJson</mark>(result, ResponseMessageBean.class).getMessage());

        } catch (Exception e) {
            String message = "Could not deploy application: " + applicationId;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }

        //restClient.deployEntity((ENDPOINT_DEPLOY_APPLICATION.replace("{applicationId}", applicationId)).replace("{applicationPolicyId",applicationPolicyId),"application");
    }

    /**
     * Undeploy application
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void undeployApplication(String applicationId) throws CommandException {
        DefaultHttpClient httpClient = new DefaultHttpClient();
        try {
            HttpResponse response = restClient.doPost(httpClient, restClient.getBaseURL()
                    + ENDPOINT_UNDEPLOY_APPLICATION.replace("{id}", applicationId), "");
            String result = getHttpResponseString(response);

            GsonBuilder gsonBuilder = <mark>new GsonBuilder</mark>();
            Gson gson = gsonBuilder.<mark>create</mark>();
            System.out.println(gson.<mark>fromJson</mark>(result, ResponseMessageBean.class).getMessage());
        } catch (Exception e) {
            String message = "Could not undeploy application: " + applicationId;
            printError(message, e);
        } finally {
            httpClient.getConnectionManager().shutdown();
        }
    }

    /**
     * Remove application
     *
     * @param applicationId application id
     * @throws CommandException This method helps to remove applications
     */
    public void deleteApplication(String applicationId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_REMOVE_APPLICATION.replace("{appId}", applicationId), applicationId,
                "application");
    }

    /**
     * Update application
     *
     * @param entityBody application definition
     * @throws CommandException
     */
    public void updateApplication(String entityBody) throws CommandException {
        restClient.updateEntity(ENDPOINT_UPDATE_APPLICATION, entityBody, "application");
    }

    /**
     * Delete autoscaling policy
     *
     * @param autoscalingPolicyId autoscaling policy id
     * @throws CommandException
     */
    public void deleteAutoSclaingPolicy(String autoscalingPolicyId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_REMOVE_AUTOSCALINGPOLICY.replace("{policyId}", autoscalingPolicyId), autoscalingPolicyId,
                "Auto-scaling policy");
    }

    /**
     * Describe application
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void describeApplication(String applicationId) throws CommandException {
        try {
            ApplicationBean application = (ApplicationBean) restClient
                    .getEntity(ENDPOINT_GET_APPLICATION, ApplicationBean.class, "{appId}", applicationId,
                            "application");

            if (application == null) {
                System.out.println("Application not found: " + applicationId);
                return;
            }

            System.out.println("Application: " + applicationId);
            System.out.println(getGson().<mark>toJson</mark>(application));
        } catch (Exception e) {
            String message = "Could not describe application: " + applicationId;
            printError(message, e);
        }
    }

    /**
     * Describe application runtime
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void describeApplicationRuntime(String applicationId) throws CommandException {
        try {
	        ApplicationInfoBean application = (ApplicationInfoBean) restClient
                    .getEntity(ENDPOINT_GET_APPLICATION_RUNTIME, ApplicationBean.class, "{applicationId}", applicationId,
                            "application");

            if (application == null) {
                System.out.println("Application Runtime not found: " + applicationId);
                return;
            }

            System.out.println("Application: " + applicationId);
            System.out.println(getGson().<mark>toJson</mark>(application));
        } catch (Exception e) {
            String message = "Could not describe application runtime: " + applicationId;
            printError(message, e);
        }
    }

    /**
     * Add application signup
     *
     * @param applicationId application id
     * @param entityBody    application signup definition
     * @throws CommandException
     */
    public void addApplicationSignup(String entityBody, String applicationId) throws CommandException {
        restClient.deployEntity(ENDPOINT_APPLICATION_SIGNUP.replace("{applicationId}", applicationId), entityBody, "application signup");
    }

    /**
     * Describe application signup
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void describeApplicationSignup(String applicationId) throws CommandException {
        try {
            ApplicationSignUpBean bean = (ApplicationSignUpBean) restClient.listEntity(ENDPOINT_APPLICATION_SIGNUP.replace("{applicationId}", applicationId),
                    ApplicationSignUpBean.class, "applicationSignup");

            if (bean == null) {
                System.out.println("Application sign up not found for application: " + applicationId);
                return;
            }

            System.out.println("Application signup for application : " + applicationId);
            System.out.println(getGson().<mark>toJson</mark>(bean));
        } catch (Exception e) {
            String message = "Could not describe application signup for application: " + applicationId;
            printError(message, e);
        }
    }

    /**
     * Delete application signup
     *
     * @param applicationId application id
     * @throws CommandException
     */
    public void deleteApplicationSignup(String applicationId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_APPLICATION_SIGNUP.replace("{applicationId}", applicationId), applicationId,
                "application signup");
    }

    /**
     * Handle exception
     *
     * @throws CommandException
     */
    private void handleException(String key, Exception e, Object... args) throws CommandException {
        if (log.isDebugEnabled()) {
            log.debug("Displaying message for {}. Exception thrown is {}", key, e.getClass());
        }

        String message = CliUtils.getMessage(key, args);
        log.error(message);
        System.out.println(message);
        throw new CommandException(message, e);
    }

    /**
     * Print error on console and log
     *
     * @param message message
     * @param e       exception
     */
    private void printError(String message, Throwable e) {
        // CLI console only get system output
        System.out.println(message);
        // Log error
        log.error(message, e);
    }

    /**
     * Add network partitions
     *
     * @param networkPartitionDefinition network partition definition
     * @throws CommandException
     */
    public void addNetworkPartition(String networkPartitionDefinition) throws CommandException {
        restClient.deployEntity(ENDPOINT_DEPLOY_NETWORK_PARTITION, networkPartitionDefinition, "network partition");
    }

    /**
     * Remove network partition
     *
     * @param networkPartitionId application id
     * @throws CommandException
     */
    public void removeNetworkPartition(String networkPartitionId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_REMOVE_NETWORK_PARTITION.replace("{id}", networkPartitionId), networkPartitionId,
                "network-partition");
    }

    /**
     * List network partitions
     *
     * @throws CommandException
     */
    public void listNetworkPartitions() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<NetworkPartitionBean>>() {
            }.getType();
            List<NetworkPartitionBean> networkPartitionsList = (List<NetworkPartitionBean>) restClient.listEntity(ENDPOINT_LIST_NETWORK_PARTITIONS,
                    listType, "network-partitions");

            if ((networkPartitionsList == null) || (networkPartitionsList.size() == 0)) {
                System.out.println("No network partitions found");
                return;
            }

            RowMapper<NetworkPartitionBean> networkPartitionMapper = new RowMapper<NetworkPartitionBean>() {
                public String[] getData(NetworkPartitionBean partition) {
                    String[] data = new String[2];
                    data[0] = partition.getId();
                    data[1] = String.valueOf(partition.getPartitions().size());
                    return data;
                }
            };

            NetworkPartitionBean[] partitions = new NetworkPartitionBean[networkPartitionsList.size()];
            partitions = networkPartitionsList.toArray(partitions);

            System.out.println("Network partitions found:");
            CliUtils.printTable(partitions, networkPartitionMapper, "Network Partition ID", "Number of Partitions");
        } catch (Exception e) {
            String message = "Error in listing network partitions";
            printError(message, e);
        }
    }

    /**
     * Update network partitions
     *
     * @param networkPartitionDefinition network partition definition
     * @throws CommandException
     */
    public void updateNetworkPartition(String networkPartitionDefinition) throws CommandException {
        restClient.updateEntity(ENDPOINT_DEPLOY_NETWORK_PARTITION, networkPartitionDefinition, "network-partition");
    }

    /**
     * Describe a network partition
     *
     * @param partitionId partition id
     * @throws CommandException
     */
    public void describeNetworkPartition(final String partitionId) throws CommandException {
        try {
            NetworkPartitionBean partition = (NetworkPartitionBean) restClient
                    .getEntity(ENDPOINT_GET_NETWORK_PARTITION, NetworkPartitionBean.class, "{networkPartitionId}", partitionId,
                            "network partition");

            if (partition == null) {
                System.out.println("Network partition not found: " + partitionId);
                return;
            }

            System.out.println("Partition: " + partitionId);
            System.out.println(getGson().<mark>toJson</mark>(partition));
        } catch (Exception e) {
            String message = "Could not describe partition: " + partitionId;
            printError(message, e);
        }
    }

    /**
     * Deploy deployment policy
     *
     * @param deploymentPolicy deployment policy definition
     * @throws CommandException
     */
    public void addDeploymentPolicy(String deploymentPolicy) throws CommandException {
        restClient.deployEntity(ENDPOINT_DEPLOY_DEPLOYMENT_POLICY, deploymentPolicy, "deployment policy");
    }

    /**
     * Deploy application policy
     *
     * @param applicationPolicy application policy definition
     * @throws CommandException
     */
    public void addApplicationPolicy(String applicationPolicy) throws CommandException {
        restClient.deployEntity(ENDPOINT_DEPLOY_APPLICATION_POLICY, applicationPolicy, "application policy");
    }

    /**
     * Update deployment policy
     *
     * @param deploymentPolicy deployment policy definition
     * @throws CommandException
     */
    public void updateDeploymentPolicy(String deploymentPolicy) throws CommandException {
        restClient.updateEntity(ENDPOINT_UPDATE_DEPLOYMENT_POLICY, deploymentPolicy, "deployment policy");
    }

    /**
     * Delete deployment policy
     *
     * @param deploymentPolicyId deployment policy definition
     * @throws CommandException
     */
    public void deleteDeploymentPolicy(String deploymentPolicyId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_REMOVE_DEPLOYMENT_POLICY.replace("{policyId}", deploymentPolicyId), deploymentPolicyId,
                "deployment policy");
    }

    /**
     * List deployment policies
     *
     * @throws CommandException
     */
    public void listDeploymentPolicies() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<DeploymentPolicyBean>>() {
            }.getType();
            List<DeploymentPolicyBean> list = (List<DeploymentPolicyBean>) restClient.listEntity(ENDPOINT_LIST_DEPLOYMENT_POLICIES,
                    listType, "deployment policies");

            if ((list == null) || (list.size() == 0)) {
                System.out.println("No deployment policies found");
                return;
            }

            RowMapper<DeploymentPolicyBean> rowMapper = new RowMapper<DeploymentPolicyBean>() {

                public String[] getData(DeploymentPolicyBean policy) {
                    String[] data = new String[2];
                    data[0] = policy.getId();
                    data[1] = String.valueOf(policy.getNetworkPartitions().size());
                    return data;
                }
            };

            DeploymentPolicyBean[] array = new DeploymentPolicyBean[list.size()];
            array = list.toArray(array);

            System.out.println("Deployment policies found:");
            CliUtils.printTable(array, rowMapper, "ID", "Accessibility");
        } catch (Exception e) {
            String message = "Could not list deployment policies";
            printError(message, e);
        }
    }

    /**
     * List application policies
     *
     * @throws CommandException
     */
    public void listApplicationPolicies() throws CommandException {
        try {
            Type listType = new TypeToken<ArrayList<ApplicationPolicyBean>>() {
            }.getType();
            List<ApplicationPolicyBean> list = (List<ApplicationPolicyBean>) restClient.listEntity(ENDPOINT_LIST_APPLICATION_POLICIES,
                    listType, "application policies");

            if ((list == null) || (list.size() == 0)) {
                System.out.println("No application policies found");
                return;
            }

            RowMapper<ApplicationPolicyBean> rowMapper = new RowMapper<ApplicationPolicyBean>() {

                public String[] getData(ApplicationPolicyBean policy) {
                    String[] data = new String[3];
                    data[0] = policy.getId();
                    data[1] = String.valueOf(policy.getNetworkPartitions().length);
                    data[2] = policy.getAlgorithm();
                    return data;
                }
            };

            ApplicationPolicyBean[] array = new ApplicationPolicyBean[list.size()];
            array = list.toArray(array);

            System.out.println("Application policies found:");
            CliUtils.printTable(array, rowMapper, "ID", "No of network partitions", "algorithm");
        } catch (Exception e) {
            String message = "Could not list application policies";
            printError(message, e);
        }
    }

    /**
     * Delete application policy
     * param applicationPolicyId application policy id
     *
     * @throws CommandException
     */
    public void deleteApplicationPolicy(String applicationPolicyId) throws CommandException {
        restClient.deleteEntity(ENDPOINT_REMOVE_APPLICATION_POLICY.replace("{policyId}", applicationPolicyId), applicationPolicyId,
                "application policy");
    }

    /**
     * Update application policy
     *
     * @param applicationPolicy application policy definition
     * @throws CommandException
     */
    public void updateApplicationPolicy(String applicationPolicy) throws CommandException {
        restClient.updateEntity(ENDPOINT_UPDATE_APPLICATION_POLICY, applicationPolicy, "application policy");
    }


}
            </pre>
          </div>
        </div>

        
  </div>
  <!-- /.container -->


</body>

</html>

        